{"version":3,"sources":["common/MeshAlgorithm.js","geometry/Geometry.js","geometry/Collection.js","geometry/Point.js","geometry/LineString.js","geometry/Polygon.js","geometry/LinearRing.js","geometry/MultiPolygon.js","geometry/MultiPolyline.js","geometry/GeometryAlgorithm.js","feedback/Feedback.js","feedback/FeedbackController.js","Bounds.js","Map.js","MecatorTransform.js","Tile.js","ShapeOptionTypeEnum.js","GeometryTransform.js","Proj4Transform.js","TileRequestController.js","layer/Layer.js","layer/WholeLayer.js","layer/WholeTileLayer.js","layer/WholeCanvasLayer.js","layer/FrozenCanvasLayer.js","layer/VectorLayer.js","layer/MeshLayer.js","LayerRender.js","layer/TileJSONLayer.js","layer/EditLayer-new.js","layer/FeedbackLayer.js","layer/GuideLineLayer.js","layer/GridLayer.js","layer/TileBoundsLayer.js","layer/OverlayLayer.js","ajax.js","Parallel.js","scene/SceneLayer.js","scene/Scene.js","scene/SceneController.js","snap/SnapActor.js","snap/FeatureSnapActor.js","snap/FullScreenFeatureSnapActor.js","snap/GivenPointSnapActor.js","snap/GivenFeatureSnapActor.js","snap/GivenObjectSnapActor.js","snap/NearestLocationSnapActor.js","snap/NearestVertexSnapActor.js","snap/MeshBorderSnapActor.js","snap/SnapController.js","source/Source.js","source/ClassicalSource.js","source/InfoSource.js","source/DeletionLinkSource.js","source/SourceController.js","FeatureSelector.js","symbol/Point.js","symbol/Matrix.js","symbol/Vector.js","symbol/LineSegment.js","symbol/LineString.js","symbol/Polygon.js","symbol/Bound.js","symbol/Template.js","symbol/Transformation.js","symbol/Symbol.js","symbol/MarkerSymbol.js","symbol/CircleMarkerSymbol.js","symbol/SquareMarkerSymbol.js","symbol/RectangleMarkerSymbol.js","symbol/CrossMarkerSymbol.js","symbol/TiltedCrossMarkerSymbol.js","symbol/TriangleMarkerSymbol.js","symbol/ImageLoader.js","symbol/ImageMarkerSymbol.js","symbol/MultiImageMarkerSymbol.js","symbol/TextMarkerSymbol.js","symbol/CompositeMarkerSymbol.js","symbol/LineSymbol.js","symbol/SimpleLineSymbol.js","symbol/CartoLineSymbol.js","symbol/MarkerLineSymbol.js","symbol/HashLineSymbol.js","symbol/TextLineSymbol.js","symbol/CenterTextLineSymbol.js","symbol/EndMarkerLineSymbol.js","symbol/CenterMarkerLineSymbol.js","symbol/CompositeLineSymbol.js","symbol/FillSymbol.js","symbol/SimpleFillSymbol.js","symbol/PatternFillSymbol.js","symbol/LinearGradientFillSymbol.js","symbol/RadialGradientFillSymbol.js","symbol/CenterMarkerFillSymbol.js","symbol/CompositeFillSymbol.js","symbol/ResourceFactory.js","symbol/SymbolFactory.js","symbol/GeometryFactory.js","symbol/GeometryTransform.js","render/initRender.js","render/data/DataModel.js","render/renderer/Render.js","render/renderer/Renderer.js","render/highlight/GeoLiveHighlight.js","render/highlight/HighlightController.js","render/highlight/FlashHighlightController.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5TA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACneA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7xBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACt8BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC9dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AChHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACxDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC3DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC5HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/EA;AACA;AACA;AACA;AACA;AACA;ACLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC1YA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AC/FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"mapApi.min.js","sourcesContent":["/**\n * Created by Chenx on 2017/7/10.\n * Class 1:25000\n */\nFM.mapApi.MeshAlgorithm = L.Class.extend({\n    /*\n     *  \n     *\n     *  @param{number}lat                       \n     *  @param{number}remainder                 \n     */\n    CalculateIdealRowIndex: function (lat, remainder) {\n        //  =  - 0.0\n        var regionLatitude = lat - 0.0;\n        // \n        var secondLatitude = regionLatitude * 3600;\n        var longsecond;\n        // *10(0.000010.036)\n        if (secondLatitude * 1000 < 0) {\n            longsecond = Math.ceil(secondLatitude * 1000);\n        } else {\n            longsecond = Math.floor(secondLatitude * 1000);\n        }\n        remainder = (longsecond % 300000);\n        return {\n            value: Math.floor(longsecond / 300000),\n            reminder: remainder\n        };\n    },\n    /*\n     *  \n     *\n     *  @param{number}lat                       \n     *  @param{number}remainder                 \n     */\n    CalculateRealRowIndex: function (lat, remainder) {\n        // \n        var idealRow = this.CalculateIdealRowIndex(lat, remainder);\n        switch (idealRow % 3) {\n            case 0: // \n                if (300000 - idealRow.remainder <= 12) {\n                    idealRow.value++;\n                }\n                break;\n            case 1: // \n                break;\n            case 2: // \n                if (idealRow.remainder < 12) {\n                    idealRow.value--;\n                }\n                break;\n            default:\n                break;\n        }\n        return idealRow;\n    },\n    /**\n     * \n     * @param {Number} lon       \n     * @param {Number} remainder [description]\n     */\n    CalculateRealColumnIndex: function (lon, remainder) {\n        return this.CalculateIdealColumnIndex(lon, remainder);\n    },\n    /*\n     * \n     *\n     *  @param{number}lon                \n     *  @param{number}reminder            \n     */\n    CalculateIdealColumnIndex: function (lon, remainder) {\n        //  =  - 60.0\n        var regionLongitude = lon - 60.0;\n        // \n        var secondLongitude = regionLongitude * 3600;\n        // *10(0.000010.036)\n        var longsecond = Math.floor(secondLongitude * 1000);\n        remainder = Math.floor(longsecond % 450000);\n        return {\n            value: Math.floor(longsecond / 450000),\n            reminder: remainder\n        };\n    },\n    /**\n     * \n     * \n     * @param {[type]} lon \n     * @param {[type]} lat \n     */\n    CalculateMesh_25T: function (lon, lat) {\n        var remainder = 0;\n        var rowResult = this.CalculateRealRowIndex(lat, remainder);\n        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);\n        // 12 : 1.5\n        var M1M2 = Math.floor(lat * 1.5);\n        // 34 :  60\n        var M3M4 = Math.floor(lon) - 60;\n        // 5 :\n        var M5 = rowResult.value % 8;\n        // 6 : 4508\n        var M6 = colResult.value % 8;\n        // ,\n        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;\n        while (sMeshId.length < 6) {\n            sMeshId = '0' + sMeshId;\n        }\n        return sMeshId;\n    },\n    /**\n     * \n     * @param {[type]} lon \n     * @param {[type]} lat \n     */\n    MeshLocator_25T: function (lon, lat) {\n        // \n        if ((this.GetBorderModel_25T(lon, lat) & 0x0F) == 0x01) {\n            lat += 0.00001;\n        }\n        var remainder = 0;\n        var rowResult = this.CalculateRealRowIndex(lat, remainder);\n        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);\n        // 12 : 1.5\n        var M1M2 = Math.floor(lat * 1.5);\n        // 34 :  60\n        var M3M4 = Math.floor(lon) - 60;\n        // 5 :\n        var M5 = rowResult.value % 8;\n        // 6 : 4508\n        var M6 = colResult.value % 8;\n        // ,\n        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;\n        while (sMeshId.length < 6) {\n            sMeshId = '0' + sMeshId;\n        }\n        return sMeshId;\n    },\n    /**\n     * 25T\n     * @param {LatLng} latlng \n     * @return {Array} \n     */\n    GetMeshes_25T: function (latlng) {\n        var lon = latlng.lng;\n        var lat = latlng.lat;\n        var meshes = [];\n        var meshId;\n        var borderModal = this.GetBorderModel_25T(lon, lat);\n        var tmpLat,\n            tmpLon;\n        // \n        if ((borderModal & 0x0F) == 0x01) {\n            tmpLat = lat + 0.00001;\n            meshId = this.CalculateMesh_25T(lon, tmpLat);\n            meshes.push(meshId);\n\n            tmpLat = lat - 0.00001;\n            meshId = this.CalculateMesh_25T(lon, tmpLat);\n            meshes.push(meshId);\n\n            if ((borderModal & 0xF0) == 0x10) {\n                tmpLon = lon - 0.00001;\n                tmpLat = lat + 0.00001;\n                meshId = this.CalculateMesh_25T(tmpLon, tmpLat);\n                meshes.push(meshId);\n\n                tmpLat = lat - 0.00001;\n                meshId = this.CalculateMesh_25T(tmpLon, tmpLat);\n                meshes.push(meshId);\n            }\n        } else if ((borderModal & 0xF0) == 0x10) { // \n            tmpLat = lat;\n            tmpLon = lon + 0.00001;\n            meshId = this.CalculateMesh_25T(tmpLon, tmpLat);\n            meshes.push(meshId);\n\n            tmpLon = lon - 0.00001;\n            meshId = this.CalculateMesh_25T(tmpLon, tmpLat);\n            meshes.push(meshId);\n        }\n\n        // \n        if (borderModal == 0) {\n            meshes.push(this.CalculateMesh_25T(lon, lat));\n        }\n\n        return meshes;\n    },\n    /**\n     * ,,\n     *\n     * @param {L.Latlng}point   \n     */\n    Calculate25TMeshId: function (point) {\n        var mesh = this.MeshLocator_25T(point.lng, point.lat);\n        return mesh;\n    },\n    /**\n     * \n     *\n     * @param{L.Latlng}point          \n     */\n    Calculate25TMeshCorner: function (point) {\n        return this.Calculate25TMeshCornerByMeshId(this.Calculate25TMeshId(point));\n    },\n    /**\n     * \n     * @param {String}mesh\n     * @returns {*}\n     * @constructor\n     */\n    Calculate25TMeshCornerByMeshId: function (mesh) {\n        var cc = mesh.split('');\n        var M1 = parseInt(cc[0], 0);\n        var M2 = parseInt(cc[1], 0);\n        var M3 = parseInt(cc[2], 0);\n        var M4 = parseInt(cc[3], 0);\n        var M5 = parseInt(cc[4], 0);\n        var M6 = parseInt(cc[5], 0);\n        var x = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;\n        var y = (M1 * 10 + M2) * 2400 + M5 * 300;\n        var point = L.latLng(y / 3600.0, x / 3600.0);\n        return point;\n    },\n    /**\n     *  border\n     * @param {String}mesh\n     * @returns {{minLon:\n     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),\n     *   minLat:\n     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat),\n     *   maxLon:\n     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),\n     *   maxLat:\n     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat)}}\n     * @constructor\n     */\n    Calculate25TMeshBorder: function (mesh) {\n        var cc = mesh.split('');\n        var M1 = parseInt(cc[0], 0);\n        var M2 = parseInt(cc[1], 0);\n        var M3 = parseInt(cc[2], 0);\n        var M4 = parseInt(cc[3], 0);\n        var M5 = parseInt(cc[4], 0);\n        var M6 = parseInt(cc[5], 0);\n        var xConner = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;\n        var yConner = (M1 * 10 + M2) * 2400 + M5 * 300;\n        var xUpper = xConner + 450.0;\n        var yUpper = yConner + 300.0;\n        var leftBottom = L.latLng(yConner / 3600.0, xConner / 3600.0);\n        var rightTop = L.latLng(yUpper / 3600.0, xUpper / 3600.0);\n        return {\n            minLon: leftBottom.lng,\n            minLat: leftBottom.lat,\n            maxLon: rightTop.lng,\n            maxLat: rightTop.lat\n        };\n    },\n    /**\n     * \n     * @param{number}lon               \n     * @param{number}lat               \n     */\n    GetBorderModel_25T: function (lon, lat) {\n        var model = 0;\n        var remainder = 0;\n        var rowResult = this.CalculateIdealRowIndex(lat, remainder);\n        switch (rowResult.value % 3) {\n            case 0: // \n                if (300000 - rowResult.reminder == 12) {\n                    model |= 0x01;\n                } else if (rowResult.reminder == 0) model |= 0x01;\n                break;\n            case 1: // \n                break;\n            case 2: // \n                if (rowResult.reminder == 12) {\n                    model |= 0x01;\n                }\n                break;\n            default:\n                break;\n        }\n        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);\n        if (colResult.reminder == 0) model |= 0x10;\n        return model;\n    },\n    /**\n     * 25T\n     * @param {LatLng} latlng \n     * @return {Boolean}\n     */\n    IsOnMeshBorder_25T: function (latlng) {\n        var model = this.GetBorderModel_25T(latlng.lng, latlng.lat);\n\n        return (model & 0x0F) == 0x01 || (model & 0xF0) == 0x10;\n    },\n    /**\n     * \n     * @return {[type]} [description]\n     */\n    destroy: function () {\n        fastmap.mapApi.MeshAlgorithm.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.MeshAlgorithm.instance) {\n                fastmap.mapApi.MeshAlgorithm.instance =\n                    new fastmap.mapApi.MeshAlgorithm();\n            }\n            return fastmap.mapApi.MeshAlgorithm.instance;\n        }\n    }\n});\n","/**\n * Geometry\n * leaflet\n *\n * @namespace mapApi\n * @class Geometry\n */\nfastmap.mapApi.Geometry = L.Class.extend({\n    /**\n     * \n     * type\n     * @property type\n     * @type String\n     */\n    type: 'Geometry',\n\n    /**\n     * @method initialize\n     * \n     *\n     */\n    initialize: function () {\n        this.bounds = null;\n    },\n\n    /**\n     * .\n     * @method clone\n     * @return {!fastmap.mapApi.Geometry} Clone.\n     */\n    clone: fastmap.abstractMethod,\n\n    /**\n     * .\n     * @method  getExtent\n     * @param {fastmap.mapApi.Extent} opt_extent Extent.\n     * @return {fastmap.mapApi.Extent} extent Extent.\n     */\n    getExtent: fastmap.abstractMethod,\n\n    /**\n     * \n     */\n    clearBounds: function () {\n        this.bounds = null;\n        if (this.parent) {\n            this.parent.clearBounds();\n        }\n    },\n\n    /**\n     * wkt\n     * @method fromWkt\n     *\n     * @param {string} wkt.\n     * @return {fastmap.mapApi.Geometry} geometry.\n     */\n    fromWkt: function (wkt) {\n        return null;\n    },\n\n    /**\n     * wkt\n     * @method toWkt\n     *\n     * @return {string} geoJsonString.\n     */\n    toWkt: function () {\n        return '';\n    },\n\n    /**\n     * \n     * @method distanceTo\n     *\n     * @param {fastmap.mapApi.Geometry} \n     * @param {Object} Optional \n     *\n     * @return {Number | Object} \n     */\n    distanceTo: function (geometry, options) {\n\n    }\n});\n\n/**\n * Function: OpenLayers.Geometry.fromWKT\n * Generate a geometry given a Well-Known Text string.  For this method to\n *     work, you must include the OpenLayers.Format.WKT in your build\n *     explicitly.\n *\n * Parameters:\n * wkt - {String} A string representing the geometry in Well-Known Text.\n *\n * Returns:\n * {<OpenLayers.Geometry>} A geometry of the appropriate class.\n */\nfastmap.mapApi.Geometry.fromWKT = function (wkt) {\n    var geom;\n    // if (OpenLayers.Format && OpenLayers.Format.WKT) {\n    //     var format = OpenLayers.Geometry.fromWKT.format;\n    //     if (!format) {\n    //         format = new OpenLayers.Format.WKT();\n    //         OpenLayers.Geometry.fromWKT.format = format;\n    //     }\n    //     var result = format.read(wkt);\n    //     if (result instanceof OpenLayers.Feature.Vector) {\n    //         geom = result.geometry;\n    //     } else if (OpenLayers.Util.isArray(result)) {\n    //         var len = result.length;\n    //         var components = new Array(len);\n    //         for (var i = 0; i < len; ++i) {\n    //             components[i] = result[i].geometry;\n    //         }\n    //         geom = new OpenLayers.Geometry.Collection(components);\n    //     }\n    // }\n    return geom;\n};\n\n/**\n * Method: OpenLayers.Geometry.segmentsIntersect\n * Determine whether two line segments intersect.  Optionally calculates\n *     and returns the intersection point.  This function is optimized for\n *     cases where seg1.x2 >= seg2.x1 || seg2.x2 >= seg1.x1.  In those\n *     obvious cases where there is no intersection, the function should\n *     not be called.\n *\n * Parameters:\n * seg1 - {Object} Object representing a segment with properties x1, y1, x2,\n *     and y2.  The start point is represented by x1 and y1.  The end point\n *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.\n * seg2 - {Object} Object representing a segment with properties x1, y1, x2,\n *     and y2.  The start point is represented by x1 and y1.  The end point\n *     is represented by x2 and y2.  Start and end are ordered so that x1 < x2.\n * options - {Object} Optional properties for calculating the intersection.\n *\n * Valid options:\n * point - {Boolean} Return the intersection point.  If false, the actual\n *     intersection point will not be calculated.  If true and the segments\n *     intersect, the intersection point will be returned.  If true and\n *     the segments do not intersect, false will be returned.  If true and\n *     the segments are coincident, true will be returned.\n * tolerance - {Number} If a non-null value is provided, if the segments are\n *     within the tolerance distance, this will be considered an intersection.\n *     In addition, if the point option is true and the calculated intersection\n *     is within the tolerance distance of an end point, the endpoint will be\n *     returned instead of the calculated intersection.  Further, if the\n *     intersection is within the tolerance of endpoints on both segments, or\n *     if two segment endpoints are within the tolerance distance of eachother\n *     (but no intersection is otherwise calculated), an endpoint on the\n *     first segment provided will be returned.\n *\n * Returns:\n * {Boolean | <OpenLayers.Geometry.Point>}  The two segments intersect.\n *     If the point argument is true, the return will be the intersection\n *     point or false if none exists.  If point is true and the segments\n *     are coincident, return will be true (and the instersection is equal\n *     to the shorter segment).\n */\nfastmap.mapApi.Geometry.segmentsIntersect = function (seg1, seg2, options) {\n    var point = options && options.point;\n    var tolerance = options && options.tolerance;\n    var intersection = false;\n    var x1121 = seg1.x1 - seg2.x1;\n    var y1121 = seg1.y1 - seg2.y1;\n    var x1211 = seg1.x2 - seg1.x1;\n    var y1211 = seg1.y2 - seg1.y1;\n    var y2221 = seg2.y2 - seg2.y1;\n    var x2221 = seg2.x2 - seg2.x1;\n    var d = (y2221 * x1211) - (x2221 * y1211);\n    var n1 = (x2221 * y1121) - (y2221 * x1121);\n    var n2 = (x1211 * y1121) - (y1211 * x1121);\n    if (d == 0) {\n        // parallel\n        if (n1 == 0 && n2 == 0) {\n            // coincident\n            intersection = true;\n        }\n    } else {\n        var along1 = n1 / d;\n        var along2 = n2 / d;\n        if (along1 >= 0 && along1 <= 1 && along2 >= 0 && along2 <= 1) {\n            // intersect\n            if (!point) {\n                intersection = true;\n            } else {\n                // calculate the intersection point\n                var px = seg1.x1 + (along1 * x1211);\n                var py = seg1.y1 + (along1 * y1211);\n                intersection = new fastmap.mapApi.Point(px, py);\n            }\n        }\n    }\n    if (tolerance) {\n        var dist;\n        var segs = [seg1, seg2];\n        var seg;\n        var x;\n        var y;\n        var i;\n        var j;\n        if (intersection) {\n            if (point) {\n                // check segment endpoints for proximity to intersection\n                // set intersection to first endpoint within the tolerance\n                outer: for (i = 0; i < 2; ++i) {\n                    seg = segs[i];\n                    for (j = 1; j < 3; ++j) {\n                        x = seg['x' + j];\n                        y = seg['y' + j];\n                        dist = Math.sqrt(\n                                Math.pow(x - intersection.x, 2) +\n                                Math.pow(y - intersection.y, 2)\n                        );\n                        if (dist < tolerance) {\n                            intersection.x = x;\n                            intersection.y = y;\n                            break outer;\n                        }\n                    }\n                }\n            }\n        } else {\n            // no calculated intersection, but segments could be within\n            // the tolerance of one another\n            var source,\n                target,\n                p,\n                result;\n            // check segment endpoints for proximity to intersection\n            // set intersection to first endpoint within the tolerance\n            outer: for (i = 0; i < 2; ++i) {\n                source = segs[i];\n                target = segs[(i + 1) % 2];\n                for (j = 1; j < 3; ++j) {\n                    p = { x: source['x' + j], y: source['y' + j] };\n                    result = fastmap.mapApi.Geometry.distanceToSegment(p, target);\n                    if (result.distance < tolerance) {\n                        if (point) {\n                            intersection = new fastmap.mapApi.Point(p.x, p.y);\n                        } else {\n                            intersection = true;\n                        }\n                        break outer;\n                    }\n                }\n            }\n        }\n    }\n    return intersection;\n};\n\n/**\n * Function: OpenLayers.Geometry.distanceToSegment\n *\n * Parameters:\n * point - {Object} An object with x and y properties representing the\n *     point coordinates.\n * segment - {Object} An object with x1, y1, x2, and y2 properties\n *     representing endpoint coordinates.\n *\n * Returns:\n * {Object} An object with distance, along, x, and y properties.  The distance\n *     will be the shortest distance between the input point and segment.\n *     The x and y properties represent the coordinates along the segment\n *     where the shortest distance meets the segment. The along attribute\n *     describes how far between the two segment points the given point is.\n */\nfastmap.mapApi.Geometry.distanceToSegment = function (point, segment) {\n    var result = fastmap.mapApi.Geometry.distanceSquaredToSegment(point, segment);\n    result.distance = Math.sqrt(result.distance);\n    return result;\n};\n\n/**\n * Function: OpenLayers.Geometry.distanceSquaredToSegment\n *\n * Usually the distanceToSegment function should be used. This variant however\n * can be used for comparisons where the exact distance is not important.\n *\n * Parameters:\n * point - {Object} An object with x and y properties representing the\n *     point coordinates.\n * segment - {Object} An object with x1, y1, x2, and y2 properties\n *     representing endpoint coordinates.\n *\n * Returns:\n * {Object} An object with squared distance, along, x, and y properties.\n *     The distance will be the shortest distance between the input point and\n *     segment. The x and y properties represent the coordinates along the\n *     segment where the shortest distance meets the segment. The along\n *     attribute describes how far between the two segment points the given\n *     point is.\n */\nfastmap.mapApi.Geometry.distanceSquaredToSegment = function (point, segment) {\n    var x0 = point.x;\n    var y0 = point.y;\n    var x1 = segment.x1;\n    var y1 = segment.y1;\n    var x2 = segment.x2;\n    var y2 = segment.y2;\n    var dx = x2 - x1;\n    var dy = y2 - y1;\n    var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /\n        (Math.pow(dx, 2) + Math.pow(dy, 2));\n    var x,\n        y;\n    if (along <= 0.0) {\n        x = x1;\n        y = y1;\n    } else if (along >= 1.0) {\n        x = x2;\n        y = y2;\n    } else {\n        x = x1 + along * dx;\n        y = y1 + along * dy;\n    }\n    return {\n        distance: Math.pow(x - x0, 2) + Math.pow(y - y0, 2),\n        x: x,\n        y: y,\n        along: along\n    };\n};\n\nfastmap.mapApi.geometry = function () {\n    return new fastmap.mapApi.Geometry();\n};\n","/**\n * Created by zhongxiaoming on 2015/10/14.\n * Class Collection \n */\nfastmap.mapApi.Collection = fastmap.mapApi.Geometry.extend({\n\n    /**\n     * \n     * type\n     * @property type\n     * @type Collection\n     */\n    type: 'Collection',\n\n    /**\n     * \n     * components\n     * @property components\n     */\n    components: [],\n\n    initialize: function (components) {\n        this.components = [];\n        if (components != null) {\n            this.addComponents(components);\n        }\n    },\n\n    /** *\n     * \n     * @returns {string}\n     */\n    getComponentsString: function () {\n        var i;\n        var len;\n        var strings = [];\n        for (i = 0, len = this.components.length; i < len; i++) {\n            strings.push(this.components[i].toShortString());\n        }\n        return strings.join(',');\n    },\n\n    /** *\n     * \n     */\n    calculateBounds: function () {},\n\n    /** *\n     * \n     * @param components\n     */\n    addComponents: function (components) {\n        var i,\n            len;\n        if (!(L.Util.isArray(components))) {\n            components = [components];\n        }\n        for (i = 0, len = components.length; i < len; i++) {\n            this.addComponent(components[i]);\n        }\n    },\n\n    /** *\n     * \n     * @param component\n     * @param index\n     */\n    addComponent: function (component, index) {\n        var added = false;\n        var components1;\n        var components2;\n        if (component) {\n            if (this.componentTypes == null\n                // || (OpenLayers.Util.indexOf(this.componentTypes,\n                //     component.CLASS_NAME) > -1)\n            ) {\n                if (index != null && (index < this.components.length)) {\n                    components1 = this.components.slice(0, index);\n                    components2 = this.components.slice(index,\n                        this.components.length);\n                    components1.push(component);\n                    this.components = components1.concat(components2);\n                } else {\n                    this.components.push(component);\n                }\n                component.parent = this;\n                this.clearBounds();\n                added = true;\n            }\n        }\n        return added;\n    },\n\n    /** *\n     * \n     * @param components\n     */\n    removeComponents: function (components) {},\n\n    /** *\n     * \n     * @param component\n     */\n    removeComponent: function (component) {},\n\n    /** *\n     * \n     * @param nodes\n     */\n    getVertices: function (nodes) {},\n\n    clone: function () {\n        var components = this.components.slice(0);\n        var newColl = new fastmap.mapApi.Collection(components);\n        newColl.type = this.type;\n        return newColl;\n    }\n});\n","/* global fastmap b:true */\n/**\n * Point\n * GeometryPoint\n *\n * @namespace mapApi\n * @class Point\n */\nfastmap.mapApi.Point = fastmap.mapApi.Geometry.extend({\n    /**\n     * \n     * type\n     * @property type\n     * @type String\n     */\n    type: 'Point',\n    /**\n     * \n     * x\n     * @property x\n     * @type Number\n     */\n    x: null,\n\n    /**\n     * \n     * y\n     * @property y\n     * @type Number\n     */\n    y: null,\n\n    /**\n     * @method initialize\n     * \n     *\n     * @param {Number} x \n     * @param {Number} y \n     *\n     */\n    initialize: function (x, y) {\n        fastmap.mapApi.Geometry.prototype.initialize.apply(this, arguments);\n\n        this.x = parseFloat(x);\n        this.y = parseFloat(y);\n    },\n\n    /**\n     * .\n     * @method clone\n     * @return {fastmap.mapApi.Point} Clone.\n     */\n    clone: function () {\n        var obj = new fastmap.mapApi.Point(this.x, this.y);\n\n        return obj;\n    },\n\n    /**\n     * \n     * @method distanceTo\n     * @return {object} result.\n     */\n    distanceTo: function (geometry, options) {\n        var edge = !(options && options.edge === false);\n        var details = edge && options && options.details;\n        var distance,\n            x0,\n            y0,\n            x1,\n            y1,\n            result;\n        if (geometry instanceof fastmap.mapApi.Point) {\n            x0 = this.x;\n            y0 = this.y;\n            x1 = geometry.x;\n            y1 = geometry.y;\n            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n            result = !details ?\n                distance : { x0: x0, y0: y0, x1: x1, y1: y1, distance: distance };\n        } else {\n            result = geometry.distanceTo(this, options);\n            if (details) {\n                result = {\n                    x0: result.x1,\n                    y0: result.y1,\n                    x1: result.x0,\n                    y1: result.y0,\n                    distance: result.distance\n                };\n            }\n        }\n        return result;\n    },\n\n    /**\n     * \n     * @method calculateBounds\n     *\n     * @return {fastmap.mapApi.Bounds}.\n     */\n    calculateBounds: function () {\n        this.bounds = new fastmap.mapApi.Bounds(this.x, this.y, this.x, this.y);\n        return this.bounds;\n    },\n    /**\n     * \n     * @method move\n     * @param {Number}x\n     * @param {Number}y\n     */\n    move: function (x, y) {\n        this.x = this.x + x;\n        this.y = this.y + y;\n        this.bounds = null;\n    },\n\n    /**\n     * \n     * @method getCentroid\n     * @returns {fastmap.mapApi.Point}\n     */\n    getCentroid: function () {\n        return new fastmap.mapApi.Point(this.x, this.y);\n    },\n\n    /**\n     * \n     * @method intersects\n     * @param {Geometry}geometry\n     * @returns {boolean}\n     */\n    intersects: function (geometry) {\n        var intersect = false;\n        if (geometry.type === 'Point') {\n            intersect = this.equals(geometry);\n        } else {\n            intersect = geometry.intersects(this);\n        }\n        return intersect;\n    },\n    getVertices: function (nodes) {\n        return [this];\n    }\n});\nfastmap.mapApi.point = function (x, y) {\n    return new fastmap.mapApi.Point(x, y);\n};\n\n","/**\n * Created by liwanchong on 2015/9/8.\n * lineString\n * @namespace fast.mapApi\n * @class LineString\n */\nfastmap.mapApi.LineString = fastmap.mapApi.Collection.extend({\n    /**\n     * \n     * type\n     * @property type\n     * @type String\n     */\n    type: 'LineString',\n\n    /**\n     * @class LineString\n     * @constructor\n     * @namespace fastmap.mapApi\n     * @param {Array}Points\n     */\n    initialize: function (points) {\n        fastmap.mapApi.Collection.prototype.initialize.apply(this, arguments);\n        this.points = points;\n    },\n\n    /**\n     * \n     * @method removeComponent\n     * @return boolean .\n     */\n    removeComponent: function (point) {\n        var removed = this.components && (this.components.length > 2);\n        if (removed) {\n            fastmap.mapApi.Collection.prototype.removeComponent.apply(this,\n                arguments);\n        }\n        return removed;\n    },\n\n    /**\n     * lineString\n     * @method clone\n     * @return LineString Clone.\n     */\n    clone: function () {\n        var newpoints = [];\n        newpoints = this.points.slice(0);\n        var lineString = new fastmap.mapApi.LineString(newpoints);\n        return lineString;\n    },\n    /**\n     *lineString\n     * @method getCoordinates\n     * @param {Array}coordinates\n     */\n\n    getCoordinates: function () {\n    },\n    /**\n     * \n     * @method getStartPoint\n     * @param {Point}coordinates\n     */\n    getStartPoint: function (coordinates) {\n\n    },\n    /**\n     * \n     * @method getEndPoint\n     * @param {Point} coordinates\n     */\n    getEndPoint: function (coordinates) {\n\n    },\n    /**\n     *\n     * @method pointToSegmentDistance\n     * @param {Point}p\n     * @param {Point}p1\n     * @param {Point}p2\n     * @returns {number}\n     */\n    pointToSegmentDistance: function (/* Point*/ p, /* Point*/ p1, /* Point*/ p2) {\n        return this._sqClosestPointOnSegment(p, p1, p2);\n    },\n\n    _sqClosestPointOnSegment: function (p, p1, p2) {\n        var x0 = p.x;\n        var y0 = p.y;\n        var x1 = p1.x;\n        var y1 = p1.y;\n        var x2 = p2.x;\n        var y2 = p2.y;\n        var dx = x2 - x1;\n        var dy = y2 - y1;\n        var along = ((dx * (x0 - x1)) + (dy * (y0 - y1))) /\n            (Math.pow(dx, 2) + Math.pow(dy, 2));\n        var x,\n            y;\n        if (along <= 0.0) {\n            x = x1;\n            y = y1;\n        } else if (along >= 1.0) {\n            x = x2;\n            y = y2;\n        } else {\n            x = x1 + along * dx;\n            y = y1 + along * dy;\n        }\n        return {\n            distance: Math.sqrt(Math.pow(x - x0, 2) + Math.pow(y - y0, 2)),\n            x: x,\n            y: y,\n            along: along\n        };\n    },\n    /**\n     *\n     * @method intersects\n     * @param {Geometry}geometry\n     * @returns {boolean}\n     */\n    intersects: function (geometry) {\n        var intersect = false;\n        var type = geometry.type;\n        if (type == 'LineString' ||\n            type == 'LinearRing' ||\n            type == 'Point') {\n            var segs1 = this.getSortedSegments();\n            var segs2;\n            if (type == 'Point') {\n                segs2 = [{\n                    x1: geometry.x,\n                    y1: geometry.y,\n                    x2: geometry.x,\n                    y2: geometry.y\n                }];\n            } else {\n                segs2 = geometry.getSortedSegments();\n            }\n            var seg1,\n                seg1x1,\n                seg1x2,\n                seg1y1,\n                seg1y2,\n                seg2,\n                seg2y1,\n                seg2y2;\n            // sweep right\n            outer: for (var i = 0, len = segs1.length; i < len; ++i) {\n                seg1 = segs1[i];\n                seg1x1 = seg1.x1;\n                seg1x2 = seg1.x2;\n                seg1y1 = seg1.y1;\n                seg1y2 = seg1.y2;\n                for (var j = 0, jlen = segs2.length; j < jlen; ++j) {\n                    seg2 = segs2[j];\n                    if (seg2.x1 > seg1x2) {\n                        // seg1 still left of seg2\n                        break;\n                    }\n                    if (seg2.x2 < seg1x1) {\n                        // seg2 still left of seg1\n                        continue;\n                    }\n                    seg2y1 = seg2.y1;\n                    seg2y2 = seg2.y2;\n                    if (Math.min(seg2y1, seg2y2) > Math.max(seg1y1, seg1y2)) {\n                        // seg2 above seg1\n                        continue;\n                    }\n                    if (Math.max(seg2y1, seg2y2) < Math.min(seg1y1, seg1y2)) {\n                        // seg2 below seg1\n                        continue;\n                    }\n                    if (fastmap.mapApi.Geometry.segmentsIntersect(seg1, seg2)) {\n                        intersect = true;\n                        break outer;\n                    }\n                }\n            }\n        } else {\n            intersect = geometry.intersects(this);\n        }\n        return intersect;\n    },\n    /**\n     * \n     *@method getSortedSegments\n     * @param {Boolean}boolsort \n     * Returns:\n     * {Array} An array of segment objects.  Segment objects have properties\n     *     x1, y1, x2, and y2.  The start point is represented by x1 and y1.\n     *     The end point is represented by x2 and y2.  Start and end are\n     *     ordered so that x1 < x2.\n     */\n    getSortedSegments: function (boolsort) {\n        var numSeg = this.components.length - 1;\n        var segments = new Array(numSeg);\n        var point1,\n            point2;\n        for (var i = 0; i < numSeg; ++i) {\n            point1 = this.components[i];\n            point2 = this.components[i + 1];\n            if (point1.x < point2.x) {\n                segments[i] = {\n                    x1: point1.x,\n                    y1: point1.y,\n                    x2: point2.x,\n                    y2: point2.y\n                };\n            } else {\n                segments[i] = {\n                    x1: point2.x,\n                    y1: point2.y,\n                    x2: point1.x,\n                    y2: point1.y\n                };\n            }\n        }\n        // more efficient to define this somewhere static\n        function byX1(seg1, seg2) {\n            return seg1.x1 - seg2.x1;\n        }\n\n        if (boolsort == true) {\n            return segments.sort(byX1);\n        }\n        return segments;\n    },\n\n    getSegments: function () {\n        var numSeg = this.components.length - 1;\n        var segments = new Array(numSeg);\n        var point1,\n            point2;\n        for (var i = 0; i < numSeg; ++i) {\n            point1 = this.components[i];\n            point2 = this.components[i + 1];\n            segments[i] = {\n                x1: point1.x,\n                y1: point1.y,\n                x2: point2.x,\n                y2: point2.y\n            };\n        }\n        return segments;\n    },\n\n    /**\n     *\n     *@method splitWithSegment\n     * @param {Object}seg\n     * @param {Object}options\n     */\n    splitWithSegment: function (seg, options) {\n        var edge = !(options && options.edge === false);\n        var tolerance = options && options.tolerance;\n        var lines = [];\n        var verts = this.getVertices();\n        var points = [];\n        var intersections = [];\n        var split = false;\n        var vert1,\n            vert2,\n            point;\n        var node,\n            vertex,\n            target;\n        var interOptions = { point: true, tolerance: tolerance };\n        var result = null;\n        for (var i = 0, stop = verts.length - 2; i <= stop; ++i) {\n            vert1 = verts[i];\n            points.push(vert1.clone());\n            vert2 = verts[i + 1];\n            target = { x1: vert1.x, y1: vert1.y, x2: vert2.x, y2: vert2.y };\n            point = fastmap.mapApi.Geometry.segmentsIntersect(\n                seg, target, interOptions\n            );\n            if (point instanceof fastmap.mapApi.Point) {\n                if ((point.x === seg.x1 && point.y === seg.y1) ||\n                    (point.x === seg.x2 && point.y === seg.y2) ||\n                    point.equals(vert1) || point.equals(vert2)) {\n                    vertex = true;\n                } else {\n                    vertex = false;\n                }\n                if (vertex || edge) {\n                    // push intersections different than the previous\n                    if (!point.equals(intersections[intersections.length - 1])) {\n                        intersections.push(point.clone());\n                    }\n                    if (i === 0) {\n                        if (point.equals(vert1)) {\n                            continue;\n                        }\n                    }\n                    if (point.equals(vert2)) {\n                        continue;\n                    }\n                    split = true;\n                    if (!point.equals(vert1)) {\n                        points.push(point);\n                    }\n                    lines.push(new fastmap.mapApi.LineString(points));\n                    points = [point.clone()];\n                }\n            }\n        }\n        if (split) {\n            points.push(vert2.clone());\n            lines.push(new fastmap.mapApi.LineString(points));\n        }\n        if (intersections.length > 0) {\n            // sort intersections along segment\n            var xDir = seg.x1 < seg.x2 ? 1 : -1;\n            var yDir = seg.y1 < seg.y2 ? 1 : -1;\n            result = {\n                lines: lines,\n                points: intersections.sort(function (p1, p2) {\n                    return (xDir * p1.x - xDir * p2.x) || (yDir * p1.y - yDir * p2.y);\n                })\n            };\n        }\n        return result;\n    },\n    /**\n     * geometry\n     *@method split\n     * @param {Object}target\n     * @param {Object}options\n     */\n    split: function (target, options) {\n        var results = null;\n        var mutual = options && options.mutual;\n        var sourceSplit,\n            targetSplit,\n            sourceParts,\n            targetParts;\n        if (target instanceof fastmap.mapApi.LineString) {\n            var verts = this.getVertices();\n            var vert1,\n                vert2,\n                seg,\n                splits,\n                lines,\n                point;\n            var points = [];\n            sourceParts = [];\n            for (var i = 0, stop = verts.length - 2; i <= stop; ++i) {\n                vert1 = verts[i];\n                vert2 = verts[i + 1];\n                seg = {\n                    x1: vert1.x,\n                    y1: vert1.y,\n                    x2: vert2.x,\n                    y2: vert2.y\n                };\n                targetParts = targetParts || [target];\n                if (mutual) {\n                    points.push(vert1.clone());\n                }\n                for (var j = 0; j < targetParts.length; ++j) {\n                    splits = targetParts[j].splitWithSegment(seg, options);\n                    if (splits) {\n                        // splice in new features\n                        lines = splits.lines;\n                        if (lines.length > 0) {\n                            lines.unshift(j, 1);\n                            Array.prototype.splice.apply(targetParts, lines);\n                            j += lines.length - 2;\n                        }\n                        if (mutual) {\n                            for (var k = 0, len = splits.points.length; k < len; ++k) {\n                                point = splits.points[k];\n                                if (!point.equals(vert1)) {\n                                    points.push(point);\n                                    sourceParts.push(new fastmap.mapApi.LineString(points));\n                                    if (point.equals(vert2)) {\n                                        points = [];\n                                    } else {\n                                        points = [point.clone()];\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (mutual && sourceParts.length > 0 && points.length > 0) {\n                points.push(vert2.clone());\n                sourceParts.push(new fastmap.mapApi.LineString(points));\n            }\n        } else {\n            results = target.splitWith(this, options);\n        }\n        if (targetParts && targetParts.length > 1) {\n            targetSplit = true;\n        } else {\n            targetParts = [];\n        }\n        if (sourceParts && sourceParts.length > 1) {\n            sourceSplit = true;\n        } else {\n            sourceParts = [];\n        }\n        if (targetSplit || sourceSplit) {\n            if (mutual) {\n                results = [sourceParts, targetParts];\n            } else {\n                results = targetParts;\n            }\n        }\n        return results;\n    },\n\n    splitWith: function (geometry, options) {\n        return geometry.split(this, options);\n    },\n\n    /**\n     * \n     * @method distanceTo\n     * @param {Geometry}geometry\n     * @param {Object}options\n     * @returns {{}}\n     */\n    distanceTo: function (geometry, options) {\n        var edge = !(options && options.edge === false);\n        var details = edge && options && options.details;\n        var result;\n        var best = {};\n        var min = Number.POSITIVE_INFINITY;\n        var i;\n        if (geometry instanceof fastmap.mapApi.Point) {\n            var segs = this.getSortedSegments();\n            var x = geometry.x;\n            var y = geometry.y;\n            var seg;\n            for (i = 0; i < segs.length; ++i) {\n                seg = segs[i];\n                result = fastmap.mapApi.Geometry.distanceToSegment(geometry, seg);\n                if (result.distance < min) {\n                    min = result.distance;\n                    best = result;\n                    if (min === 0) {\n                        break;\n                    }\n                } else if (seg.x2 > x && ((y > seg.y1 && y < seg.y2) || (y < seg.y1 && y > seg.y2))) {\n                    // if distance increases and we cross y0 to the right of x0, no need to keep looking.\n                    break;\n                }\n            }\n            if (details) {\n                best = {\n                    distance: best.distance,\n                    x0: best.x,\n                    y0: best.y,\n                    x1: x,\n                    y1: y\n                };\n            } else {\n                best = best.distance;\n            }\n        } else if (geometry instanceof fastmap.mapApi.LineString) {\n            var segs0 = this.getSortedSegments();\n            var segs1 = geometry.getSortedSegments();\n            var seg0,\n                seg1,\n                intersection,\n                x0,\n                y0;\n            var len1 = segs1.length;\n            var interOptions = { point: true };\n            outer: for (i = 0; i < segs0.length; ++i) {\n                seg0 = segs0[i];\n                x0 = seg0.x1;\n                y0 = seg0.y1;\n                for (var j = 0; j < len1; ++j) {\n                    seg1 = segs1[j];\n                    intersection = fastmap.mapApi.Geometry.segmentsIntersect(seg0, seg1, interOptions);\n                    if (intersection) {\n                        min = 0;\n                        best = {\n                            distance: 0,\n                            x0: intersection.x,\n                            y0: intersection.y,\n                            x1: intersection.x,\n                            y1: intersection.y\n                        };\n                        break outer;\n                    } else {\n                        result = fastmap.mapApi.Geometry.distanceToSegment({ x: x0, y: y0 }, seg1);\n                        if (result.distance < min) {\n                            min = result.distance;\n                            best = {\n                                distance: min,\n                                x0: x0,\n                                y0: y0,\n                                x1: result.x,\n                                y1: result.y\n                            };\n                        }\n                    }\n                }\n            }\n            if (!details) {\n                best = best.distance;\n            }\n            if (min !== 0) {\n                // check the final vertex in this line's sorted segments\n                if (seg0) {\n                    result = geometry.distanceTo(\n                        new fastmap.mapApi.Point(seg0.x2, seg0.y2),\n                        options\n                    );\n                    var dist = details ? result.distance : result;\n                    if (dist < min) {\n                        if (details) {\n                            best = {\n                                distance: min,\n                                x0: result.x1,\n                                y0: result.y1,\n                                x1: result.x0,\n                                y1: result.y0\n                            };\n                        } else {\n                            best = dist;\n                        }\n                    }\n                }\n            }\n        } else {\n            best = geometry.distanceTo(this, options);\n            // swap since target comes from this line\n            if (details) {\n                best = {\n                    distance: best.distance,\n                    x0: best.x1,\n                    y0: best.y1,\n                    x1: best.x0,\n                    y1: best.y0\n                };\n            }\n        }\n        return best;\n    },\n\n    getVertices: function (nodes) {\n        var vertices;\n        if (nodes === true) {\n            vertices = [\n                this.components[0],\n                this.components[this.components.length - 1]\n            ];\n        } else if (nodes === false) {\n            vertices = this.components.slice(1, this.components.length - 1);\n        } else {\n            vertices = this.components.slice();\n        }\n        return vertices;\n    },\n\n    /**\n     *\n     * @method simplify\n     * @param {Number}tolerance\n     */\n    simplify: function (tolerance) {\n        if (this && this !== null) {\n            var points = this.getVertices();\n            if (points.length < 3) {\n                return this;\n            }\n            var compareNumbers = function (a, b) {\n                return (a - b);\n            };\n            var firstPoint = 0;\n            var lastPoint = points.length - 1;\n            var pointIndexsToKeep = [];\n\n            // Add the first and last index to the keepers\n            pointIndexsToKeep.push(firstPoint);\n            pointIndexsToKeep.push(lastPoint);\n\n            // The first and the last point cannot be the same\n            while (points[firstPoint].equals(points[lastPoint])) {\n                lastPoint--;\n                // Addition: the first point not equal to first point in the LineString is kept as well\n                pointIndexsToKeep.push(lastPoint);\n            }\n\n            /**\n             * Private function calculating the perpendicular distance\n             * TODO: check whether OpenLayers.Geometry.LineString::distanceTo() is faster or slower\n             */\n            var perpendicularDistance = function (point1, point2, point) {\n                // Area = |(1/2)(x1y2 + x2y3 + x3y1 - x2y1 - x3y2 - x1y3)|   *Area of triangle\n                // Base = v((x1-x2)+(x1-x2))                               *Base of Triangle*\n                // Area = .5*Base*H                                          *Solve for height\n                // Height = Area/.5/Base\n\n                var area = Math.abs(0.5 * (point1.x * point2.y + point2.x * point.y + point.x * point1.y - point2.x * point1.y - point.x * point2.y - point1.x * point.y));\n                var bottom = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));\n                var height = area / bottom * 2;\n\n                return height;\n            };\n            /**\n             * Private function doing the Douglas-Peucker reduction\n             */\n            var douglasPeuckerReduction = function (points1, firstPoint1, lastPoint1, tolerance1) {\n                var maxDistance = 0;\n                var indexFarthest = 0;\n\n                for (var index = firstPoint1, distance; index < lastPoint1; index++) {\n                    distance = perpendicularDistance(points1[firstPoint1], points1[lastPoint1], points1[index]);\n                    if (distance > maxDistance) {\n                        maxDistance = distance;\n                        indexFarthest = index;\n                    }\n                }\n\n                if (maxDistance > tolerance1 && indexFarthest != firstPoint1) {\n                    // Add the largest point that exceeds the tolerance1\n                    pointIndexsToKeep.push(indexFarthest);\n                    douglasPeuckerReduction(points1, firstPoint1, indexFarthest, tolerance1);\n                    douglasPeuckerReduction(points1, indexFarthest, lastPoint1, tolerance1);\n                }\n            };\n            douglasPeuckerReduction(points, firstPoint, lastPoint, tolerance);\n            var returnPoints = [];\n            pointIndexsToKeep.sort(compareNumbers);\n            for (var index = 0; index < pointIndexsToKeep.length; index++) {\n                returnPoints.push(points[pointIndexsToKeep[index]]);\n            }\n            // return new OpenLayers.Geometry.LineString(returnPoints);\n            return new FM.Geometry.LineString(returnPoints);\n        }\n        return this;\n    }\n});\nfastmap.mapApi.lineString = function (coordiates) {\n    return new fastmap.mapApi.LineString(coordiates);\n};\n\n","/**\n * Created by wangtun on 2015/9/10.\n * Polygon \n * @namespace fast.mapApi\n * @class Polygon\n */\nfastmap.mapApi.Polygon = fastmap.mapApi.Collection.extend({\n    type: 'Polygon',\n    components: [],\n    options: {},\n    /**\n     * \n     * @class Polygon\n     * @constructor\n     * @param {Array}components\n     * @param {Object}options\n     */\n    initialize: function (components, options) {\n        this.components = components;\n        this.options = options;\n    },\n    /**\n     * \n     * @method getArea\n     * @returns {number}\n     */\n    getArea: function () {\n        var area = 0.0;\n        var i,\n            len;\n        if (this.components && (this.components.length > 0)) {\n            area += Math.abs(this.components[0].getArea());\n            for (i = 1, len = this.components.length; i < len; i++) {\n                area -= Math.abs(this.components[i].getArea());\n            }\n        }\n        return area;\n    },\n    /**\n     * \n     * @method containsPoint\n     * @param {Point}point\n     * @returns {boolean}\n     */\n    containsPoint: function (point) {\n        var numRings = this.components.length;\n        var contained = false;\n        var hole,\n            i,\n            len;\n        if (numRings > 0) {\n            // check exterior ring - 1 means on edge, boolean otherwise\n            contained = this.components[0].containsPoint(point);\n            if (contained !== 1) {\n                if (contained && numRings > 1) {\n                    // check interior rings\n                    for (i = 1; i < numRings; ++i) {\n                        hole = this.components[i].containsPoint(point);\n                        if (hole) {\n                            if (hole === 1) {\n                                // on edge\n                                contained = 1;\n                            } else {\n                                // in hole\n                                contained = false;\n                            }\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        return contained;\n    },\n    /**\n     * \n     * @method intersects\n     * @param {Geometry}geometry\n     * @returns {boolean}\n     */\n    intersects: function (geometry) {\n        var intersect = false;\n        var i,\n            len,\n            ring;\n        if (geometry.type === 'Point') {\n            intersect = this.containsPoint(geometry);\n        } else if (geometry.type === 'LineString' ||\n            geometry.type === 'LinearRing') {\n            // check if rings/linestrings intersect\n            for (i = 0, len = this.components.length; i < len; ++i) {\n                intersect = geometry.intersects(this.components[i]);\n                if (intersect) {\n                    break;\n                }\n            }\n            if (!intersect) {\n                // check if this poly contains points of the ring/linestring\n                for (i = 0, len = geometry.components.length; i < len; ++i) {\n                    intersect = this.containsPoint(geometry.components[i]);\n                    if (intersect) {\n                        break;\n                    }\n                }\n            }\n        } else {\n            for (i = 0, len = geometry.components.length; i < len; ++i) {\n                intersect = this.intersects(geometry.components[i]);\n                if (intersect) {\n                    break;\n                }\n            }\n        }\n        // check case where this poly is wholly contained by another\n        if (!intersect && geometry.type === 'Polygon') {\n            // exterior ring points will be contained in the other geometry\n            ring = this.components[0];\n            for (i = 0, len = ring.components.length; i < len; ++i) {\n                intersect = geometry.containsPoint(ring.components[i]);\n                if (intersect) {\n                    break;\n                }\n            }\n        }\n        return intersect;\n    },\n    /**\n     * polygon\n     * @method distanceTo\n     * @param {Geometry}geometry\n     * @param {Object}options\n     * @returns {*}\n     */\n    distanceTo: function (geometry, options) {\n        var edge = !(options && options.edge === false);\n        var result;\n        // this is the case where we might not be looking for distance to edge\n        if (!edge && this.intersects(geometry)) {\n            result = 0;\n        } else {\n            result = fastmap.mapApi.Collection.prototype.distanceTo.apply(\n                this, [geometry, options]\n            );\n        }\n        return result;\n    },\n    /**\n     * Polygon\n     * @method Polygon\n     * @returns {.mapApi.Polygon}\n     */\n    clone: function () {\n        var polygon = new fastmap.mapApi.Polygon(null);\n        return polygon;\n    },\n    /**\n     * \n     * @param num\n     * @param sig\n     * @returns {number}\n     */\n    limitSigDigs: function (num, sig) {\n        var fig = 0;\n        if (sig > 0) {\n            fig = parseFloat(num.toPrecision(sig));\n        }\n        return fig;\n    }\n});\nfastmap.mapApi.polygon = function (components, options) {\n    return new fastmap.mapApi.Polygon(components, options);\n};\n","/**\n * Created by liwanchong on 2015/9/8.\n * LinearRing\n * @namespace fast.mapApi\n * @class LinearRing\n */\nfastmap.mapApi.LinearRing = fastmap.mapApi.LineString.extend({\n    options: {},\n    components: [],\n\n    /**\n     * \n     * type\n     * @property type\n     * @type String\n     */\n    type: 'LinearRing',\n\n    /**\n     * \n     * @class LinearRing\n     * @constructor\n     * @namespace fastmap.mapApi\n     * @param {Array}components\n     * @param {Object}options\n     */\n    initialize: function (components, options) {\n        this.components = components;\n        this.options = options;\n    },\n    /**\n     *  geometry\n     *  @method addComponent\n     * @param point\n     * @param index\n     * @returns {boolean}\n     */\n    addComponent: function (point, index) {\n        var added = false;\n\n        // remove last point\n        var lastPoint = this.components.pop();\n\n        // given an index, add the point\n        // without an index only add non-duplicate points\n        if (index != null || !point.equals(lastPoint)) {\n            added = fastmap.mapApi.Collection.prototype.addComponent.apply(this,\n                arguments);\n        }\n\n        // append copy of first point\n        var firstPoint = this.components[0];\n        fastmap.mapApi.Collection.prototype.addComponent.apply(this,\n            [firstPoint]);\n\n        return added;\n    },\n    /**\n     * geometry\n     * @method removeComponent\n     * @param point\n     * @returns {Array}\n     */\n    removeComponent: function (point) {\n        var removed = this.components && (this.components.length > 3);\n        if (removed) {\n            // remove last point\n            this.components.pop();\n\n            // remove our point\n            fastmap.mapApi.Collection.prototype.removeComponent.apply(this,\n                arguments);\n            // append copy of first point\n            var firstPoint = this.components[0];\n            fastmap.mapApi.Collection.prototype.addComponent.apply(this,\n                [firstPoint]);\n        }\n        return removed;\n    },\n    /**\n     * x,ygeometry\n     * @method move\n     * @param x\n     * @param y\n     */\n    move: function (x, y) {\n        for (var i = 0, len = this.components.length; i < len - 1; i++) {\n            this.components[i].move(x, y);\n        }\n    },\n\n    rotate: function (angle, origin) {\n        for (var i = 0, len = this.components.length; i < len - 1; ++i) {\n            this.components[i].rotate(angle, origin);\n        }\n    },\n    /**\n     * geometry\n     * @method resize\n     * @param scale\n     * @param origin\n     * @param ratio\n     * @returns {fastmap.mapApi.LinearRing}\n     */\n    resize: function (scale, origin, ratio) {\n        for (var i = 0, len = this.components.length; i < len - 1; ++i) {\n            this.components[i].resize(scale, origin, ratio);\n        }\n        return this;\n    },\n\n    transform: function (source, dest) {\n        if (source && dest) {\n            for (var i = 0, len = this.components.length; i < len - 1; i++) {\n                var component = this.components[i];\n                component.transform(source, dest);\n            }\n            this.bounds = null;\n        }\n        return this;\n    },\n\n    /**\n     * \n     * @method getCentroid\n     */\n    getCentroid: function () {\n        var center = null;\n        if (this.components) {\n            var len = this.components.length;\n            var i;\n            var x;\n            var y;\n            if (len > 0 && len <= 2) {\n                return this.components[0].clone();\n            } else if (len > 2) {\n                var sumX = 0.0;\n                var sumY = 0.0;\n                var x0 = this.components[0].x;\n                var y0 = this.components[0].y;\n                var area = -1 * this.getArea();\n                if (area != 0) {\n                    for (i = 0; i < len - 1; i++) {\n                        var b = this.components[i];\n                        var c = this.components[i + 1];\n                        sumX += (b.x + c.x - 2 * x0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));\n                        sumY += (b.y + c.y - 2 * y0) * ((b.x - x0) * (c.y - y0) - (c.x - x0) * (b.y - y0));\n                    }\n                    x = x0 + sumX / (6 * area);\n                    y = y0 + sumY / (6 * area);\n                } else {\n                    for (i = 0; i < len - 1; i++) {\n                        sumX += this.components[i].x;\n                        sumY += this.components[i].y;\n                    }\n                    x = sumX / (len - 1);\n                    y = sumY / (len - 1);\n                }\n                // return new OpenLayers.Geometry.Point(x, y);\n                return new FM.Geometry.Point(x, y);\n            }\n            return center;\n        }\n        return center;\n    },\n    /**\n     * geometry\n     * @method getArea\n     * @returns {number}\n     */\n    getArea: function () {\n        var area = 0.0;\n        if (this.components && (this.components.length > 2)) {\n            var sum = 0.0;\n            for (var i = 0, len = this.components.length; i < len - 1; i++) {\n                var b = this.components[i];\n                var c = this.components[i + 1];\n                sum += (b.x + c.x) * (c.y - b.y);\n            }\n            area = -sum / 2.0;\n        }\n        return area;\n    },\n    /**\n     * geometry \n     * @method getGeodesicLength\n     * @param projection\n     * @returns {number}\n     */\n    getGeodesicLength: function (projection) {\n        var length = 0.0;\n        return length;\n    },\n    /**\n     * LinearRing\n     * @returns {fastmap.mapApi.LinearRing}\n     */\n    clone: function () {\n        var linearRing = new fastmap.mapApi.LinearRing(null);\n        return linearRing;\n    },\n    limitSigDigs: function (num, sig) {\n        var fig = 0;\n        if (sig > 0) {\n            fig = parseFloat(num.toPrecision(sig));\n        }\n        return fig;\n    },\n    /**\n     * \n     * @method containsPoint\n     * @param point\n     * @returns {boolean}\n     */\n    containsPoint: function (point) {\n        var digs = 14;\n        var px = this.limitSigDigs(point.x, digs);\n        var py = this.limitSigDigs(point.y, digs);\n\n        function getX(y, x1, y1, x2, y2) {\n            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;\n        }\n\n        var numSeg = this.components.length - 1;\n        var start,\n            end,\n            x1,\n            y1,\n            x2,\n            y2,\n            cx,\n            cy;\n        var crosses = 0;\n        for (var i = 0; i < numSeg; ++i) {\n            start = this.components[i];\n            x1 = this.limitSigDigs(start.x ? start.x : start[0], digs);\n            y1 = this.limitSigDigs(start.y ? start.y : start[1], digs);\n            end = this.components[i + 1];\n            x2 = this.limitSigDigs(end.x ? end.x : end[0], digs);\n            y2 = this.limitSigDigs(end.y ? end.y : end[1], digs);\n\n            /**\n             * The following conditions enforce five edge-crossing rules:\n             *    1. points coincident with edges are considered contained;\n             *    2. an upward edge includes its starting endpoint, and\n             *    excludes its final endpoint;\n             *    3. a downward edge excludes its starting endpoint, and\n             *    includes its final endpoint;\n             *    4. horizontal edges are excluded; and\n             *    5. the edge-ray intersection point must be strictly right\n             *    of the point P.\n             */\n            if (y1 == y2) {\n                // horizontal edge\n                if (py == y1) {\n                    // point on horizontal line\n                    if ((x1 <= x2 && (px >= x1 && px <= x2)) || // right or vert\n                        (x1 >= x2 && (px <= x1 && px >= x2))) { // left or vert\n                        // point on edge\n                        crosses = -1;\n                        break;\n                    }\n                }\n                // ignore other horizontal edges\n                continue;\n            }\n            cx = this.limitSigDigs(getX(py, x1, y1, x2, y2), digs);\n            if (cx == px) {\n                // point on line\n                if ((y1 < y2 && (py >= y1 && py <= y2)) || // upward\n                    (y1 > y2 && (py <= y1 && py >= y2))) { // downward\n                    // point on edge\n                    crosses = -1;\n                    break;\n                }\n            }\n            if (cx <= px) {\n                // no crossing to the right\n                continue;\n            }\n            if (x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {\n                // no crossing\n                continue;\n            }\n            if ((y1 < y2 && (py >= y1 && py < y2)) || // upward\n                (y1 > y2 && (py < y1 && py >= y2))) { // downward\n                ++crosses;\n            }\n        }\n        var contained = (crosses == -1) ?\n            // on edge\n            1 :\n            // even (out) or odd (in)\n            !!(crosses & 1);\n\n        return contained;\n    },\n    /**\n     * \n     * @method intersects\n     * @param geometry\n     * @returns {boolean}\n     */\n    intersects: function (geometry) {\n        var intersect = false;\n        if (geometry.CLASS_NAME == 'OpenLayers.Geometry.Point') {\n            intersect = this.containsPoint(geometry);\n        } else if (geometry.CLASS_NAME == 'OpenLayers.Geometry.LineString') {\n            intersect = geometry.intersects(this);\n        } else if (geometry.CLASS_NAME == 'OpenLayers.Geometry.LinearRing') {\n            // intersect = OpenLayers.Geometry.LineString.prototype.intersects.apply(\n            intersect = FM.Geometry.LineString.prototype.intersects.apply(\n                this, [geometry]\n            );\n        } else {\n            // check for component intersections\n            for (var i = 0, len = geometry.components.length; i < len; ++i) {\n                intersect = geometry.components[i].intersects(this);\n                if (intersect) {\n                    break;\n                }\n            }\n        }\n        return intersect;\n    },\n    /**\n     * geometry\n     * @method getVertices\n     * @param nodes\n     */\n    getVertices: function (nodes) {\n        return (nodes === true) ? [] : this.components.slice(0, this.components.length - 1);\n    }\n});\nfastmap.mapApi.linearRing = function (coordiates, options) {\n    return new fastmap.mapApi.LinearRing(coordiates, options);\n};\n\n","/**\n * Created by wangtun on 2015/9/10.\n */\nfastmap.mapApi.MultiPolygon = fastmap.mapApi.Collection.extend({\n    options: {},\n    /**\n     * \n     * type\n     * @property type\n     * @type String\n     */\n    type: 'MultiPolygon',\n    /**\n     * \n     * @class MultiPolygon\n     * @constructor\n     * @namespace fastmap.mapApi\n     * @param {Array}coordinates\n     * @param {Object}options\n     */\n    initialize: function (coordinates, options) {\n        this.coordinates = coordinates;\n        this.options = options;\n    },\n    /**\n     *polygonMultiPolygon\n     * @method appendPolygon\n     * @param {Polygon}polygon\n     */\n    appendPolygon: function (polygon) {\n    },\n    /**\n     * MultiPolygon\n     * @method clone\n     * @returns {.mapApi.MultiPolygon}\n     */\n    clone: function () {\n        var polygons = new fastmap.mapApi.MultiPolygon(null);\n        return polygons;\n    },\n    /**\n     * \n     * @method closestPointXY\n     * @param {Number}x\n     * @param {Number}y\n     * @param {Point}closestPoint\n     * @param {Number}minSquaredDistance\n     */\n    closestPointXY: function (x, y, closestPoint, minSquaredDistance) {\n\n    },\n    /**\n     * x,y\n     * @method containsXY\n     * @param {Number}x\n     * @param {Number}y\n     */\n    containsXY: function (x, y) {\n\n    },\n    /**\n     * MultiPolygon\n     * @method getArea\n     */\n    getArea: function () {\n\n    },\n    /**\n     * MultiPolygon\n     * @method getCoordinates\n     */\n    getCoordinates: function () {\n\n    },\n    /**\n     * MultiPolygon\n     * @param {Number}squaredTolerance\n     * @returns {.mapApi.MultiPolygon}\n     */\n    getSimplifiedGeometryInternal: function (squaredTolerance) {\n        var simplifiedMultiPolygonString = new fastmap.mapApi.MultiPolygon(null);\n        return simplifiedMultiPolygonString;\n    },\n    /**\n     * MultiPolygonpolygon\n     * @method getPolygon\n     * @param {Number}index\n     * @returns {L.Polygon}\n     */\n    getPolygon: function (index) {\n        var polygon = new fastmap.mapApi.Polygon(null);\n        return polygon;\n    },\n    /**\n     * MultiPolygonpolygons\n     * @method getPolygons\n     * @returns {Array}\n     */\n    getPolygons: function () {\n        var polygons = [];\n        return polygons;\n    },\n    /**\n     *\n     * @method intersectsExtend\n     * @param {Object}extend\n     */\n    intersectsExtent: function (extend) {\n\n    }\n});\nfastmap.mapApi.multiPolygon = function (coordiates, options) {\n    return new fastmap.mapApi.MultiPolygon(coordiates, options);\n};\n","/**\n * Created by wangtun on 2015/9/10.\n * MultiPolyline\n * @namespace fast.mapApi\n * @class MultiPolyline\n */\nfastmap.mapApi.MultiPolyline = fastmap.mapApi.Collection.extend({\n    /**\n     * \n     * type\n     * @property type\n     * @type String\n     */\n    type: 'MultiPolyline',\n    /**\n     * \n     * @class MultiPolyline\n     * @constructor\n     * @namespace fastmap.mapApi\n     * @param {Array}coordinates\n     * @param {Object}options\n     * @param {Object}activeCoordinates coordinateslink\n     * @param {Object}activeOptions \n     */\n    initialize: function (coordinates, options, activeCoordinates, activeOptions) {\n        this.coordinates = coordinates;\n        this.activeCoordinates = activeCoordinates || []; // coordinatesactiveCoordinates\n        this.options = options;\n        this.activeOptions = activeOptions;\n    },\n    /**\n     * MultiPolylineZlineString\n     * @method appendLineString\n     * @param {LineString}lineString\n     */\n    appendLineString: function (lineString) {\n\n    },\n    /**\n     * MultiPolyline\n     * @method clone\n     * @returns {L.MultiPolyline}\n     */\n    clone: function () {\n        var lineStrings = new fastmap.mapApi.MultiPolyline(null);\n        return lineStrings;\n    },\n\n    /**\n     * .\n     * @method splitWith\n     * @return {Array} \n     */\n    split: function (geometry, options) {\n        var results = null;\n        var mutual = options && options.mutual;\n        var splits,\n            sourceLine,\n            sourceLines,\n            sourceSplit,\n            targetSplit;\n        var sourceParts = [];\n        var targetParts = [geometry];\n        for (var i = 0, len = this.components.length; i < len; ++i) {\n            sourceLine = this.components[i];\n            sourceSplit = false;\n            for (var j = 0; j < targetParts.length; ++j) {\n                splits = sourceLine.split(targetParts[j], options);\n                if (splits) {\n                    if (mutual) {\n                        sourceLines = splits[0];\n                        for (var k = 0, klen = sourceLines.length; k < klen; ++k) {\n                            if (k === 0 && sourceParts.length) {\n                                sourceParts[sourceParts.length - 1].addComponent(\n                                    sourceLines[k]\n                                );\n                            } else {\n                                sourceParts.push(\n                                    new fastmap.mapApi.MultiPolyline([\n                                        sourceLines[k]\n                                    ])\n                                );\n                            }\n                        }\n                        sourceSplit = true;\n                        splits = splits[1];\n                    }\n                    if (splits.length) {\n                        // splice in new target parts\n                        splits.unshift(j, 1);\n                        Array.prototype.splice.apply(targetParts, splits);\n                        break;\n                    }\n                }\n            }\n            if (!sourceSplit) {\n                // source line was not hit\n                if (sourceParts.length) {\n                    // add line to existing multi\n                    sourceParts[sourceParts.length - 1].addComponent(\n                        sourceLine.clone()\n                    );\n                } else {\n                    // create a fresh multi\n                    sourceParts = [\n                        new fastmap.mapApi.MultiPolyline(\n                            sourceLine.clone()\n                        )\n                    ];\n                }\n            }\n        }\n        if (sourceParts && sourceParts.length > 1) {\n            sourceSplit = true;\n        } else {\n            sourceParts = [];\n        }\n        if (targetParts && targetParts.length > 1) {\n            targetSplit = true;\n        } else {\n            targetParts = [];\n        }\n        if (sourceSplit || targetSplit) {\n            if (mutual) {\n                results = [sourceParts, targetParts];\n            } else {\n                results = targetParts;\n            }\n        }\n        return results;\n    },\n\n    /**\n     * .\n     * @method splitWith\n     * @return {Array} \n     */\n    splitWith: function (geometry, options) {\n        var results = null;\n        var mutual = options && options.mutual;\n        var splits,\n            targetLine,\n            sourceLines,\n            sourceSplit,\n            targetSplit,\n            sourceParts,\n            targetParts;\n        if (geometry instanceof fastmap.mapApi.LineString) {\n            targetParts = [];\n            sourceParts = [geometry];\n            for (var i = 0, len = this.components.length; i < len; ++i) {\n                targetSplit = false;\n                targetLine = this.components[i];\n                for (var j = 0; j < sourceParts.length; ++j) {\n                    splits = sourceParts[j].split(targetLine, options);\n                    if (splits) {\n                        if (mutual) {\n                            sourceLines = splits[0];\n                            if (sourceLines.length) {\n                                // splice in new source parts\n                                sourceLines.unshift(j, 1);\n                                Array.prototype.splice.apply(sourceParts, sourceLines);\n                                j += sourceLines.length - 2;\n                            }\n                            splits = splits[1];\n                            if (splits.length === 0) {\n                                splits = [targetLine.clone()];\n                            }\n                        }\n                        for (var k = 0, klen = splits.length; k < klen; ++k) {\n                            if (k === 0 && targetParts.length) {\n                                targetParts[targetParts.length - 1].addComponent(\n                                    splits[k]\n                                );\n                            } else {\n                                targetParts.push(\n                                    new fastmap.mapApi.MultiPolyline([\n                                        splits[k]\n                                    ])\n                                );\n                            }\n                        }\n                        targetSplit = true;\n                    }\n                }\n                if (!targetSplit) {\n                    // target component was not hit\n                    if (targetParts.length) {\n                        // add it to any existing multi-line\n                        targetParts[targetParts.length - 1].addComponent(\n                            targetLine.clone()\n                        );\n                    } else {\n                        // or start with a fresh multi-line\n                        targetParts = [\n                            new fastmap.mapApi.MultiPolyline([\n                                targetLine.clone()\n                            ])\n                        ];\n                    }\n                }\n            }\n        } else {\n            results = geometry.split(this);\n        }\n        if (sourceParts && sourceParts.length > 1) {\n            sourceSplit = true;\n        } else {\n            sourceParts = [];\n        }\n        if (targetParts && targetParts.length > 1) {\n            targetSplit = true;\n        } else {\n            targetParts = [];\n        }\n        if (sourceSplit || targetSplit) {\n            if (mutual) {\n                results = [sourceParts, targetParts];\n            } else {\n                results = targetParts;\n            }\n        }\n        return results;\n    },\n\n    /**\n     * \n     * @method getCoordinates\n     */\n    getCoordinates: function () {\n\n    },\n    /**\n     * MultiPolylinelineString\n     * @method getLineString\n     * @param {Number}index\n     * @returns {fastmap.mapApi.LineString}\n     */\n    getLineString: function (index) {\n        var lineString = new fastmap.mapApi.LineString(null);\n        return lineString;\n    },\n    /**\n     * MultiPolylinelineString\n     * @method getLineStrings\n     * @returns {Array}\n     */\n    getLineStrings: function () {\n        var lineStrings = [];\n        return lineStrings;\n    },\n    /**\n     * set lineStrings\n     * @method setLineString\n     * @param {Array}lineStrings\n     */\n    setLineStrings: function (lineStrings) {\n\n    },\n    /**\n     * \n     * @method closestPointXY\n     */\n    closestPointXY: function () {\n\n    },\n    /**\n     * \n     * @method intersectsExtend\n     * @param {object}extend\n     */\n    intersectsExtent: function (extend) {\n\n    },\n    /**\n     * MultiPolyline\n     * @param {Number}squaredTolerance\n     * @returns {L.MultiPolyline}\n     */\n    getSimplifiedGeometryInternal: function (squaredTolerance) {\n        var simplifiedFlatCoordinates = [];\n        var simplifiedMultiLineString = new fastmap.mapApi.MultiPolyline(null);\n        return simplifiedMultiLineString;\n    }\n});\nfastmap.mapApi.multiPolyline = function (coordiates, options, activeCoordinates, activeOptions) {\n    return new fastmap.mapApi.MultiPolyline(coordiates, options, activeCoordinates, activeOptions);\n};\n","/**\n * Created by xujie on 2016/11/32\n * geojson\n */\nfastmap.mapApi.geometry.GeometryAlgorithm = L.Class.extend({\n    initialize: function (options) {\n        this.reader = new jsts.io.GeoJSONReader();\n        this.writer = new jsts.io.GeoJSONWriter();\n        this.wktReader = new jsts.io.WKTReader();\n        this.wktWriter = new jsts.io.WKTWriter();\n        this.factory = new jsts.geom.GeometryFactory();\n        this.geometryTransform = FM.mapApi.GeometryTransform.getInstance();\n        this.proj4Transform = FM.mapApi.Proj4Transform.getInstance();\n    },\n\n    distance: function (geometry1, geometry2) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        return jstsGeometry1.distance(jstsGeometry2);\n    },\n\n    /**\n     * ,\n     * @param point1 geosjson\n     * @param point2 geosjson\n     * @returns {number}\n     */\n    sphericalDistance: function (point1, point2) {\n        var self = this;\n        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {\n            return self.proj4Transform.wgs84ToXian80(coordinates);\n        });\n        var p1 = this.geometryTransform.convertGeometry(point1);\n        var p2 = this.geometryTransform.convertGeometry(point2);\n        return this.distance(p1, p2);\n    },\n\n    nearestPoints: function (geometry1, geometry2) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        var pair = jsts.operation.distance.DistanceOp.nearestPoints(jstsGeometry1, jstsGeometry2);\n        var res = {\n            distance: pair[0].distance(pair[1]),\n            point1: this.writer.write(this.factory.createPoint(pair[0])),\n            point2: this.writer.write(this.factory.createPoint(pair[1]))\n        };\n        return res;\n    },\n\n    contains: function (geometry1, geometry2) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        return jstsGeometry1.contains(jstsGeometry2);\n    },\n\n    /* \n     return: boolen\n     */\n    intersects: function (geometry1, geometry2) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        return jstsGeometry1.intersects(jstsGeometry2);\n    },\n\n    /* \n     return: geoJson\n     */\n    intersection: function (geometry1, geometry2) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        return this.writer.write(jstsGeometry1.intersection(jstsGeometry2));\n    },\n\n    isWithinDistance: function (geometry1, geometry2, distance) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        return jstsGeometry1.isWithinDistance(jstsGeometry2, distance);\n    },\n\n    intersectsAndContains: function (geometry1, geometry2) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        // ,\n        return jstsGeometry1.contains(jstsGeometry2) ? true : jstsGeometry1.intersects(jstsGeometry2);\n    },\n\n    bbox: function (geometry) {\n        var jstsGeometry = this.reader.read(geometry);\n        var envelope = jstsGeometry.getEnvelopeInternal();\n        var bbox = {\n            minX: envelope.getMinX(),\n            minY: envelope.getMinY(),\n            maxX: envelope.getMaxX(),\n            maxY: envelope.getMaxY()\n        };\n        return bbox;\n    },\n\n    bboxToPolygon: function (bbox) {\n        var geojson = {\n            type: 'Polygon',\n            coordinates: [\n                [\n                    [bbox.minX, bbox.minY],\n                    [bbox.maxX, bbox.minY],\n                    [bbox.maxX, bbox.maxY],\n                    [bbox.minX, bbox.maxY],\n                    [bbox.minX, bbox.minY]\n                ]\n            ]\n        };\n        return geojson;\n    },\n\n    centroid: function (geometry) {\n        var jstsGeometry = this.reader.read(geometry);\n        var coordinate = jstsGeometry.getCentroid().getCoordinate();\n        var point = {\n            type: 'Point',\n            coordinates: [coordinate.x, coordinate.y]\n        };\n        return point;\n    },\n\n    buffer: function (geometry, distance) {\n        var jstsGeometry = this.reader.read(geometry);\n        var parameters = new jsts.operation.buffer.BufferParameters();\n        parameters.setEndCapStyle(jsts.operation.buffer.BufferParameters.CAP_ROUND);\n        parameters.setJoinStyle(jsts.operation.buffer.BufferParameters.JOIN_ROUND);\n        // parameters.setSingleSided(true);\n        var bufferOp = new jsts.operation.buffer.BufferOp(jstsGeometry, parameters);\n        var buffer = bufferOp.getResultGeometry(distance);\n        return this.writer.write(buffer);\n    },\n\n    convexHull: function (geometry) {\n        var jstsGeometry = this.reader.read(geometry);\n        var convexHull = jstsGeometry.convexHull();\n        return this.writer.write(convexHull);\n    },\n\n    nearestLocations: function (point, lineString) {\n        var jstsPoint = this.reader.read(point);\n        var jstsLineString = this.reader.read(lineString);\n        var distanceOp = new jsts.operation.distance.DistanceOp(jstsPoint, jstsLineString);\n        var pair = distanceOp.nearestLocations();\n        var p0 = this.factory.createPoint(pair[0].getCoordinate());\n        var p1 = this.factory.createPoint(pair[1].getCoordinate());\n        var segmentIndex = pair[1].getSegmentIndex();\n        var res = {\n            distance: p0.distance(p1),\n            point: this.writer.write(p1),\n            previousIndex: segmentIndex,\n            nextIndex: segmentIndex + 1,\n            previousPoint: this.writer.write(jstsLineString.getPointN(segmentIndex)),\n            nextPoint: this.writer.write(jstsLineString.getPointN(segmentIndex + 1))\n        };\n        return res;\n    },\n\n    wktToGeojson: function (wkt) {\n        try {\n            var jstsGeometry = this.wktReader.read(wkt);\n            return this.writer.write(jstsGeometry);\n        } catch (e) {\n            return null;\n        }\n    },\n\n    geoJsonToWkt: function (geojson) {\n        try {\n            var jstsGeometry = this.reader.read(geojson);\n            return this.wktWriter.write(jstsGeometry);\n        } catch (e) {\n            return null;\n        }\n    },\n\n    // \n    getLength: function (geometry) {\n        var self = this;\n        var func = function (map, tile, coordinates) {\n            return self.proj4Transform.wgs84ToXian80(coordinates);\n        };\n        this.geometryTransform.setEnviroment(null, null, func);\n        var g = this.geometryTransform.convertGeometry(geometry);\n\n        var jstsGeometry = this.reader.read(g);\n        return jstsGeometry.getLength();\n    },\n\n    /**\n     * LineString,\n     * @param lineString geosjson\n     * @returns {number}\n     */\n    sphericalLength: function (lineString) {\n        if (lineString.coordinates.length < 2) {\n            return 0;\n        }\n\n        var self = this;\n        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {\n            return self.proj4Transform.wgs84ToXian80(coordinates);\n        });\n        var g = this.geometryTransform.convertGeometry(lineString);\n\n        var jstsGeometry = this.reader.read(g);\n        return jstsGeometry.getLength();\n    },\n\n    isClosed: function (lineString) {\n        var length = lineString.coordinates.length;\n        if (length < 3) {\n            return false;\n        }\n        var jstsGeometry = this.reader.read(lineString);\n        return jstsGeometry.isClosed();\n    },\n\n    close: function (lineString) {\n        var length = lineString.coordinates.length;\n        if (length < 3) {\n            throw new Error('LineString!');\n        }\n        lineString.coordinates[length] = lineString.coordinates[0];\n    },\n\n    /**\n     * \n     * @param x x\n     * @param y y\n     * @param radius \n     * @param startAngle ,\n     * @param endAngle ,\n     * @param distance \n     * @returns {{type: string, coordinates: Array}}\n     */\n    arc: function (x, y, radius, startAngle, endAngle, distance) {\n        if (endAngle < startAngle) {\n            throw new Error('endAnglestartAngle');\n        }\n        var perimeter = 2 * Math.PI * radius;\n        var count = Math.floor(perimeter / distance);\n        var remainderLength = perimeter % distance;\n        var remainderAngle = 180 * remainderLength / (Math.PI * radius);\n        var angleStep = (360 - remainderAngle) / count;\n\n        var vector = new fastmap.mapApi.symbol.Vector(0, -1);\n        vector = vector.multiNumber(radius);\n        var matrix = new fastmap.mapApi.symbol.Matrix();\n        var point = new fastmap.mapApi.symbol.Point(x, y);\n        var geometry = {\n            type: 'LineString',\n            coordinates: []\n        };\n\n        var tmpVector = null;\n        var tmpPoint = null;\n        var tmpMatrix = null;\n        for (var i = startAngle; i < endAngle;) {\n            tmpMatrix = matrix.makeRotate(i);\n            tmpVector = vector.crossMatrix(tmpMatrix);\n            tmpPoint = point.plusVector(tmpVector);\n            geometry.coordinates.push([tmpPoint.x, tmpPoint.y]);\n            i += angleStep;\n        }\n        tmpMatrix = matrix.makeRotate(endAngle);\n        tmpVector = vector.crossMatrix(tmpMatrix);\n        tmpPoint = point.plusVector(tmpVector);\n        geometry.coordinates.push([tmpPoint.x, tmpPoint.y]);\n\n        return geometry;\n    },\n\n    equals: function (geometry1, geometry2) {\n        var jstsGeometry1 = this.reader.read(geometry1);\n        var jstsGeometry2 = this.reader.read(geometry2);\n        return jstsGeometry1.equals(jstsGeometry2);\n    },\n\n    /**\n     * ,\n     * @param polygon polygon\n     * @returns {number}\n     */\n    sphericalArea: function (polygon) {\n        if (polygon.coordinates.length === 0) {\n            return 0;\n        }\n        if (polygon.coordinates[0].length < 3) {\n            return 0;\n        }\n\n        var self = this;\n        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {\n            return self.proj4Transform.wgs84ToXian80(coordinates);\n        });\n\n        var g = this.geometryTransform.convertGeometry(polygon);\n\n        var jstsGeometry1 = this.reader.read(g);\n        return jstsGeometry1.getArea();\n    },\n\n    isSimple: function (geometry) {\n        var jstsGeometry = this.reader.read(geometry);\n        return jstsGeometry.isSimple();\n    },\n\n    isValidGeometry: function (geometry) {\n        try {\n            var jstsGeometry = this.reader.read(geometry);\n            return true;\n        } catch (err) {\n            // FM.Util.log(err);\n            return false;\n        }\n    },\n\n    getGeometriesByType: function (geometry, targetType) {\n        if (!geometry) {\n            return [];\n        }\n        var type = geometry.type;\n        var geometries = [];\n        switch (type) {\n            case 'MultiPoint':\n            case 'MultiLineString':\n            case 'MultiPolygon':\n                geometries = this.multiGeometryToArray(geometry);\n                break;\n            case 'GeometryCollection':\n                for (var i = 0; i < geometry.geometries.length; ++i) {\n                    var subGeometry = geometry.geometries[i];\n                    geometries = geometries.concat(this.getGeometriesByType(subGeometry, targetType));\n                }\n                break;\n            default:\n                if (type === targetType) {\n                    geometries.push(geometry);\n                }\n        }\n        return geometries;\n    },\n\n    multiGeometryToArray: function (multiGeometry) {\n        var geometries = [];\n        var type = multiGeometry.type;\n        for (var i = 0; i < multiGeometry.coordinates.length; ++i) {\n            var geometry = {\n                type: type.substr(5),\n                coordinates: multiGeometry.coordinates[i]\n            };\n            geometries.push(geometry);\n        }\n        return geometries;\n    },\n\n    precision: function (value, num) {\n        var factor = Math.pow(10, num);\n        var value1 = value * factor;\n        value1 += 0.5;\n        value1 = Math.floor(value1);\n        value1 /= factor;\n        return value1;\n    },\n\n    precisionGeometry: function (geometry, num) {\n        var self = this;\n        this.geometryTransform.setEnviroment(null, null, function (map, tile, coordinates) {\n            var x = self.precision(coordinates[0], num);\n            var y = self.precision(coordinates[1], num);\n            return [x, y];\n        });\n\n        var g = this.geometryTransform.convertGeometry(geometry);\n        return g;\n    },\n\n    destroy: function () {\n        fastmap.mapApi.geometry.GeometryAlgorithm.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.geometry.GeometryAlgorithm.instance) {\n                fastmap.mapApi.geometry.GeometryAlgorithm.instance =\n                    new fastmap.mapApi.geometry.GeometryAlgorithm();\n            }\n            return fastmap.mapApi.geometry.GeometryAlgorithm.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.Feedback = L.Class.extend({\n    initialize: function () {\n        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        this.priority = 0;\n        this.drawItems = [];\n    },\n\n    add: function (geojson, symbol) {\n        if (!geojson || !symbol) {\n            return;\n        }\n        var geometry = this.geometryFactory.fromGeojson(geojson);\n        var item = {\n            geometry: geometry,\n            symbol: symbol,\n            type: 'geometry'\n        };\n        this.drawItems.push(item);\n    },\n\n    addPid: function (pid, featureType, symbol) {\n        if (pid && featureType && symbol) {\n            this.drawItems.push({\n                pid: pid,\n                featureType: featureType,\n                symbol: symbol,\n                type: 'pid'\n            });\n        }\n    },\n\n    del: function (index) {\n        this.drawItems.splice(index, 1);\n    },\n\n    clear: function () {\n        this.drawItems = [];\n    },\n\n    getDrawItems: function () {\n        return this.drawItems;\n    },\n\n    setDrawItems: function (items) {\n        if (FM.Util.isObject(items)) {\n            this.drawItems.push(items);\n        } else if (FM.Util.isArray(items)) {\n            Array.prototype.push.apply(this.drawItems, items);\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.FeedbackController = L.Class.extend({\n\n    initialize: function () {\n        this.eventController = fastmap.uikit.EventController();\n        this.feedbacks = [];\n    },\n\n    add: function (feedback) {\n        var existFeedback = this.feedbacks.find(function (element, index, array) {\n            return element === feedback;\n        });\n\n        if (existFeedback) {\n            return;\n        }\n\n        this.feedbacks.push(feedback);\n\n        this.feedbacks.sort(function (a, b) {\n            return a.priority - b.priority;\n        });\n    },\n\n    del: function (feedback) {\n        var existFeedback = this.feedbacks.find(function (element, index, array) {\n            return element === feedback;\n        });\n\n        if (!existFeedback) {\n            return;\n        }\n\n        this.feedbacks = this.feedbacks.filter(function (element, index, array) {\n            return element !== feedback;\n        });\n    },\n\n    clear: function () {\n        this.feedbacks = [];\n    },\n\n    refresh: function () {\n        var drawItems = [];\n        this.feedbacks.forEach(function (element, index, array) {\n            drawItems = drawItems.concat(element.getDrawItems());\n        });\n\n        this.eventController.fire(L.Mixin.EventTypes.FEEDBACKREFRESH, { drawItems: drawItems });\n    },\n\n    destroy: function () {\n        fastmap.mapApi.FeedbackController.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.FeedbackController.instance) {\n                fastmap.mapApi.FeedbackController.instance =\n                    new fastmap.mapApi.FeedbackController();\n            }\n            return fastmap.mapApi.FeedbackController.instance;\n        }\n    }\n});\n","/**\n * Bounds\n * \n *\n * @namespace mapApi\n * @class Bounds\n */\nfastmap.mapApi.Bounds = L.Class.extend({\n    /**\n     * @method initialize\n     * \n     *\n     * @param {Number} left\n     * @param {Number} bottom\n     * @param {Number} right\n     * @param {Number} top\n     *\n     * @return {fastmap.mapApi.Bounds} \n     */\n    initialize: function (left, bottom, right, top) {\n        if (left) {\n            this.left = parseFloat(left);\n        }\n        if (bottom) {\n            this.bottom = parseFloat(bottom);\n        }\n        if (right) {\n            this.right = parseFloat(right);\n        }\n        if (top) {\n            this.top = parseFloat(top);\n        }\n    },\n    /**\n     * @method clone\n     * bounds\n     *\n     * @return {fastmap.mapApi.Bounds} \n     */\n    clone: function () {\n        return new fastmap.mapApi.Bounds(this.left, this.bottom, this.right, this.top);\n    },\n    /**\n     * @method equals\n     * bounds\n     *\n     * @param {fastmap.mapApi.Bounds} bounds\n     * @return {Boolean} boundsbounds\n     */\n    equals: function (bounds) {\n        var equals = false;\n        if (bounds != null) {\n            equals = ((this.left === bounds.left) && (this.right === bounds.right)\n            && (this.top === bounds.top) && (this.bottom === bounds.bottom));\n        }\n        return equals;\n    }\n});\nfastmap.mapApi.bounds = function (options) {\n    return new fastmap.mapApi.Bounds(options);\n};\n","/**\n * Created by xujie on 2017/01/11\n * Recreated by chenx on 2017-5-12\n * \n */\nFM.mapApi.Map = L.Class.extend({\n    options: {\n        tileSize: 256,\n        container: 'editorMap',\n        center: [0, 0],\n        zoom: 0\n    },\n\n    initialize: function (options) {\n        FM.setOptions(this, options);\n\n        this._tiles = [];\n        this._leafletMap = null;\n\n        this._sourceController = fastmap.mapApi.source.SourceController.getInstance();\n        this._tileRequestController = fastmap.mapApi.TileRequestController.getInstance();\n\n        this._activeLeafletVectorLayer = null;\n        // scenelayer\n        this._featureLayers = [];\n\n        this._initLeafletMap();\n    },\n\n    _initLeafletMap: function () {\n        this._leafletMap = this._createLeafletMap();\n        this._bindLeafletMapEvent();\n    },\n\n    _createLeafletMap: function () {\n        var leafletMap = L.map(this.options.container, {\n            dragging: false,\n            touchZoom: false,\n            doubleClickZoom: false,\n            scrollWheelZoom: false,\n            boxZoom: false,\n            keyboard: false,\n            tap: false,\n            attributionControl: false,\n            zoomControl: false,\n            center: this.options.center,\n            zoom: this.options.zoom\n        });\n        return leafletMap;\n    },\n\n    _bindLeafletMapEvent: function () {\n        this._leafletMap.on('moveend', this._onMapMoveEnd, this);\n        this._leafletMap.on('resize', this._onMapMoveEnd, this);\n    },\n\n    getLeafletMap: function () {\n        return this._leafletMap;\n    },\n\n    setZoom: function (zoom) {\n        return this._leafletMap.setZoom(zoom);\n    },\n\n    getZoom: function () {\n        return this._leafletMap.getZoom();\n    },\n\n    _getVectorLayers: function () {\n        var layers = [];\n        this._leafletMap.eachLayer(function (item) {\n            if (item instanceof FM.mapApi.VectorLayer) {\n                layers.push(item);\n            }\n        });\n\n        return layers;\n    },\n\n    _clearVectorLayers: function () {\n        var layers = [];\n        this._leafletMap.eachLayer(function (item) {\n            if (item instanceof FM.mapApi.VectorLayer) {\n                item.clear();\n            }\n        });\n\n        return layers;\n    },\n\n    _redrawNonVectorLayers: function () {\n        this._leafletMap.eachLayer(function (item) {\n            if (!(item instanceof FM.mapApi.VectorLayer) && item.redraw) {\n                item.redraw();\n            }\n        });\n    },\n\n    _getFeatureLayers: function () {\n        var layers = [];\n        this._leafletMap.eachLayer(function (item) {\n            if (item instanceof FM.mapApi.VectorLayer) {\n                var visibleLayers = item.getSceneLayers().filter(function (layer) {\n                    return layer.visible();\n                });\n                Array.prototype.push.apply(layers, visibleLayers);\n            }\n        });\n\n        return layers;\n    },\n\n    // \n    redraw: function (layers) {\n        this._redrawNonVectorLayers();\n\n        this._clearVectorLayers();\n\n        if (layers && layers.length > 0) {\n            var redLayers = [];\n            for (var i = 0; i < layers.length; i++) {\n                this._delLayerData(layers[i]);\n                redLayers.push(layers[i].getLeafletLayer());\n            }\n\n            this._requestAndDrawTiles(this._tiles, layers);\n\n            var vectorLayer = this._getVectorLayers();\n            var greenLayers = FM.Util.difference(vectorLayer, redLayers);\n            this._redrawTiles(this._tiles, greenLayers);\n        } else {\n            this._delTilesData(this._tiles);\n\n            this._requestAndDrawTiles(this._tiles, this._featureLayers);\n        }\n    },\n\n    // \n    refresh: function () {\n        // this._tileRequestController.clear();\n        var i;\n        var vectorLayer = this._getVectorLayers();\n        var featureLayers = this._getFeatureLayers();\n\n        var addLayers = FM.Util.differenceBy(featureLayers, this._featureLayers, 'id');\n        var delLayers = FM.Util.differenceBy(this._featureLayers, featureLayers, 'id');\n        var remLayers = FM.Util.intersectionBy(featureLayers, this._featureLayers, 'id');\n\n        this._clearVectorLayers();\n\n        delLayers = delLayers.filter(function (item) {\n            for (var k = 0; k < remLayers.length; k++) {\n                if (item.useSameData(remLayers[k])) {\n                    return false;\n                }\n            }\n            return true;\n        });\n\n        var redLayers = [];\n        for (i = 0; i < addLayers.length; i++) {\n            redLayers.push(addLayers[i].getLeafletLayer());\n        }\n        this._requestAndDrawTiles(this._tiles, addLayers);\n\n        var greenLayers = FM.Util.difference(vectorLayer, redLayers);\n        this._redrawTiles(this._tiles, greenLayers);\n\n        this._featureLayers = featureLayers;\n    },\n\n    // \n    _onMapMoveEnd: function () {\n        var tiles = this._getTiles();\n        var addTiles = FM.Util.differenceBy(tiles, this._tiles, 'name');\n        var delTiles = FM.Util.differenceBy(this._tiles, tiles, 'name');\n        var remTiles = FM.Util.intersectionBy(tiles, this._tiles, 'name');\n\n        this._clearVectorLayers();\n\n        this._delTilesData(delTiles);\n\n        var layers = this._getVectorLayers();\n\n        this._requestAndDrawTiles(addTiles, this._featureLayers);\n\n        this._redrawTiles(remTiles, layers);\n\n        this._tiles = tiles;\n    },\n\n    _getTiles: function () {\n        var map = this._leafletMap;\n        var bounds = map.getPixelBounds();\n        var zoom = map.getZoom();\n        var tileSize = this.options.tileSize;\n\n        var tileBounds = L.bounds(\n            bounds.min.divideBy(tileSize)._floor(),\n            bounds.max.divideBy(tileSize)._floor());\n\n        var queue = [];\n        var center = tileBounds.getCenter();\n\n        for (var j = tileBounds.min.y; j <= tileBounds.max.y; j++) {\n            for (var i = tileBounds.min.x; i <= tileBounds.max.x; i++) {\n                var point = new L.Point(i, j);\n                queue.push(point);\n            }\n        }\n\n        // load tiles in order of their distance to center\n        queue.sort(function (a, b) {\n            return a.distanceTo(center) - b.distanceTo(center);\n        });\n\n        var tiles = [];\n        for (i = 0; i < queue.length; ++i) {\n            var x = queue[i].x;\n            var y = queue[i].y;\n            var tile = this._createTile(x, y, zoom);\n            tiles.push(tile);\n        }\n\n        return tiles;\n    },\n\n    _createTile: function (x, y, z) {\n        var tile = {\n            name: x + ':' + y,\n            fullName: x + ':' + y + ':' + z,\n            x: x,\n            y: y,\n            z: z,\n            size: this.options.tileSize\n        };\n        return tile;\n    },\n\n    _requestAndDrawTiles: function (tiles, layers) {\n        if (tiles.length === 0 || layers.length === 0) {\n            return;\n        }\n\n        this._leafletMap.fire('TileLayersLoading', {\n            layers: layers,\n            tiles: tiles\n        });\n\n        var self = this;\n        var vectorLayers = [];\n        var i,\n            temp;\n        for (i = 0; i < layers.length; i++) {\n            temp = layers[i].getLeafletLayer();\n            if (vectorLayers.indexOf(temp) < 0) {\n                vectorLayers.push(temp);\n            }\n        }\n\n        var innerFunc = function (tile, index) {\n            return self._requestTileData(tile, index, layers)\n                .then(function () {\n                    self._redrawTile(tile, vectorLayers);\n                });\n        };\n\n        var promises = [];\n        for (i = 0; i < tiles.length; ++i) {\n            promises.push(innerFunc(tiles[i], i));\n        }\n\n        Promise.all(promises).then(function () {\n            self._leafletMap.fire('TileLayersLoaded', {\n                layers: layers,\n                tiles: tiles\n            });\n        });\n    },\n\n    _redrawTiles: function (tiles, vectorLayers) {\n        if (tiles.length === 0 || vectorLayers.length === 0) {\n            return;\n        }\n\n        var tile;\n        for (var i = 0; i < tiles.length; ++i) {\n            tile = tiles[i];\n            this._redrawTile(tile, vectorLayers);\n        }\n    },\n\n    _redrawTile: function (tile, vectorLayers) {\n        for (var i = 0; i < vectorLayers.length; ++i) {\n            vectorLayers[i].draw(tile);\n        }\n    },\n\n    _requestTileData: function (tile, tileIndex, layers) {\n        var urlObject = this._createUrlObject(tile, layers);\n        return this._sourceController.requestTileData(tile, tileIndex, urlObject);\n    },\n\n    _createUrlObject: function (tile, layers) {\n        var zoom = this._leafletMap.getZoom();\n        var urls = {};\n        var layer,\n            options,\n            sourceName,\n            featureType;\n        for (var i = 0; i < layers.length; ++i) {\n            if (!layers[i].canDraw(zoom)) {\n                continue;\n            }\n            options = layers[i].getOptions();\n            sourceName = options.source;\n            featureType = options.serverFeatureType;\n            if (!featureType) {\n                featureType = options.featureType;\n            }\n\n            if (!urls.hasOwnProperty(sourceName)) {\n                urls[sourceName] = [];\n            }\n            urls[sourceName].push(featureType);\n        }\n        return urls;\n    },\n\n    _onRequestTileDataError: function (e) {\n        throw new Error(e);\n    },\n\n    _delTilesData: function (tiles) {\n        for (var i = 0; i < tiles.length; ++i) {\n            var tile = tiles[i];\n            this._delTileData(tile);\n        }\n    },\n\n    _delTileData: function (tile) {\n        this._tileRequestController.del(tile.fullName);\n        var sources = this._sourceController.getAllSources();\n        for (var i = 0; i < sources.length; ++i) {\n            var source = sources[i];\n            source.delByTile(tile.fullName);\n        }\n    },\n\n    _delLayerData: function (sceneLayer) {\n        var sources = this._sourceController.getSource(sceneLayer.getSourceName());\n        var featureType = sceneLayer.getFeatureType();\n        for (var i = 0; i < this._tiles.length; i++) {\n            sources.delByType(featureType, this._tiles[i].fullName);\n        }\n    },\n\n    _createWmsLayer: function (sceneLayer) {\n        var opts = this._getLeafletLayerOption(sceneLayer);\n\n        return L.tileLayer.customwms(opts.source, opts);\n    },\n\n    _createRasterLayer: function (sceneLayer) {\n        var opts = this._getLeafletLayerOption(sceneLayer);\n\n        return L.tileLayer(opts.source, opts);\n    },\n\n    _createVectorLayer: function () {\n        return FM.mapApi.vectorLayer();\n    },\n\n    _createGridLayer: function (sceneLayer) {\n        var opts = this._getLeafletLayerOption(sceneLayer);\n\n        return FM.mapApi.gridLayer(opts);\n    },\n\n    _createMeshLayer: function (sceneLayer) {\n        var opts = this._getLeafletLayerOption(sceneLayer);\n\n        return FM.mapApi.meshLayer(opts);\n    },\n\n    _createTileBoundsLayer: function (sceneLayer) {\n        var opts = this._getLeafletLayerOption(sceneLayer);\n        opts.tileSize = opts.tileSize || 256;\n\n        return FM.mapApi.tileBoundsLayer(opts);\n    },\n\n    _createFeedbackLayer: function (sceneLayer) {\n        var opts = this._getLeafletLayerOption(sceneLayer);\n\n        return FM.mapApi.feedbackLayer(opts);\n    },\n\n    _createOverlayLayer: function (sceneLayer) {\n        var opts = this._getLeafletLayerOption(sceneLayer);\n\n        return FM.mapApi.overlayLayer(opts);\n    },\n\n    _getLeafletLayerOption: function (sceneLayer) {\n        var opts = {\n            id: sceneLayer.id,\n            name: sceneLayer.name\n        };\n        FM.extend(opts, sceneLayer.options);\n\n        return opts;\n    },\n\n    addLayer: function (sceneLayer) {\n        var leafletLayer;\n        var vectFlag = false;\n        var temp;\n        switch (sceneLayer.type) {\n            case 'wms':\n                leafletLayer = this._createWmsLayer(sceneLayer);\n                break;\n            case 'raster':\n                leafletLayer = this._createRasterLayer(sceneLayer);\n                break;\n            case 'vector':\n                if (!this._activeLeafletVectorLayer || !this._activeLeafletVectorLayer.available()) {\n                    this._activeLeafletVectorLayer = this._createVectorLayer();\n                    leafletLayer = this._activeLeafletVectorLayer;\n                }\n                this._activeLeafletVectorLayer.addSceneLayer(sceneLayer);\n                vectFlag = true;\n                break;\n            case 'grid':\n                leafletLayer = this._createGridLayer(sceneLayer);\n                break;\n            case 'mesh':\n                leafletLayer = this._createMeshLayer(sceneLayer);\n                break;\n            case 'tile':\n                leafletLayer = this._createTileBoundsLayer(sceneLayer);\n                break;\n            case 'feedback':\n                leafletLayer = this._createFeedbackLayer(sceneLayer);\n                break;\n            case 'overlay':\n                leafletLayer = this._createOverlayLayer(sceneLayer);\n                break;\n            default:\n                throw new Error(':' + sceneLayer.type);\n        }\n\n        if (leafletLayer) {\n            this._leafletMap.addLayer(leafletLayer);\n        }\n\n        if (!vectFlag) {\n            sceneLayer.setLeafletLayer(leafletLayer);\n            this._activeLeafletVectorLayer = null;\n        }\n\n        return sceneLayer;\n    },\n\n    removeLayer: function (layer) {\n        var leafletLayer = layer.getLeafletLayer();\n        var temp;\n        if (leafletLayer) {\n            if (layer.type === 'vector') {\n                leafletLayer.removeSceneLayer(layer);\n                if (leafletLayer.getSceneLayers().length === 0) {\n                    if (this._activeLeafletVectorLayer === leafletLayer) {\n                        this._activeLeafletVectorLayer = null;\n                    }\n                    this._leafletMap.removeLayer(leafletLayer);\n                }\n            } else {\n                this._leafletMap.removeLayer(leafletLayer);\n                layer.setLeafletLayer(null);\n            }\n        }\n    }\n});\n","/**\n * Created by zhongxiaoming on 2015/9/6.\n * Class mecator\n */\nfastmap.mapApi.MecatorTranform = function () {\n    this.M_PI = Math.PI;\n    this.originShift = (2 * this.M_PI * 6378137) / 2.0; // 6378137wt\n    this.initialResolution = (2 * this.M_PI * 6378137) / 256;\n};\n/** *\n * \n * @param {number}zoom\n * @returns {number}\n */\nfastmap.mapApi.MecatorTranform.prototype.resolution = function (zoom) {\n    return this.initialResolution / Math.pow(2, zoom);\n};\n/**\n * mecator\n * @param {Number}lon\n * @param {Number}lat\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.lonLat2Mercator = function (lon, lat) {\n    var xy = [];\n    var x = (lon * this.originShift) / 180;\n    var y = Math.log(Math.tan(((90 + lat) * this.M_PI) / 360)) / (this.M_PI / 180);\n    y = (y * this.originShift) / 180;\n    xy.push(x);\n    xy.push(y);\n    return xy;\n};\n/** *\n *\n * mercator\n * @param {number}mx\n * @param {number}my\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.mer2lonlat = function (mx, my) {\n    var lonlat = [];\n    lonlat.push((mx / this.originShift) * 180);\n    lonlat.push((my / this.originShift) * 180);\n    lonlat[1] = (180 / this.M_PI) *\n      ((2 * Math.atan(Math.exp((lonlat[1] * this.M_PI) / 180))) - (this.M_PI / 2));\n    return lonlat;\n};\n/** *\n * mecator\n * @param {number}x\n * @param {number}y\n * @param {number}zoom\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.mercator2Pixel = function (x, y, zoom) {\n    var res = this.resolution(zoom);\n    var px = (x + this.originShift) / res;\n    var py = (-y + this.originShift) / res;\n    var xy = [];\n    xy.push(px);\n    xy.push(py);\n    return xy;\n};\n/** *\n * mecatorqq\n * @param {number}x\n * @param {number}y\n * @param {number}zoom\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.mercator2PixelQQ = function (x, y, zoom) {\n    var res = this.resolution(zoom);\n    var px = (x + this.originShift) / res;\n    var py = (y + this.originShift) / res;\n    var xy = [];\n    xy.push(px);\n    xy.push(py);\n    return xy;\n};\n/** *\n * \n * @param {number}x\n * @param {number}y\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.pixels2Tile = function (x, y) {\n    var tx = Math.ceil(x / 256) - 1;\n    var ty = Math.ceil(y / 256) - 1;\n    var xy = [];\n    xy.push(tx);\n    xy.push(ty);\n    return xy;\n};\n/** *\n * mecator\n * @param {number}x\n * @param {number}y\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.mercator2Tile = function (x, y, zoom) {\n    var merXY = [];\n    var xy = [];\n    merXY = this.mercator2Pixel(x, y, zoom);\n    xy = this.pixels2Tile(merXY[0], merXY[1]);\n    return xy;\n};\n/** *\n * \n * @param {number}x\n * @param {number}y\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.lonlat2Tile = function (lon, lat, zoom) {\n    var xy = [];\n    var res;\n    xy = this.lonLat2Mercator(lon, lat);\n    xy = this.mercator2Pixel(xy[0], xy[1], zoom);\n    res = this.pixels2Tile(xy[0], xy[1]);\n    return res;\n};\n/** *\n * \n * @param {number}x\n * @param {number}y\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.lonlat2Pixel = function (lon, lat, zoom) {\n    var xy = [];\n    xy = this.lonLat2Mercator(lon, lat);\n    xy = this.mercator2Pixel(xy[0], xy[1], zoom);\n    return xy;\n};\nfastmap.mapApi.MecatorTranform.prototype.PixelToLonlat = function (pixelX, pixelY, zoom) {\n    var x = 360 * ((pixelX / (256 << zoom)) - 0.5);\n    var y = 0.5 - (pixelY / (256 << zoom));\n    y = 90 - ((360 * Math.atan(Math.exp(-y * 2 * Math.PI))) / Math.PI);\n    return [x, y];\n};\n/** *\n * \n * @param {number}x\n * @param {number}y\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.scale = function (map) {\n    /* var titleSize = 256;\n     var res = ((2 * Math.PI * 6378137) / titleSize) / Math.pow(2, zoom);\n     return res;*/\n    var bounds = map.getBounds();\n    var centerLat = bounds.getCenter().lat;\n    var halfWorldMeters = 6378137 * Math.PI * Math.cos((centerLat * Math.PI) / 180);\n    var dist = (halfWorldMeters * (bounds.getNorthEast().lng - bounds.getSouthWest().lng)) / 180;\n    var size = map.getSize();\n    var res = dist / size.x;\n    return res;\n};\nfastmap.mapApi.MecatorTranform.prototype.rad = function (d) {\n    return (d * Math.PI) / 180.0;\n};\n/** *\n * \n * @param {number}x\n * @param {number}y\n * @returns {Array}\n */\nfastmap.mapApi.MecatorTranform.prototype.distance = function (lat1, lon1, lat2, lon2) {\n    var radius = 6378137;\n    var a = fastmap.mapApi.MecatorTranform.prototype.rad(lat1)\n      - fastmap.mapApi.MecatorTranform.prototype.rad(lat2);\n    var b = fastmap.mapApi.MecatorTranform.prototype.rad(lon1)\n      - fastmap.mapApi.MecatorTranform.prototype.rad(lon2);\n    var s = 2 * Math.asin(\n          Math.sqrt(\n            (Math.pow(Math.sin(a / 2), 2) + (\n            Math.cos(fastmap.mapApi.MecatorTranform.prototype.rad(lat1)) *\n            Math.cos(fastmap.mapApi.MecatorTranform.prototype.rad(lat2)) *\n            Math.pow(Math.sin(b / 2), 2)))\n          )\n      );\n    s *= radius;\n    return Math.abs(s);\n};\n","/**\n * Created by zhongxiaoming on 2015/9/6.\n * Class Tile\n */\nfastmap.mapApi.Tile = L.Class.extend({\n    options: {},\n    /** *\n     *\n     * @param {String}url url\n     * @param {Object}options \n     */\n    initialize: function (url, options) {\n        this.options = options || {};\n        L.setOptions(this, options);\n        this.url = url;\n        this.data = {};\n        this.xmlhttprequest = {};\n    },\n    /** *\n     * tileurl\n     * @returns {tileJson.url}\n     */\n    getUrl: function () {\n        return this.url;\n    },\n    /** *\n     * tiledata\n     * @returns {*}\n     */\n    getData: function () {\n        return this.data;\n    },\n    /** *\n     * tiledata\n     * @param {Object}data\n     */\n    setData: function (data) {\n        this.data = data;\n    },\n    /** *\n     * tilehttmxmlrequest\n     * @returns {{}|*}\n     */\n    getRequest: function () {\n        return this.xmlhttprequest;\n    },\n    /** *\n     * tilehttmxmlrequest\n     * @param {XMLHttpRequest}xmlhttprequest\n     */\n    setRequest: function (xmlhttprequest) {\n        this.xmlhttprequest = xmlhttprequest;\n    }\n});\n/** *\n * tile\n * @param {String}url  url\n * @param {Object}options \n * @returns {.mapApi.Tile}\n */\nfastmap.mapApi.tile = function (url, options) {\n    return new fastmap.mapApi.Tile(url, options);\n};\n","/**\n * Created by wangtun on 2016/4/21.\n */\nfastmap.mapApi.ShapeOptionType = {\n    /*\n       \n     */\n    DRAWPATH: 'drawPath',\n    ADDBORDERTIPS: 'addBorderTips',\n    DRAWRWLINK: 'drawRwLink',\n    /*\n      AdLink\n     */\n    DRAWADLINK: 'drawAdLink',\n    /*\n     \n     */\n    SELECTPARENT: 'SelectParent',\n    /*\n     /*\n     \n     */\n    POISAME: 'PoiSame',\n    /*\n      \n     */\n    DRAWPOLYGON: 'drawPolygon',\n    /*\n     \n     */\n    PATHCOPY: 'pathcopy',\n    /*\n     \n     */\n    PATHCUT: 'pathcut',\n    /*\n     \n     */\n    PATHVERTEXINSERT: 'pathVertexInsert',\n    /*\n      \n     */\n    PATHVERTEXMOVE: 'pathVertexMove',\n    /*\n      \n     */\n    PATHVERTEXREMOVE: 'pathVertexReMove',\n    /*\n      \n     */\n    PATHVERTEXADD: 'pathVertexAdd',\n    /*\n      \n     */\n    PATHBREAK: 'pathBreak',\n    /*\n     \n     */\n    TRANSFORMDIRECT: 'transformDirect',\n    /*\n      \n     */\n    PATHNODEMOVE: 'pathNodeMove',\n    /*\n      \n     */\n    POINTVERTEXADD: 'pointVertexAdd',\n    /*\n     /*\n     \n     */\n    UPDATESPEEDNODE: 'updateSpeedNode',\n    /*\n    \n     */\n    ADADMINMOVE: 'adAdminMove',\n    /*\n     \n     */\n    PATHBUFFER: 'pathBuffer',\n    /*\n     \n     */\n    PATHSIDE: 'pathSide',\n\n    /*\n     \n     */\n    POILOCMOVE: 'poiLocMove',\n    /*\n     \n     */\n    POIGUIDEMOVE: 'poiGuideMove',\n    /*\n     \n     */\n    POIAUTODRAG: 'poiAutoDrag',\n    /*\n     poi\n     */\n    POIADD: 'poiAdd',\n    /*\n     \n     */\n    TRAFFICSIGNAL: 'trafficSignal',\n    /*\n     \n     */\n    WARNINGINFO: 'warningInfo',\n    /*\n     \n     */\n    GATE: 'gate',\n    /*\n     \n     */\n    ELECTRONICEYE: 'electronicEye',\n    /*\n     \n     */\n    ELECTRANSFORMDIRECT: 'elecTransformDirect',\n    /*\n     \n     */\n    RDSLOPE: 'rdSlope',\n    /*\n     CRF\n     */\n    CRFINTER: 'CRFInter',\n    /*\n     CRF\n     */\n    CRFROAD: 'CRFRoad',\n    /*\n     /*\n     CRF\n     */\n    CRFOBJECT: 'CRFObject',\n    /*\n     \n     */\n    RDDIRECTROUTE: 'rdDirectRoute',\n    /*\n     \n     */\n    RDSPEEDBUMP: 'rdSpeedBump',\n    /*\n     \n     */\n    RDSE: 'rdSe',\n    /*\n     \n     */\n    RDTOLLGATE: 'rdTollgate',\n    /*\n     \n     */\n    RDVOICEGUIDE: 'rdVoiceguide',\n    /*\n     \n     */\n    VARIABLESPEED: 'variableSpeed',\n    /*\n     \n     */\n    RDLANE: 'rdLane',\n    /*\n     \n     */\n    RDLANETOPODETAIL: 'rdLaneTopoDetail',\n    /*\n     \n     */\n    MODIFYRDCROSS: 'modifyRdcross',\n    /*\n     \n     */\n    RDHGWGLIMIT: 'hgwgLimitDirect',\n    /*\n     \n     */\n    PATHDEPARTNODE: 'pathDepartNode',\n    /*\n     * \n     * */\n    UPDATEHGWHLIMIT: 'updateHgwgLimit',\n    /*\n     * TMC\n     * */\n    TMCTRANSFORMDIRECT: 'tmcTransformDirect',\n    // \n    PATHSMOOTH: 'pathSmooth',\n    // \n    MODIFYBRANCHOUTLINK: 'modifyBranchOutLink',\n    // \n    ADDBRANCH: 'addBranch',\n    // \n    UPDATEADMINPOINT: 'updateAdminPoint'\n};\n\n","/**\n * Created by xujie on 2016/11/32\n * geojson\n */\nfastmap.mapApi.GeometryTransform = L.Class.extend({\n\n    initialize: function () {\n        this.convertFunction = null;\n        this.map = null;\n        this.tile = null;\n    },\n\n    /**\n     * \n     * @param map\n     * @param tile\n     * @param convertFuc\n     */\n    setEnviroment: function (map, tile, convertFuc) {\n        this.convertFunction = convertFuc;\n        this.map = map;\n        this.tile = tile;\n    },\n\n  /**\n   * geojson\n   * \n   * @returns geojson\n   */\n    convertGeometry: function (geojson) {\n        var type = geojson.type;\n        var newGeojson = {\n            type: type\n        };\n        switch (type) {\n            case 'Point':\n                newGeojson.coordinates = this.convertPoint(geojson.coordinates);\n                break;\n            case 'MultiPoint':\n            case 'LineString':\n                newGeojson.coordinates = this.convertLineString(geojson.coordinates);\n                break;\n            case 'MultiLineString':\n            case 'Polygon':\n                newGeojson.coordinates = this.convertPolygon(geojson.coordinates);\n                break;\n            // case 'Polygon':\n            //     newGeojson.coordinates = this.convertPolygon(geojson.coordinates[0]);\n            //     break;\n            case 'MultiPolygon':\n                newGeojson.coordinates = this.convertMultiPolygon(geojson.coordinates);\n                break;\n            case 'GeometryCollection':\n                newGeojson.geometries = this.convertGeometryCollection(geojson.geometries);\n                break;\n            default:\n                throw new Error(':' + type);\n        }\n\n        return newGeojson;\n    },\n\n    convertPoint: function (coordinates) {\n        return this.convertFunction(this.map, this.tile, coordinates);\n    },\n\n    convertLineString: function (coordinates) {\n        var newCoordinates = [];\n        for (var i = 0; i < coordinates.length; ++i) {\n            newCoordinates.push(this.convertPoint(coordinates[i]));\n        }\n\n        return newCoordinates;\n    },\n\n    convertPolygon: function (coordinates) {\n        var newCoordinates = [];\n        for (var i = 0; i < coordinates.length; ++i) {\n            newCoordinates.push(this.convertLineString(coordinates[i]));\n        }\n\n        return newCoordinates;\n    },\n\n    convertMultiPolygon: function (coordinates) {\n        var newCoordinates = [];\n        for (var i = 0; i < coordinates.length; ++i) {\n            newCoordinates.push(this.convertPolygon(coordinates[i]));\n        }\n\n        return newCoordinates;\n    },\n\n    convertGeometryCollection: function (geometries) {\n        var newGeometries = [];\n        for (var i = 0; i < geometries.length; ++i) {\n            newGeometries.push(this.convertGeometry(geometries[i]));\n        }\n\n        return newGeometries;\n    },\n\n    destroy: function () {\n        fastmap.mapApi.GeometryTransform.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.GeometryTransform.instance) {\n                fastmap.mapApi.GeometryTransform.instance =\n                    new fastmap.mapApi.GeometryTransform();\n            }\n            return fastmap.mapApi.GeometryTransform.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/11/32\n * \n */\nfastmap.mapApi.Proj4Transform = L.Class.extend({\n    initialize: function (options) {\n        // epsghttp://spatialreference.org/ref/epsg/\n        // :http://proj4.org/parameters.html#\n\n        // wgs84,espg4326\n        this.sourceProjection = '+title=WGS 84 (long/lat) +proj=longlat +ellps=WGS84 +datum=WGS84 +units=degrees +no_defs';\n\n        // 80:312040\n        // ,epsg2385\n        this.targetProjection = '+title=Xian80.GK3d/CM-120E +proj=tmerc +lat_0=0 +lon_0=120 +k=1 +x_0=500000 +y_0=0 +a=6378140 +b=6356755.288157528 +units=m +no_defs';\n\n        this.transform = proj4(this.sourceProjection, this.targetProjection);\n        this.forward = this.transform.forward;\n        this.inverse = this.transform.inverse;\n    },\n\n    /**\n     * wgs8480\n     * {x:x,y:y}[]\n     * \n     * \n     * @param coordinate\n     * @returns {*}\n     */\n    wgs84ToXian80: function (coordinate) {\n        return this.forward(coordinate);\n    },\n\n    /**\n     * 80wgs84\n     * {x:x,y:y}[]\n     * \n     * \n     * @param coordinate\n     * @returns {*}\n     */\n    xian80ToWGS84: function (coordinate) {\n        return this.inverse(coordinate);\n    },\n\n    destroy: function () {\n        fastmap.mapApi.Proj4Transform.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.Proj4Transform.instance) {\n                fastmap.mapApi.Proj4Transform.instance =\n                    new fastmap.mapApi.Proj4Transform();\n            }\n            return fastmap.mapApi.Proj4Transform.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2017/04/14.\n */\nfastmap.mapApi.TileRequestController = L.Class.extend({\n\n    initialize: function () {\n        this.tiles = {};\n    },\n\n    add: function (tileName, request) {\n        if (!tileName || !request) {\n            return;\n        }\n\n        if (!this.tiles[tileName]) {\n            this.tiles[tileName] = [];\n        }\n\n        this.tiles[tileName].push(request);\n    },\n\n    del: function (tileName) {\n        if (!tileName) {\n            return;\n        }\n\n        if (!this.tiles.hasOwnProperty(tileName)) {\n            return;\n        }\n\n        this.abortTileRequests(tileName);\n\n        delete this.tiles[tileName];\n    },\n\n    getRequests: function (tileName) {\n        return this.tiles[tileName];\n    },\n\n    containTile: function (tileName) {\n        return this.tiles.hasOwnProperty(tileName);\n    },\n\n    abortTileRequests: function (tileName) {\n        var requests = this.tiles[tileName];\n        for (var i = 0; i < requests.length; ++i) {\n            var request = requests[i];\n            request.abort();\n        }\n    },\n\n    clear: function () {\n        var keys = Object.getOwnPropertyNames(this.tiles);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            this.del(key);\n        }\n        this.tiles = {};\n    },\n\n    destroy: function () {\n        fastmap.mapApi.TileRequestController.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.TileRequestController.instance) {\n                fastmap.mapApi.TileRequestController.instance =\n                    new fastmap.mapApi.TileRequestController();\n            }\n            return fastmap.mapApi.TileRequestController.instance;\n        }\n    }\n});\n","/**\n * Created by zhongxiaoming on 2015/9/2.\n * Class Ilayer\n */\nfastmap.mapApi.Layer = L.Class.extend({\n    /** *\n     * @param {Object}options\n     * isVisiablefalse\n     * isSelectablefalse\n     */\n    initialize: function (options) {\n        FM.setOptions(this, options);\n        // this.isVisiable = options.isVisiable ? true : false;\n        // this.isSelectable = options.isSelectable ? true : false;\n        this.isVisiable = this.options.isVisiable;\n        this.isSelectable = this.options.isSelectable;\n    },\n    /** *\n     * \n     * onAddIlayer\n     * @param {L.Map}map\n     */\n    onAdd: function (map) {\n        this._map = map;\n        // map.addLayer(this)\n    },\n    /** *\n     * \n     * onRemoveIlayer\n     * @param {L.Map}map\n     */\n    onRemove: function (map) {\n        // map.removeLayer(this);\n        this._map = null;\n    }\n});\nfastmap.mapApi.layer = function (options) {\n    return new fastmap.mapApi.Layer(options);\n};\n","/**\n * Created by zhongxiaoming on 2015/9/2.\n * Class WholeLayer canvas\n */\nfastmap.mapApi.WholeLayer = fastmap.mapApi.Layer.extend({\n    /** *\n     *\n     * @param options options\n     */\n    // initialize: function (options) {\n    //     fastmap.mapApi.Layer.prototype.initialize.call(this, options);\n    // },\n    /** *\n     * \n     * @param map\n     */\n    onAdd: function (map) {\n        this.map = map;\n        this._initContainer(this.options);\n        map.on('moveend', this._redraw, this);\n        this._redraw();\n    },\n    /** *\n     * \n     * @param map\n     */\n    onRemove: function (map) {\n        map.getPanes().overlayPane.removeChild(this._div);\n        map.off('moveend', this._redraw, this);\n    },\n    /** *\n     * \n     * @param options\n     * @private\n     */\n    _initContainer: function (options) {\n        this.options = options || {};\n        var container = L.DomUtil.create('div', 'leaflet-canvas-container');\n        container.id = options.id || '';\n        container.style.position = 'absolute';\n        container.style.width = this.map.getSize().x + 'px';\n        container.style.height = this.map.getSize().y + 'px';\n        this.canv = document.createElement('canvas');\n        this._ctx = this.canv.getContext('2d');\n        this.canv.width = this.map.getSize().x;\n        this.canv.height = this.map.getSize().y;\n        this.canv.style.width = this.canv.width + 'px';\n        this.canv.style.height = this.canv.height + 'px';\n        container.appendChild(this.canv);\n        this._div = container;\n        this.map.getPanes().overlayPane.appendChild(this._div);\n        this._div.style.zIndex = this.options.zIndex;\n    },\n    setZIndex: function (zIndex) {\n        this._div.style.zIndex = zIndex;\n        return this;\n    },\n    bringToFront: function () {\n        this._div.style.zIndex = 100;\n        return this;\n    },\n    bringToBack: function () {\n        this._div.style.zIndex = 0;\n        return this;\n    },\n    _setAutoZIndex: function (pane, compare) {\n        this.options.zIndex = this._div.style.zIndex = 100;\n    },\n    /** *\n     * \n     */\n    draw: function () {},\n    /** *\n     * \n     * @private\n     */\n    _redraw: function () {\n        this._resetCanvasPosition();\n    },\n    /** *\n     * \n     */\n    clear: function () {},\n    /** *\n     * \n     * @private\n     */\n    _resetCanvasPosition: function () {\n        var bounds = this.map.getBounds();\n        var topLeft = this.map.latLngToLayerPoint(bounds.getNorthWest());\n        L.DomUtil.setPosition(this._div, topLeft);\n    }\n});\nfastmap.mapApi.wholeLayer = function (options) {\n    return new fastmap.mapApi.WholeLayer(options);\n};\n","/**\n * Created by zhongxiaoming on 2015/9/6.\n * Class canvas\n */\nfastmap.mapApi.WholeTileLayer = L.TileLayer.extend({\n    options: {\n        minZoom: 0,\n        maxZoom: 20,\n        tileSize: 256,\n        opacity: 1\n    },\n\n    initialize: function (options) {\n        L.setOptions(this, options);\n        // \n        FM.Util.bind(this);\n        this._dataSource = fastmap.mapApi.source.DataSource.getInstance();\n        this._sceneController = fastmap.mapApi.scene.SceneController.getInstance();\n        this._geojsonTransform = fastmap.mapApi.GeometryTransform.getInstance();\n        this._geometryTransform = fastmap.mapApi.symbol.GeometryTransform.getInstance();\n        this._eventController = fastmap.uikit.EventController();\n        this._eventController.on(L.Mixin.EventTypes.SCENECREFRESH, this._onSceneRefresh);\n        this._drawnFeatures = {};\n    },\n\n    _onSceneRefresh: function () {\n        this.redraw();\n    },\n\n    _initContainer: function () {\n        L.TileLayer.prototype._initContainer.call(this);\n\n        var canvas = document.createElement('canvas');\n        canvas.width = this._map.getSize().x;\n        canvas.height = this._map.getSize().y;\n        this._canvas = canvas;\n        this._tileContainer.appendChild(this._canvas);\n    },\n\n    _resetCanvasPosition: function () {\n        var bounds = this._map.getBounds();\n        var topLeft = this._map.latLngToLayerPoint(bounds.getNorthWest());\n        L.DomUtil.setPosition(this._tileContainer, topLeft);\n    },\n\n    _reset: function (e) {\n        L.TileLayer.prototype._reset.call(this);\n\n        this._resetCanvasPosition();\n\n        this._drawnFeatures = {};\n\n        this._dataSource.clear();\n    },\n\n    _removeTile: function (key) {\n        var tile = this._tiles[key];\n\n        this.fire('tileunload', { tile: tile });\n\n        if (this.options.reuseTiles) {\n            L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\n            this._unusedTiles.push(tile);\n        }\n\n        delete this._tiles[key];\n    },\n\n    _addTile: function (tilePoint, container) {\n        var tilePos = this._getTilePos(tilePoint);\n\n        var tile = this._getTile(tilePoint);\n\n        this._tiles[tile.name] = tile;\n\n        this._loadTile(tile);\n    },\n\n    _getTile: function (tilePoint) {\n        if (this.options.reuseTiles && this._unusedTiles.length > 0) {\n            var tile = this._unusedTiles.pop();\n            this._resetTile(tile);\n            return tile;\n        }\n        return this._createTile(tilePoint);\n    },\n\n    _createTile: function (tilePoint) {\n        var tile = {\n            name: tilePoint.x + ':' + tilePoint.y,\n            x: tilePoint.x,\n            y: tilePoint.y\n        };\n        return tile;\n    },\n\n    _loadTile: function (tile) {\n        var zoom = this._map.getZoom();\n        var promise = this._createTilePromise(tile, zoom);\n        promise.then(this._tilePromiseSuccess)\n            .catch(function (e) {\n                FM.Util.log(e);\n            });\n    },\n\n    _createTilePromise: function (tile, zoom) {\n        var promises = this._createPromises(tile, zoom);\n        var promise = new Promise(function (resolve, reject) {\n            Promise.all(promises)\n                .then(function (res) {\n                    resolve({ tile: tile, res: res });\n                })\n                .catch(function (e) {\n                    reject(e);\n                });\n        });\n\n        return promise;\n    },\n\n    _tileOnLoad: function (tile) {\n        L.DomUtil.addClass(this._tileContainer, 'leaflet-tile-loaded');\n\n        this.fire('tileload', {\n            tile: tile\n        });\n\n        this._tileLoaded();\n    },\n\n    _tileOnError: function (tile) {\n        this.fire('tileerror', {\n            tile: tile\n        });\n\n        this._tileLoaded();\n    },\n\n    _createPromises: function (tile, zoom) {\n        var urlObject = this._createUrlObject(tile);\n        this._uniqueFeatureType(urlObject);\n\n        var promises = [];\n        var keys = Object.getOwnPropertyNames(urlObject);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = urlObject[key];\n            if (!value.featureTypes.length) {\n                continue;\n            }\n            var parameter = this._dataSource.getDataLayer(key).requestParameter;\n            parameter.types = value.featureTypes;\n            parameter.x = tile.x;\n            parameter.y = tile.y;\n            parameter.z = zoom;\n            var url = App.Config.serviceUrl + value.sourceUrl + '?';\n            var promise = this._createAjaxPromise(url, parameter, {\n                tile: tile,\n                source: key,\n                parse: value.parse\n            });\n            promises.push(promise);\n        }\n\n        return promises;\n    },\n\n    _createUrlObject: function (tile) {\n        var urls = {};\n        var currentScene = this._sceneController.getCurrentScene();\n        if (!currentScene) {\n            return urls;\n        }\n        var sceneItems = currentScene.layers;\n        for (var i = 0; i < sceneItems.length; ++i) {\n            var item = sceneItems[i];\n            var source = item.getSourceName();\n            var visiable = item.options.visible;\n            var featureType = item.getFeatureType();\n            if (!visiable || !source || !featureType) {\n                continue;\n            }\n\n            var layer = this._dataSource.getDataLayer(source);\n            var sourceUrl = layer.sourceUrl;\n            var parse = layer.parse;\n            if (!sourceUrl || !parse) {\n                continue;\n            }\n            if (!urls.hasOwnProperty(source)) {\n                urls[source] = {\n                    sourceUrl: sourceUrl,\n                    featureTypes: [],\n                    parse: parse\n                };\n            }\n            urls[source].featureTypes.push(featureType);\n        }\n        return urls;\n    },\n\n    _uniqueFeatureType: function (urlObject) {\n        var keys = Object.getOwnPropertyNames(urlObject);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = urlObject[key];\n            urlObject[key].featureTypes = FM.Util.unique(value.featureTypes);\n        }\n    },\n\n    _createAjaxPromise: function (url, requestParameter, addtionParameter) {\n        var promise = new Promise(function (resolve, reject) {\n            var options = {\n                url: url,\n                requestParameter: requestParameter,\n                parameter: addtionParameter,\n                timeout: 10000,\n                responseType: 'json',\n                // debug: true,\n                onSuccess: function (json, parameter) {\n                    if (json.errcode == 0) { // \n                        resolve({ data: json.data, parameter: parameter });\n                    } else {\n                        reject({ errmsg: json.errmsg, parameter: parameter });\n                    }\n                },\n                onFail: function (errmsg, parameter) {\n                    reject({ errmsg: errmsg, parameter: parameter });\n                },\n                onError: function (errmsg, parameter) {\n                    reject({ errmsg: errmsg, parameter: parameter });\n                },\n                onTimeout: function (errmsg, parameter) {\n                    reject({ errmsg: errmsg, parameter: parameter });\n                }\n            };\n            fastmap.mapApi.ajax.get(options);\n        });\n\n        return promise;\n    },\n\n    _tilePromiseSuccess: function (res) {\n        var allFeatures = {};\n        var tile = res.tile;\n        var tmpRes = res.res;\n        for (var i = 0; i < tmpRes.length; ++i) {\n            var item = tmpRes[i];\n            var data = item.data;\n            var parameter = item.parameter;\n            var layer = this._dataSource.getDataLayer(parameter.source);\n            var features = parameter.parse(data);\n            this._convertGeometry(this._map, parameter.tile, features);\n            this._classifyFeaturesByGeoLiveType(allFeatures, features);\n            this._addFeaturesToDataSource(layer, allFeatures);\n        }\n        console.log(tile.name + '********************************');\n        var urls = this._getDependencyResource(allFeatures);\n        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);\n\n        var self = this;\n        loader.load()\n            .then(function () {\n                self._onDependencyResourceLoaded(allFeatures);\n                self._tileOnLoad(tile);\n            })\n            .catch(function (e) {\n                FM.Util.log(e);\n            });\n    },\n\n    _classifyFeaturesByGeoLiveType: function (allFeatures, features) {\n        for (var i = 0; i < features.length; i++) {\n            var feature = features[i];\n            if (!this._isDrawnFeature(feature)) {\n                var geoLiveType = feature.properties.geoLiveType;\n                if (!allFeatures.hasOwnProperty(geoLiveType)) {\n                    allFeatures[geoLiveType] = [];\n                }\n                allFeatures[geoLiveType].push(feature);\n\n                var id = feature.properties.id;\n                var key = geoLiveType + ':' + id;\n                this._drawnFeatures[key] = true;\n            }\n        }\n    },\n\n    _getDependencyResource: function (allFeatures) {\n        var features = this._getFeatures(allFeatures);\n\n        var urls = [];\n        for (var i = 0; i < features.length; i++) {\n            var feature = features[i];\n            var symbol = feature.properties.symbol;\n            if (!symbol) {\n                continue;\n            }\n\n            if (FM.Util.isArray(symbol)) {\n                urls = urls.concat(this._getUrlsFromSymbolArray(symbol));\n            } else {\n                var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n                urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));\n            }\n        }\n\n        return urls;\n    },\n\n    _getFeatures: function (allFeatures) {\n        var features = [];\n        var keys = Object.getOwnPropertyNames(allFeatures);\n        for (var i = 0; i < keys.length; i++) {\n            var key = keys[i];\n            var tmpFeatures = allFeatures[key];\n            features = features.concat(tmpFeatures);\n        }\n        return features;\n    },\n\n    _getUrlsFromSymbolArray: function (symbols) {\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        var urls = [];\n        for (var i = 0; i < symbols.length; i++) {\n            var symbol = symbols[i];\n            var symbolUrls = symbolFactory.getUrlsFromSymbol(symbol);\n            urls = urls.concat(symbolUrls);\n        }\n\n        return urls;\n    },\n\n    _addFeaturesToDataSource: function (layer, allFeatures) {\n        var keys = Object.getOwnPropertyNames(allFeatures);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var features = allFeatures[key];\n            for (var j = 0; j < features.length; ++j) {\n                var feature = features[j];\n                layer.add(feature);\n            }\n        }\n    },\n\n    _isDrawnFeature: function (feature) {\n        var key = feature.properties.geoLiveType + ':' + feature.properties.id;\n        if (this._drawnFeatures.hasOwnProperty(key)) {\n            return true;\n        }\n\n        return false;\n    },\n\n    _convertGeometry: function (map, tile, features) {\n        this._geojsonTransform.setEnviroment(map, tile, this._convertGeojsonToLngLat);\n        for (var i = 0; i < features.length; ++i) {\n            var feature = features[i];\n            feature.geometry = this._geojsonTransform.convertGeometry(feature.geometry);\n        }\n    },\n\n    _convertGeojsonToLngLat: function (map, tileInfo, coordinates) {\n        var x = tileInfo.x * this.options.tileSize + coordinates[0];\n        var y = tileInfo.y * this.options.tileSize + coordinates[1];\n        var lnglat = map.unproject([x, y]);\n        return [lnglat.lng, lnglat.lat];\n    },\n\n    _onDependencyResourceLoaded: function (allFeatures) {\n        var sceneItems = this._sceneController.currentScene.items;\n        for (var i = 0; i < sceneItems.length; ++i) {\n            var item = sceneItems[i];\n            var source = item.source;\n            var visiable = item.visible;\n            var featureType = item.featureType;\n            var render = item.render;\n            if (!visiable || !source || !featureType || !render) {\n                continue;\n            }\n\n            // eslint-disable-next-line new-cap\n            render = new render();\n\n            var features = allFeatures[featureType];\n            if (features) {\n                console.log(featureType + '+++++++++++++++++++++++++++++++++++++');\n                this._drawFeatures(features, render);\n            }\n        }\n    },\n\n    _drawFeatures: function (features, render) {\n        var g = this._canvas.getContext('2d');\n        var zoom = this._map.getZoom();\n        var pids = [];\n        for (var i = 0; i < features.length; i++) {\n            var feature = features[i];\n            pids.push(feature.properties.id);\n            var symbol = render.symbolize(feature, zoom);\n            if (feature.properties.id === 737370) {\n                var a = 0;\n            }\n\n            if (FM.Util.isArray(symbol)) {\n                this._drawSymbolArray(g, symbol);\n            } else {\n                this._drawSymbol(symbol, g);\n            }\n        }\n        pids = pids.sort();\n        console.log(JSON.stringify(pids));\n        // this.eventController.fire(this.eventController.eventTypes.TILEDRAWEND, {\n        //     layer: this,\n        //     id: ctx.tile.x + ':' + ctx.tile.y,\n        //     zoom: ctx.zoom\n        // });\n    },\n\n    _drawSymbolArray: function (g, array) {\n        array.forEach(function (item) {\n            this._drawSymbol(item, g);\n        }, this);\n    },\n\n    _drawSymbol: function (symbol, g) {\n        this._geometryTransform.setEnviroment(this._map, null, this._convertGeometryToPixel);\n        var convertedGeometry = this._geometryTransform.convertGeometry(symbol.geometry);\n        symbol.geometry = convertedGeometry;\n        symbol.draw(g);\n    },\n\n    _convertGeometryToPixel: function (map, tile, geometry) {\n        var point = map.latLngToContainerPoint([geometry.y, geometry.x]);\n        geometry.x = point.x;\n        geometry.y = point.y;\n        return geometry;\n    }\n});\n","/**\n * Created by xujie on 2016-11-26.\n * WholeCanvasLayer\n */\nfastmap.mapApi.WholeCanvasLayer = fastmap.mapApi.WholeLayer.extend({\n    /** *\n     *\n     * @param options options\n     */\n    initialize: function (options) {\n        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);\n\n        // \n        // FM.Util.bind(this);\n\n        this._drawItems = {};\n\n        this._transform = fastmap.mapApi.symbol.GeometryTransform.getInstance();\n    },\n\n    /** *\n     * \n     * @param map\n     */\n    onAdd: function (map) {\n        this.map = map;\n        this._initContainer(this.options);\n    },\n    /** *\n     * \n     * @param map\n     */\n    onRemove: function (map) {\n        map.getPanes().overlayPane.removeChild(this._div);\n    },\n\n    /** *\n     * \n     */\n    draw: function (tile, features) {\n        var symbols = this._symbolizeFeatures(features);\n        var urls = this._getDependencyResource(symbols);\n        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);\n        var self = this;\n        loader.load()\n            .then(function () {\n                self._onDependencyResourceLoaded(tile, symbols);\n            })\n            .catch(function (e) {\n                FM.Util.log(e);\n            });\n    },\n\n    /** *\n     * \n     */\n    clear: function () {\n        this._resetCanvasPosition();\n        this._ctx.clearRect(0, 0, this.canv.width, this.canv.height);\n        this._drawItems = {};\n    },\n\n    _symbolizeFeatures: function (features) {\n        var zoom = this.map.getZoom();\n        var render = this.options.render;\n\n        // eslint-disable-next-line new-cap\n        render = new render();\n\n        var symbols = [];\n        for (var i = 0; i < features.length; ++i) {\n            var feature = features[i];\n            if (!this._canDraw(zoom, feature)) {\n                continue;\n            }\n\n            var symbol = render.getSymbol(feature, this.map.getZoom());\n            if (!symbol) {\n                // null\n                continue;\n            }\n            if (FM.Util.isArray(symbol)) {\n                symbols = symbols.concat(symbol);\n            } else {\n                symbols.push(symbol);\n            }\n        }\n\n        return symbols;\n    },\n\n    _canDraw: function (zoom, feature) {\n        if (zoom < 17) {\n            // 17,\n            return true;\n        }\n\n        var geoLiveType = feature.properties.geoLiveType;\n        var id = feature.properties.id;\n        var key = geoLiveType + ':' + id;\n        if (this._drawItems.hasOwnProperty(key)) {\n            // \n            return false;\n        }\n\n        this._drawItems[key] = true;\n        return true;\n    },\n\n    _onDependencyResourceLoaded: function (tile, symbols) {\n        this._transform.setEnviroment(this.map, tile, this._convertGeometry);\n        var g = this._ctx.canvas.getContext('2d');\n        for (var i = 0; i < symbols.length; ++i) {\n            var symbol = symbols[i];\n            var convertedGeometry = this._transform.convertGeometry(symbol.geometry);\n            symbol.geometry = convertedGeometry;\n            symbol.draw(g);\n        }\n    },\n\n    _getDependencyResource: function (symbols) {\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        var urls = [];\n        for (var i = 0; i < symbols.length; i++) {\n            var symbol = symbols[i];\n            urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));\n        }\n\n        return urls;\n    },\n\n    _convertGeometry: function (map, tile, geometry) {\n        var origin = this.map.getPixelBounds().min;\n        var x = tile.size * tile.x + geometry.x - origin.x;\n        var y = tile.size * tile.y + geometry.y - origin.y;\n        geometry.x = x;\n        geometry.y = y;\n        return geometry;\n    }\n});\n\nfastmap.mapApi.wholeCanvasLayer = function (options) {\n    return new fastmap.mapApi.WholeCanvasLayer(options);\n};\n","fastmap.mapApi.FrozenCanvasLayer = fastmap.mapApi.WholeCanvasLayer.extend({\n    _symbolizeFeatures: function (features) {\n        var zoom = this.map.getZoom();\n        var renderMap = this.options.renderMap;\n\n        var render;\n        var symbols = [];\n        for (var i = 0; i < features.length; ++i) {\n            var feature = features[i];\n            if (!this._canDraw(zoom, feature)) {\n                continue;\n            }\n\n            render = renderMap[feature.properties.geoLiveType];\n            var symbol = render.getSymbol(feature, this.map.getZoom());\n            if (!symbol) {\n                // null\n                continue;\n            }\n            if (FM.Util.isArray(symbol)) {\n                symbols = symbols.concat(symbol);\n            } else {\n                symbols.push(symbol);\n            }\n        }\n\n        return symbols;\n    },\n\n    setRenderMap: function (geoLiveType, Render) {\n        this.options.renderMap = this.options.renderMap || {};\n\n        if (Render) {\n            this.options.renderMap[geoLiveType] = new Render();\n        } else {\n            delete this.options.renderMap[geoLiveType];\n        }\n    }\n});\n\nfastmap.mapApi.frozenCanvasLayer = function (options) {\n    return new fastmap.mapApi.FrozenCanvasLayer(options);\n};\n","FM.mapApi.VectorLayer = FM.mapApi.WholeCanvasLayer.extend({\n    initialize: function (options) {\n        FM.mapApi.WholeCanvasLayer.prototype.initialize.call(this, options);\n\n        this._sourceController = FM.mapApi.source.SourceController.getInstance();\n        this._sceneLayers = [];\n        this._size = 20; // sceneLayer\n    },\n    /** *\n     * \n     */\n    draw: function (tile) {\n        var symbols = this._getSymbols(tile);\n        var urls = this._getDependencyResource(symbols);\n        var loader = new FM.mapApi.symbol.ImageLoader(urls);\n        var self = this;\n        loader.load()\n            .then(function () {\n                self._onDependencyResourceLoaded(tile, symbols);\n            })\n            .catch(function (e) {\n                FM.Util.log(e);\n            });\n    },\n\n    _getSymbols: function (tile) {\n        var symbols = [];\n        var zoom = this.map.getZoom();\n        var sceneLayer,\n            options,\n            geoLiveType,\n            source,\n            render,\n            features;\n        for (var i = 0; i < this._sceneLayers.length; i++) {\n            sceneLayer = this._sceneLayers[i];\n            if (!sceneLayer.canDraw(zoom)) {\n                continue;\n            }\n\n            options = sceneLayer.getOptions();\n            if (!options.featureType || !options.render || !options.source) {\n                continue;\n            }\n\n            // eslint-disable-next-line new-cap\n            render = new options.render();\n            source = this._sourceController.getSource(options.source);\n            features = source.queryFeaturesByType(options.featureType, tile.fullName);\n\n            Array.prototype.push.apply(symbols, this._symbolizeFeatures(features, sceneLayer, render));\n        }\n\n        return symbols;\n    },\n\n    _symbolizeFeatures: function (features, sceneLayer, render) {\n        var symbols = [];\n        var feature,\n            symbol;\n        for (var i = 0; i < features.length; ++i) {\n            feature = features[i];\n            if (!this._canDraw(feature, sceneLayer)) {\n                continue;\n            }\n\n            symbol = render.getSymbol(feature, this.map.getZoom());\n            if (!symbol) {\n                // null\n                continue;\n            }\n            if (FM.Util.isArray(symbol)) {\n                Array.prototype.push.apply(symbols, symbol);\n            } else {\n                symbols.push(symbol);\n            }\n        }\n\n        return symbols;\n    },\n\n    _canDraw: function (feature, sceneLayer) {\n        var zoom = this.map.getZoom();\n        var filterObj = sceneLayer.options.unique;\n        var minEditZoom = sceneLayer.options.minEditZoom || sceneLayer.options.minZoom;\n        if (filterObj) {\n            if (zoom < filterObj.level) {\n                return true;\n            }\n        } else {\n            if (zoom < minEditZoom) {\n                // ,\n                return true;\n            }\n        }\n\n        var geoLiveType = feature.properties.geoLiveType;\n        var id = feature.properties.id;\n        var key = sceneLayer.id + ':' + geoLiveType + ':' + id;\n        if (this._drawItems.hasOwnProperty(key)) {\n            // \n            return false;\n        }\n\n        this._drawItems[key] = true;\n        return true;\n    },\n\n    addSceneLayer: function (sceneLayer) {\n        sceneLayer.setLeafletLayer(this);\n        this._sceneLayers.push(sceneLayer);\n    },\n\n    removeSceneLayer: function (sceneLayer) {\n        var index = this._sceneLayers.indexOf(sceneLayer);\n        if (index >= 0) {\n            this._sceneLayers.splice(index, 1);\n            sceneLayer.setLeafletLayer(null);\n        }\n    },\n\n    getSceneLayers: function () {\n        return this._sceneLayers;\n    },\n\n    available: function () {\n        return this._sceneLayers.length <= this._size;\n    }\n});\n\nFM.mapApi.vectorLayer = function (options) {\n    return new FM.mapApi.VectorLayer(options);\n};\n","/**\n * Created by zhongxiaoming on 2015/9/2.\n * Class 1:25000\n */\nfastmap.mapApi.MeshLayer = fastmap.mapApi.WholeLayer.extend({\n    /** *\n     * \n     * @param {Object}options\n     */\n    initialize: function (options) {\n        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);\n        this.minZoom = this.options.minZoom || 9;\n        this.maxZoom = this.options.maxZoom || 20;\n        this.latStep = 0.083333333333333;\n        // this.latStep = 0.08333;\n        this.lngStep = 0.125;\n    },\n    /** *\n     * \n     * @param{L.Map} map\n     */\n    onAdd: function (map) {\n        this.map = map;\n        this._initContainer(this.options);\n        map.on('moveend', this._redraw, this);\n        this._redraw();\n    },\n    /** *\n     * bounds\n     * @param {L.Bounds}bounds\n     */\n    draw: function (bounds) {\n        var pointDL = bounds.getSouthWest();\n        // \n        var pointUR = bounds.getNorthEast();\n        // var ret= this.CalculateMeshIds(pointDL.lng, pointUR.lng, pointDL.lat, pointUR.lat);\n        var minPoint = this.Calculate25TMeshCorner(pointDL);\n        var minLon = minPoint.lng;\n        var minLat = minPoint.lat;\n        this.gridArr = [];\n        var labelArr = [];\n        while (minLon <= pointUR.lng) {\n            var gridObj = this.createGrid(minLon, minLon + this.lngStep, minLat, pointUR.lat);\n            this.gridArr = this.gridArr.concat(gridObj);\n            minLon += this.lngStep;\n        }\n        for (var i = 0, len = this.gridArr.length; i < len; i++) {\n            var latlngbounds = this.gridArr[i].getBounds();\n            var bound = L.bounds(this.map.latLngToContainerPoint(latlngbounds.getNorthWest()), this.map.latLngToContainerPoint(latlngbounds.getSouthEast()));\n            var size = bound.getSize();\n            this.drawRect(this._ctx, this.gridArr[i].options.meshid, bound);\n        }\n    },\n    /** *\n     * \n     * @param {Object}context canvas context\n     * @param meshId id\n     * @param options \n     */\n    drawRect: function (context, meshId, options) {\n        var fontSize = this.map.getZoom();\n        if (fontSize >= 10) {\n            fontSize += 5;\n            context.font = fontSize + 'px Verdana';\n            context.fillText(meshId, options.min.x + (options.max.x - options.min.x) / 2 - fontSize * 2, options.min.y + (options.max.y - options.min.y) / 2 + fontSize / 3);\n        }\n        context.strokeStyle = '#00ff00'; // \n        context.linewidth = 3; // \n        context.strokeRect(options.min.x, options.min.y, options.getSize().x, options.getSize().y); //  x y  \n        context.stroke();\n    },\n    /** *\n     * \n     * @returns {fastmap.mapApi.MeshLayer}\n     * @private\n     */\n    _redraw: function () {\n        this._resetCanvasPosition();\n        this.clear();\n        if (this.map.getZoom() >= this.minZoom && this.map.getZoom() <= this.maxZoom) {\n            this.draw(this.map.getBounds());\n        }\n        return this;\n    },\n    /** *\n     * \n     * @param {number}minLon \n     * @param {number}maxLon \n     * @param {number}origin \n     * @param {number}destination \n     * @returns {Array}\n     */\n    createGrid: function (minLon, maxLon, origin, destination) {\n        // \n        var grids = [];\n        var minLat = origin;\n        var maxLat;\n        var meshId;\n        var bounds;\n        while (minLat <= destination) {\n            maxLat = minLat + this.latStep;\n            meshId = this.Calculate25TMeshId({\n                lng: (minLon + maxLon) / 2,\n                lat: (minLat + maxLat) / 2\n            });\n            // var bound = this.Calculate25TMeshBorder(meshId); // commented by chenx on 2016-11-22, \n            bounds = L.latLngBounds([this.checkAccuracy(minLat, 100000), this.checkAccuracy(minLon, 100000)], [this.checkAccuracy(maxLat, 100000), this.checkAccuracy(maxLon, 10000)]);\n            grids.push(L.rectangle(bounds, {\n                meshid: meshId\n            }));\n            minLat = maxLat;\n        }\n        return grids;\n    },\n\n    /**\n     * \n     * @param number\n     * @param accuracy\n     */\n    checkAccuracy: function (number, accuracy) {\n        return parseInt(number * accuracy + 0.5, 10) / accuracy;\n    },\n\n    /** *\n     * \n     */\n    clear: function () {\n        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);\n    },\n    /** *\n     * \n     * @private\n     */\n    _resetCanvasPosition: function () {\n        var bounds = this.map.getBounds();\n        var topLeft = this.map.latLngToLayerPoint(bounds.getNorthWest());\n        L.DomUtil.setPosition(this._div, topLeft);\n    },\n    /*\n     *  \n     *\n     *  @param{number}lat                       \n     *  @param{number}remainder                 \n     */\n    CalculateIdealRowIndex: function (lat, remainder) {\n        //  =  - 0.0\n        var regionLatitude = lat - 0.0;\n        // \n        var secondLatitude = regionLatitude * 3600;\n        var longsecond;\n        // *10(0.000010.036)\n        if (secondLatitude * 1000 < 0) {\n            longsecond = Math.ceil(secondLatitude * 1000);\n        } else {\n            longsecond = Math.floor(secondLatitude * 1000);\n        }\n        remainder = (longsecond % 300000);\n        return {\n            value: Math.floor(longsecond / 300000),\n            reminder: remainder\n        };\n    },\n    /*\n     *  \n     *\n     *  @param{number}lat                       \n     *  @param{number}remainder                 \n     */\n    CalculateRealRowIndex: function (lat, remainder) {\n        // \n        var idealRow = this.CalculateIdealRowIndex(lat, remainder);\n        switch (idealRow % 3) {\n            case 0: // \n                if (300000 - idealRow.remainder <= 12) {\n                    idealRow.value++;\n                }\n                break;\n            case 1: // \n                break;\n            case 2: // \n                if (idealRow.remainder < 12) {\n                    idealRow.value--;\n                }\n                break;\n            default:\n                break;\n        }\n        return idealRow;\n    },\n    /*\n     *  \n     *\n     *  @param{number}lon                \n     */\n    CalculateRealColumnIndex: function (lon, remainder) {\n        return this.CalculateIdealColumnIndex(lon, remainder);\n    },\n    /*\n     * \n     *\n     *  @param{number}lon                \n     *  @param{number}reminder            \n     */\n    CalculateIdealColumnIndex: function (lon, remainder) {\n        //  =  - 60.0\n        var regionLongitude = lon - 60.0;\n        // \n        var secondLongitude = regionLongitude * 3600;\n        // *10(0.000010.036)\n        var longsecond = Math.floor(secondLongitude * 1000);\n        remainder = Math.floor(longsecond % 450000);\n        return {\n            value: Math.floor(longsecond / 450000),\n            reminder: remainder\n        };\n    },\n    MeshLocator_25T: function (lon, lat) {\n        // \n        if ((this.IsAt25TMeshBorder(lon, lat) & 0x0F) == 0x01) {\n            lat += 0.00001;\n        }\n        var remainder = 0;\n        var rowResult = this.CalculateRealRowIndex(lat, remainder);\n        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);\n        // 12 : 1.5\n        var M1M2 = Math.floor(lat * 1.5);\n        // 34 :  60\n        var M3M4 = Math.floor(lon) - 60;\n        // 5 :\n        var M5 = rowResult.value % 8;\n        // 6 : 4508\n        var M6 = colResult.value % 8;\n        // ,\n        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;\n        while (sMeshId.length < 6) {\n            sMeshId = '0' + sMeshId;\n        }\n        return sMeshId;\n    },\n    /*\n     *  ,,\n     *\n     *  @param {L.Latlng}point   \n     */\n    Calculate25TMeshId: function (point) {\n        var mesh = this.MeshLocator_25T(point.lng, point.lat);\n        return mesh;\n    },\n    /*\n     *  \n     *\n     *  @param{L.Latlng}point          \n     */\n    Calculate25TMeshCorner: function (point) {\n        return this.Calculate25TMeshCornerByMeshId(this.Calculate25TMeshId(point));\n    },\n    /** *\n     * \n     * @param {String}mesh\n     * @returns {*}\n     * @constructor\n     */\n    Calculate25TMeshCornerByMeshId: function (mesh) {\n        var cc = mesh.split('');\n        var M1 = parseInt(cc[0], 0);\n        var M2 = parseInt(cc[1], 0);\n        var M3 = parseInt(cc[2], 0);\n        var M4 = parseInt(cc[3], 0);\n        var M5 = parseInt(cc[4], 0);\n        var M6 = parseInt(cc[5], 0);\n        var x = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;\n        var y = (M1 * 10 + M2) * 2400 + M5 * 300;\n        var point = L.latLng(y / 3600.0, x / 3600.0);\n        return point;\n    },\n    /** *\n     *  border\n     * @param {String}mesh\n     * @returns {{minLon:\n     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),\n     *   minLat:\n     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat),\n     *   maxLon:\n     *   (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng),\n     *   maxLat:\n     *   (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat)}}\n     * @constructor\n     */\n    Calculate25TMeshBorder: function (mesh) {\n        var cc = mesh.split('');\n        var M1 = parseInt(cc[0], 0);\n        var M2 = parseInt(cc[1], 0);\n        var M3 = parseInt(cc[2], 0);\n        var M4 = parseInt(cc[3], 0);\n        var M5 = parseInt(cc[4], 0);\n        var M6 = parseInt(cc[5], 0);\n        var xConner = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;\n        var yConner = (M1 * 10 + M2) * 2400 + M5 * 300;\n        var xUpper = xConner + 450.0;\n        var yUpper = yConner + 300.0;\n        var leftBottom = L.latLng(yConner / 3600.0, xConner / 3600.0);\n        var rightTop = L.latLng(yUpper / 3600.0, xUpper / 3600.0);\n        return {\n            minLon: leftBottom.lng,\n            minLat: leftBottom.lat,\n            maxLon: rightTop.lng,\n            maxLat: rightTop.lat\n        };\n    },\n    /*\n     *  \n     *\n     *  @param{number}lon               \n     *  @param{number}lat               \n     */\n    IsAt25TMeshBorder: function (lon, lat) {\n        var model = 0;\n        var remainder = 0;\n        var rowResult = this.CalculateIdealRowIndex(lat, remainder);\n        switch (rowResult.value % 3) {\n            case 0: // \n                if (300000 - rowResult.reminder == 12) {\n                    model |= 0x01;\n                } else if (rowResult.reminder == 0) model |= 0x01;\n                break;\n            case 1: // \n                break;\n            case 2: // \n                if (rowResult.reminder == 12) {\n                    model |= 0x01;\n                }\n                break;\n            default:\n                break;\n        }\n        var colResult = this.CalculateRealColumnIndex(lon, rowResult.reminder);\n        if (colResult.reminder == 0) model |= 0x10;\n        return model;\n    }\n});\nfastmap.mapApi.meshLayer = function (options) {\n    return new fastmap.mapApi.MeshLayer(options);\n};\n","/**\n * Created by zhongxiaoming on 2016/3/23.\n * Class fastmap.mapApi.LayerRender\n */\nfastmap.mapApi.LayerRender = {\n    /** *\n     * \n     * @param ctx {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param geom \n     * @param style \n     * @param boolPixelCrs \n     * @private\n     */\n    _drawPoint: function (options) {\n        var p = null;\n        if (options.boolPixelCrs) {\n            p = {\n                x: options.geom[0],\n                y: options.geom[1]\n            };\n        } else {\n            p = this._tilePoint(options.ctx, options.geom);\n        }\n        var c = options.ctx.canvas;\n        var g = c.getContext('2d');\n        g.beginPath();\n        if (options.fillColor) {\n            g.fillStyle = options.fillColor;\n        }\n        if (options.fillOpacity) {\n            g.fillOpacity = options.fillOpacity;\n        }\n        if (options.strokeColor) {\n            g.strokeColor = options.strokeColor;\n        }\n        if (options.strokeOpacity) {\n            g.strokeOpacity = options.strokeOpacity;\n        }\n        g.arc(p.x, p.y, options.radius, 0, Math.PI * 2);\n        g.closePath();\n        g.fill();\n        g.restore();\n    },\n    /** *\n     * \n     * @param ctx {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param geom \n     * @param style \n     * @param boolPixelCrs \n     * @private\n     */\n    _drawCircle: function (ctx, geom, style, boolPixelCrs) {\n        if (!style) {\n            return;\n        }\n        var p = null;\n        if (boolPixelCrs) {\n            p = {\n                x: geom[0],\n                y: geom[1]\n            };\n        } else {\n            p = this._tilePoint(ctx, geom);\n        }\n        var c = ctx.canvas;\n        var g = c.getContext('2d');\n        g.beginPath();\n        g.fillStyle = style.color;\n        g.arc(p.x, p.y, style.radius, 0, Math.PI * 2);\n        g.stroke(); // \n        g.closePath();\n    },\n    /** *\n     * @param options\n     * @param geo\n     * @param boolPixelCrs\n     * @param ctx \n     * @param rotate\n     * @param scaley \n     * @param drawx x\n     * @param drawy y\n     * @param fillStyle\n     * @private\n     */\n    _drawImg: function (options) {\n        var p = null;\n        var style = options.style;\n        if (options.boolPixelCrs) {\n            p = {\n                x: options.geo[0],\n                y: options.geo[1]\n            };\n        } else {\n            p = this._tilePoint(options.ctx, options.geom);\n        }\n        var c = options.ctx.canvas;\n        var g = c.getContext('2d');\n        var image = new Image();\n        var rotate = options.rotate;\n        image.src = style.src;\n        image.onload = function () {\n            var scalex = options.scalex ? options.scalex : 1;\n            var scaley = options.scaley ? options.scaley : 1;\n            var drawx = options.drawx ? options.drawx : -image.width * scalex / 2;\n            var drawy = options.drawy ? options.drawy : -image.height * scalex / 2;\n            // var drawx = -options.c * image.width/2;\n            // var drawy = 0\n            g.save();\n            g.translate(p.x, p.y);\n            if (options.fillStyle) {\n                g.strokeStyle = options.fillStyle.lineColor; // \n                g.fillStyle = options.fillStyle.fillColor;\n                g.linewidth = options.fillStyle.lineWidth; // \n                if (options.fillStyle.fillType == 'IXPOI') {\n                    g.beginPath();\n                    g.arc(0, 0, image.width * scalex / 2 + 2, 0, 2 * Math.PI);\n                    g.stroke();\n                } else {\n                    g.fillRect(drawx, drawy, image.width, image.height); //  x y  \n                    g.strokeRect(drawx, drawy, image.width, image.height); //  x y  \n                }\n            }\n            if (rotate) {\n                g.rotate(rotate); // \n            }\n            g.drawImage(image, drawx, drawy, image.width * scalex, image.height * scaley);\n            g.restore();\n        };\n    },\n    _drawBackground: function (options) {\n        var p = null;\n        if (options.boolPixelCrs) {\n            p = {\n                x: options.geo[0],\n                y: options.geo[1]\n            };\n        } else {\n            p = this._tilePoint(options.ctx, options.geom);\n        }\n        var c = options.ctx.canvas;\n        var g = c.getContext('2d');\n        var rotate = options.rotate;\n        var scalex = options.scalex ? options.scalex : 1;\n        var scaley = options.scaley ? options.scaley : 1;\n        var drawx = options.drawx;\n        var drawy = options.drawy;\n        g.save();\n        g.translate(p.x, p.y);\n        if (rotate) {\n            g.rotate(rotate); // \n        }\n        g.strokeStyle = options.lineColor; // \n        g.fillStyle = options.fillColor;\n        g.linewidth = options.lineWidth; // \n        g.fillRect(drawx, drawy, options.width, options.height); //  x y  \n        g.strokeRect(drawx, drawy, options.width, options.height); //  x y  \n        g.restore();\n    },\n    _drawLinkNameText: function (ctx, geom, name) {\n        var startLen = geom.concat().length;\n        geom = this._clip(ctx, geom);\n        var endLen = geom.length;\n        var c = ctx.canvas;\n        var g = c.getContext('2d');\n        g.font = '10px Courier New';\n        g.textAlign = 'center';\n        var angle;\n        var nameArr = name.split('');\n        var nameLen = name.length * 10;\n        var lineLen = 0;\n        if (geom.length === 2) {\n            angle = this._rotateAngle(geom[0], geom[1]);\n            lineLen = this.distance(geom[0], geom[1]);\n            if (nameLen < lineLen / 2 && lineLen > 160) {\n                this._showTextOfAngle(ctx, 0, name, angle, [(geom[0][0] + geom[1][0]) / 2, (geom[0][1] + geom[1][1]) / 2]);\n            }\n        } else {\n            var startPoint = geom[0];\n            var startPointForLen = geom[0];\n            var endPoint = geom[geom.length - 1];\n            var textLength = 0;\n            var startText = 0;\n            var textIndex = 0;\n            var betPointsLen;\n            var realLineLen = 0;\n            var linkArrLen = geom.length;\n            for (var m = 1; m < linkArrLen; m++) {\n                betPointsLen = this.distance(geom[m], startPointForLen);\n                realLineLen += betPointsLen;\n                startPointForLen = geom[m];\n            }\n            if (nameLen < realLineLen / 2 && realLineLen > 50) {\n                startPoint = geom[2];\n                for (var linkFLag = 1; linkFLag < linkArrLen; linkFLag++) {\n                    if (textLength < nameArr.length) {\n                        betPointsLen = this.distance(geom[linkFLag], startPoint);\n                        angle = this._rotateAngle(startPoint, geom[linkFLag]);\n                        if (betPointsLen > 10) {\n                            textIndex = parseInt(betPointsLen / 10, 10);\n                            this._showTextOfAngle(ctx, 0, name, angle, startPoint);\n                            break;\n                        } else {\n                            startPoint = geom[linkFLag];\n                        }\n                    }\n                }\n            }\n        }\n    },\n    _drawBridge: function (cav, geom, that) {\n        var c = cav.canvas;\n        var ctx = c.getContext('2d');\n        var oriStart,\n            oriEnd;\n        oriStart = geom[0][0];\n        for (var i = 1, len = geom.length; i < len; i++) {\n            oriEnd = geom[i][0];\n            var angle = that._rotateAngle(oriStart, oriEnd);\n            var points = [];\n            points = that._pointsFromAngle([oriStart, oriEnd], angle);\n            that._drawObliqueLine(ctx, points, angle);\n            oriStart = geom[i][0];\n        }\n    },\n    _drawObliqueLine: function (ctx, points, angle) {\n        var len = Math.floor(this.distance(points[0], points[1]) / 20);\n        ctx.lineWidth = 1;\n        ctx.strokeStyle = '#FF0000';\n        ctx.save();\n        ctx.translate(points[0][0], points[0][1]);\n        ctx.rotate(angle);\n        ctx.beginPath();\n        for (var i = 0; i < len; i++) {\n            ctx.moveTo(i * 20, 0);\n            ctx.lineTo(i * 20, -6);\n        }\n        // \n        ctx.moveTo(points[1][0] - points[0][0], 0);\n        ctx.lineTo(points[1][0] - points[0][0], -6);\n        ctx.stroke();\n        ctx.restore();\n    },\n    /**\n     * \n     * @param startPoint\n     * @param endPoint\n     * @returns {*}\n     * @private\n     */\n    _rotateAngle: function (startPoint, endPoint) {\n        var angle;\n        if ((startPoint[0] - endPoint[0]) === 0) {\n            angle = Math.PI / 2;\n        } else if ((startPoint[1] - endPoint[1]) === 0) {\n            angle = 0;\n        } else {\n            angle = Math.atan((startPoint[1] - endPoint[1]) / (startPoint[0] - endPoint[0]));\n        }\n        return angle;\n    },\n    _showTextOfAngle: function (ctx, start, name, angle, textGeom, font, align) {\n        var c = ctx.canvas;\n        var g = c.getContext('2d');\n        g.font = font || '10px Courier New';\n        g.textAlign = align || 'center';\n        var nameArr = name.split('');\n        var PI = Math.PI;\n        var end = nameArr.length;\n        if (angle === 0) {\n            g.fillText(name, textGeom[0], textGeom[1]);\n            g.save();\n        } else if ((angle < PI && angle > 2 * (PI / 5))) {\n            for (var i = start; i < end; i++) {\n                g.fillText(nameArr[i], textGeom[0], textGeom[1] + i * 13);\n                g.save();\n            }\n        } else {\n            var showName = name.substr(start, end);\n            g.save();\n            g.translate(textGeom[0], textGeom[1]);\n            g.rotate(angle);\n            g.fillText(showName, 0, 0);\n            g.restore();\n        }\n    },\n    // _drawConditionSpeedLimit: function (ctx, name, angle, textGeom, font, align) {\n    _drawText: function (options) {\n        var c = options.ctx.canvas;\n        var g = c.getContext('2d');\n        g.font = options.font ? options.font : '10px Courier New';\n        g.textAlign = options.textAlign ? options.textAlign : 'center';\n        g.save();\n        g.translate(options.geo[0], options.geo[1]);\n        if (options.rotate) {\n            g.rotate(options.rotate);\n        }\n        // g.fillText(options.text, 0, 12 / 2);\n        g.fillText(options.text, options.drawx, options.drawy);\n        g.restore();\n    },\n    /** *\n     * _drawArrow\n     * @param {Object}ctx\n     * @param {Number}direct \n     * @param {Array}data \n     * @private\n     */\n    _drawArrow: function (ctx, direct, data) {\n        var g = ctx.canvas.getContext('2d');\n        g.linewidth = 2;\n        g.strokeStyle = '#ff0000';\n        if (direct == 0 || direct == 1) {\n            return;\n        }\n        for (var i = 0, len = data.length; i < len; i++) {\n            for (var j = 0, len2 = data[i].length; j < len2 - 1; j += 2) {\n                g.beginPath();\n                g.translate(0, 0, 0);\n                var point1 = data[i][j];\n                var point2 = data[i][j + 1];\n                var distance = this.distance(point1, point2);\n                if (distance < 30) {\n                    return;\n                }\n                g.save();\n                var centerPoint = L.point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);\n                g.translate(centerPoint.x, centerPoint.y);\n                // y(0,-1)\n                var ang = 0;\n                if (point1.y - point2.y == 0) {\n                    if (point1.x - point2.x > 0) {\n                        ang = Math.PI / -2;\n                    } else {\n                        ang = Math.PI / 2;\n                    }\n                } else {\n                    ang = (point1.x - point2.x) / (point1.y - point2.y);\n                    ang = Math.atan(ang);\n                }\n                if (point2.y - point1.y >= 0) {\n                    if (direct == 2) {\n                        g.rotate(-ang);\n                    } else if (direct == 3) {\n                        g.rotate(-ang + Math.PI);\n                    }\n                } else if (direct == 2) {\n                    g.rotate(Math.PI - ang); // 180\n                } else if (direct == 3) {\n                    g.rotate(-ang);\n                }\n                g.lineTo(-3, -6);\n                g.lineTo(0, 1);\n                g.lineTo(3, -6);\n                g.lineTo(0, 0);\n                g.stroke();\n                g.fill(); // \n                g.closePath();\n                g.restore(); // \n            }\n        }\n    },\n    /**\n     * \n     * @param ctx\n     * @param points\n     * @param dashLength\n     * @param that\n     * @private\n     */\n    _drawDashLineOfAngle: function (ctx, points, dashLength, that) {\n        var endPoint;\n        var startPoint = points[0][0];\n        for (var i = 1, len = points.length; i < len; i++) {\n            endPoint = points[i][0];\n            var angle = that._rotateAngle(startPoint, endPoint);\n            that._drawDashLine(ctx, [startPoint, endPoint], angle, dashLength, that);\n            startPoint = points[i][0];\n        }\n    },\n    /**\n     * \n     * @param ctx\n     * @param points\n     * @param angle\n     * @param dashLength\n     * @param self\n     * @private\n     */\n    _drawDashLine: function (ctx, points, angle, dashLength, self) {\n        var pointsOfChange = self._pointsFromAngle(points, angle);\n        ctx.lineWidth = 2;\n        ctx.strokeStyle = 'red';\n        var xPos = points[1][0] - points[0][0];\n        var yPos = points[1][1] - points[0][1];\n        var dash = Math.floor(Math.sqrt(xPos * xPos + yPos * yPos) / dashLength);\n        ctx.save();\n        ctx.translate(pointsOfChange[0][0], pointsOfChange[0][1]);\n        ctx.rotate(angle);\n        ctx.beginPath();\n        for (var i = 0; i < dash; i++) {\n            if (i % 2) {\n                ctx.lineTo(dashLength * i, 0);\n            } else {\n                ctx.moveTo(dashLength * i, 0);\n            }\n        }\n        ctx.stroke();\n        ctx.restore();\n    },\n    /** *\n     * \n     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param {Array}geom \n     * @param {Object}style \n     * @param {Boolean}boolPixelCrs \n     * @private\n     */\n    _drawLineString: function (ctx, geom, boolPixelCrs, linestyle, nodestyle, properties) {\n        if (!linestyle) {\n            return;\n        }\n        var proj = [];\n        var coords = this._clip(ctx, geom);\n        for (var i = 0; i < coords.length; i++) {\n            // if (this._map.getZoom() >= this.showNodeLevel && (i == 0 || i == coords.length - 1)) {\n            //    this._drawPoint(ctx, coords[i], nodestyle, true);\n            // }\n            if (boolPixelCrs) {\n                proj.push({\n                    x: coords[i][0],\n                    y: coords[i][1]\n                });\n            } else {\n                proj.push(this._tilePoint(ctx, coords[i]));\n            }\n        }\n        var g = ctx.canvas.getContext('2d');\n        g.strokeStyle = linestyle.strokeColor;\n        g.lineWidth = linestyle.strokeWidth;\n        g.globalAlpha = linestyle.strokeOpacity || 1; // Opacity\n        g.lineCap = linestyle.lineCap || 'butt';\n        g.beginPath();\n        for (var j = 0; j < proj.length; j++) {\n            var method = (j === 0 ? 'move' : 'line') + 'To';\n            g[method](proj[j].x, proj[j].y);\n        }\n        g.stroke();\n        g.restore();\n        if (properties.hasOwnProperty('symbol')) {\n            // symbol\n            this._drawLineStringWithSymbol(ctx, geom, boolPixelCrs, properties.symbol);\n        }\n    },\n    /** *\n     * \n     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param {Array}geom \n     * @param {Boolean}boolPixelCrs \n     * @symbol {Array}style \n     * @private\n     */\n    _drawLineStringWithSymbol: function (ctx, geom, boolPixelCrs, symbol) {\n        if (!symbol) {\n            return;\n        }\n        var geometry = [];\n        // coords = this._clip(ctx, geom);\n        for (var i = 0; i < geom.length; i++) {\n            if (boolPixelCrs) {\n                geometry.push([geom[i][0], geom[i][1]]);\n            } else {\n                var point = this._tilePoint(ctx, geom[i]);\n                geometry.push([point.x, point.y]);\n            }\n        }\n        var lsGeometry = new fastmap.mapApi.symbol.LineString(geometry);\n        var g = ctx.canvas.getContext('2d');\n        symbol.geometry = lsGeometry;\n        symbol.draw(g);\n    },\n    /** *\n     * polygon\n     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param {Array}geom \n     * @param {Object}style \n     * @private\n     */\n    _drawPolygon: function (ctx, geom, style, boolPixelCrs) {\n        if (!style) {\n            return;\n        }\n        var coords = geom[0];\n        var proj = [];\n        var i;\n        coords = this._clip(ctx, coords);\n        for (i = 0; i < coords.length; i++) {\n            if (boolPixelCrs) {\n                proj.push({\n                    x: coords[i][0],\n                    y: coords[i][1]\n                });\n            } else {\n                proj.push(this._tilePoint(ctx, coords[i]));\n            }\n        }\n        var g = ctx.canvas.getContext('2d');\n        g.globalAlpha = style.fillOpacity;\n        g.fillStyle = style.fillColor;\n        if (style.strokeWidth > 0) {\n            g.strokeStyle = style.strokeColor;\n            g.lineWidth = style.strokeWidth;\n        }\n        g.beginPath();\n        for (i = 0; i < proj.length; i++) {\n            var method = (i === 0 ? 'move' : 'line') + 'To';\n            g[method](proj[i].x, proj[i].y);\n        }\n        g.closePath();\n        g.fill();\n        if (style.strokeWidth > 0) {\n            g.stroke();\n        }\n    },\n    /** rtic*/\n    _drawrdrtic: function (ctx, geom, properties, boolPixelCrs) {\n        var direct = null;\n        var stolecolor = null;\n        var reversecolor = null;\n        var coords = geom;\n        var proj = [];\n        var arrowlist = [];\n        coords = this._clip(ctx, coords);\n        for (var rtic = 0; rtic < coords.length; rtic++) {\n            if (boolPixelCrs) {\n                proj.push({\n                    x: coords[rtic][0][0],\n                    y: coords[rtic][0][1]\n                });\n            } else {\n                proj.push(this._tilePoint(ctx, coords[rtic]));\n            }\n        }\n        var g = ctx.canvas.getContext('2d');\n        for (var rticj = 0; rticj < proj.length; rticj++) {\n            var method = (rticj === 0 ? 'move' : 'line') + 'To';\n            g[method](proj[rticj].x, proj[rticj].y);\n            if (rticj < proj.length - 1) {\n                var oneArrow = [proj[rticj], proj[rticj + 1]];\n                arrowlist.push(oneArrow);\n            }\n        }\n        if (properties.forwardLevel == 0) {\n            stolecolor = '#808080'; // \n        } else if (properties.forwardLevel == 1) {\n            stolecolor = '#FF0000'; // \n        } else if (properties.forwardLevel == 2) {\n            stolecolor = '#006400'; // \n        } else if (properties.forwardLevel == 3) {\n            stolecolor = '#00008B'; // \n        } else if (properties.forwardLevel == 4) {\n            stolecolor = '#FF1493'; // \n        }\n        if (properties.reverseLevel == 0) {\n            reversecolor = '#808080'; // \n        } else if (properties.reverseLevel == 1) {\n            reversecolor = '#FF0000'; // \n        } else if (properties.reverseLevel == 2) {\n            reversecolor = '#006400'; // \n        } else if (properties.reverseLevel == 3) {\n            reversecolor = '#00008B'; // \n        } else if (properties.reverseLevel == 4) {\n            reversecolor = '#FF1493'; // \n        }\n        if (properties.forwardLevel && properties.reverseLevel) {\n            if (this._map.getZoom() >= this.showNodeLevel) {\n                this._drawIntRticArrow(g, 2, arrowlist, stolecolor);\n                this._drawIntRticArrow(g, 3, arrowlist, reversecolor);\n                this._drawIntRticText(ctx, geom, properties.forwardInformation + '', 2);\n                this._drawIntRticText(ctx, geom, properties.reverseInformation + '', 3);\n            }\n        } else {\n            if (properties.forwardLevel) {\n                direct = 2; // \n            } else if (properties.reverseLevel) {\n                direct = 3; // \n            }\n            if (direct && this._map.getZoom() >= this.showNodeLevel) {\n                this._drawIntRticArrow(g, direct, arrowlist, (direct == 2 ? stolecolor : reversecolor));\n                if (direct === 2) {\n                    this._drawIntRticText(ctx, geom, properties.forwardInformation + '', 2);\n                }\n                if (direct === 3) {\n                    this._drawIntRticText(ctx, geom, properties.reverseInformation + '', 3);\n                }\n            }\n        }\n    },\n    /** *\n     * _drawArrow\n     * @param {Object}ctx\n     * @param {Number}direct \n     * @param {Array}data \n     * * @param colors \n     * @private\n     */\n    _drawIntRticArrow: function (elem, direct, data, colors) {\n        var ctx = elem.canvas.getContext('2d');\n        ctx.linewidth = 2;\n        ctx.fillStyle = colors;\n        if (direct == 0 || direct == 1) {\n            return;\n        }\n        ctx.beginPath();\n        var point1,\n            point2;\n        if (direct === 2) {\n            point1 = data[data.length - 1][0];\n            point2 = data[data.length - 1][1];\n        } else if (direct === 3) {\n            point1 = data[0][0];\n            point2 = data[0][1];\n        }\n        var distance = this.distance(point1, point2);\n        if (distance < 30) {\n            return;\n        }\n        ctx.save();\n        // var centerPoint = L.point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);\n        var centerPoint;\n        if (direct == 2) {\n            centerPoint = L.point(point2.x, point2.y);\n        } else {\n            centerPoint = L.point(point1.x, point1.y);\n        }\n        ctx.translate(centerPoint.x, centerPoint.y);\n        // y(0,-1)\n        var ang = 0;\n        if (point1.y - point2.y == 0) {\n            if (point1.x - point2.x > 0) {\n                ang = Math.PI / -2;\n            } else {\n                ang = Math.PI / 2;\n            }\n        } else {\n            ang = (point1.x - point2.x) / (point1.y - point2.y);\n            ang = Math.atan(ang);\n        }\n        if (point2.y - point1.y >= 0) {\n            if (direct == 2) {\n                ctx.rotate(-ang);\n            } else if (direct == 3) {\n                ctx.rotate(-ang + Math.PI);\n            }\n        } else if (direct == 2) {\n            ctx.rotate(Math.PI - ang); // 180\n        } else if (direct == 3) {\n            ctx.rotate(-ang);\n        }\n        ctx.lineTo(-6, -9);\n        ctx.lineTo(0, 1);\n        ctx.lineTo(6, -9);\n        ctx.stroke();\n        ctx.fill(); // \n        ctx.closePath();\n        ctx.restore(); // \n    },\n    _drawIntRticText: function (ctx, geom, name, direct) {\n        geom = this._clip(ctx, geom);\n        var c = ctx.canvas;\n        var g = c.getContext('2d');\n        g.font = '10px Courier New';\n        g.textAlign = 'center';\n        var angle;\n        var nameArr = name.split('');\n        var nameLen = name.length * 10;\n        var lineLen = 0;\n        if (geom.length === 2) {\n            angle = this._rotateAngle(geom[0], geom[1]);\n            lineLen = this.distance(geom[0], geom[1]);\n            if (nameLen < lineLen / 2 && lineLen > 160) {\n                this._showIntRticTextOfAngle(g, 0, nameArr.length, name, angle, [(geom[0][0] + geom[1][0]) / 2, (geom[0][1] + geom[1][1]) / 2], direct);\n            }\n        } else {\n            var startPoint = geom[0];\n            var startPointForLen = geom[0];\n            var endPoint = geom[geom.length - 1];\n            var textLength = 0;\n            var startText = 0;\n            var textIndex = 0;\n            var betPointsLen;\n            var realLineLen = 0;\n            var linkArrLen = geom.length;\n            for (var m = 1; m < linkArrLen; m++) {\n                betPointsLen = this.distance(geom[m], startPointForLen);\n                realLineLen += betPointsLen;\n                startPointForLen = geom[m];\n            }\n            if (nameLen < realLineLen / 2 && realLineLen > 50) {\n                startPoint = geom[1];\n                for (var linkFLag = 1; linkFLag < linkArrLen; linkFLag++) {\n                    if (textLength < nameArr.length) {\n                        betPointsLen = this.distance(geom[linkFLag], startPoint);\n                        angle = this._rotateAngle(startPoint, geom[linkFLag]);\n                        if (betPointsLen > 10) {\n                            textIndex = parseInt(betPointsLen / 10, 10);\n                            this._showIntRticTextOfAngle(g, 0, nameArr.length, name, angle, startPoint, direct);\n                            break;\n                        } else {\n                            startPoint = geom[linkFLag];\n                        }\n                    }\n                }\n            }\n        }\n    },\n    _showIntRticTextOfAngle: function (ctx, start, end, name, angle, textGeom, direct) {\n        var nameArr = name.split('');\n        var PI = Math.PI;\n        if (angle === 0) {\n            if (direct === 2) {\n                ctx.fillText(name, textGeom[0], textGeom[1] - 10);\n            } else {\n                ctx.fillText(name, textGeom[0], textGeom[1] + 13);\n            }\n            ctx.save();\n        } else if ((angle < PI && angle > 2 * (PI / 5))) {\n            if (direct === 2) {\n                for (var l = start; l < end; l++) {\n                    ctx.fillText(nameArr[l], textGeom[0] - 8, textGeom[1] + l * 14);\n                    ctx.save();\n                }\n            } else {\n                for (var i = start; i < end; i++) {\n                    ctx.fillText(nameArr[i], textGeom[0] + 8, textGeom[1] + i * 14);\n                    ctx.save();\n                }\n            }\n        } else {\n            var showName = name.substr(start, end);\n            ctx.save();\n            if (direct === 2) {\n                ctx.translate(textGeom[0], textGeom[1] - 10);\n            } else {\n                ctx.translate(textGeom[0], textGeom[1] + 13);\n            }\n            ctx.rotate(angle);\n            ctx.fillText(showName, 0, 0);\n            ctx.restore();\n        }\n    },\n    /**\n     *\n     * @param ctx\n     * @param geom\n     * @param boolPixelCrs\n     * @param linestyle\n     * @param nodestyle\n     * @param properties\n     * @private\n     */\n    _drawAdLineString: function (ctx, geom, boolPixelCrs, linestyle, nodestyle, properties) {\n        if (!linestyle) {\n            return;\n        }\n        var coords = geom;\n        var proj = [];\n        var arrowlist = [];\n        coords = this._clip(ctx, coords);\n        for (var i = 0; i < coords.length; i++) {\n            if (this._map.getZoom() >= this.showNodeLevel && (i == 0 || i == coords.length - 1)) {\n                if (i == 0) {\n                    this._drawCircle(ctx, coords[i][0], nodestyle, true);\n                } else if (coords[0][0][0] != coords[coords.length - 1][0][0] && coords[0][0][1] != coords[coords.length - 1][0][1]) {\n                    this._drawCircle(ctx, coords[coords.length - 1][0], nodestyle, true);\n                }\n            }\n            if (boolPixelCrs) {\n                proj.push({\n                    x: coords[i][0][0],\n                    y: coords[i][0][1]\n                });\n            } else {\n                proj.push(this._tilePoint(ctx, coords[i]));\n            }\n        }\n        var g = ctx.canvas.getContext('2d');\n        g.strokeStyle = linestyle.color;\n        g.lineWidth = linestyle.size;\n        g.beginPath();\n        for (var j = 0; j < proj.length; j++) {\n            var method = (j === 0 ? 'move' : 'line') + 'To';\n            g[method](proj[j].x, proj[j].y);\n        }\n        g.stroke();\n        g.restore();\n    }\n};\n","/**\n * Created by zhongxiaoming on 2015/9/6.\n * Class canvas\n */\nfastmap.mapApi.TileJSON = L.TileLayer.Canvas.extend({\n    options: {\n        debug: true\n    },\n    includes: [L.Mixin.Events, fastmap.mapApi.LayerRender],\n    tileSize: 256,\n    /** *\n     *\n     * @param {Object}options\n     */\n    initialize: function (url, options) {\n        this.options = this.options || {};\n        L.Util.setOptions(this, options);\n        this.url = url;\n        this.style = this.options.style || '';\n        this.type = this.options.type || '';\n        this.editable = this.options.editable || '';\n        this.requestType = this.options.requestType || '';\n        this.gap = this.options.gap || 30;\n        this.tiles = {};\n        this.directColor = this.options.directColor || '#ff0000';\n        this.mecator = this.options.mecator || '';\n        this.clickFunction = this.options.clickFunction || null;\n        this.eventController = fastmap.uikit.EventController();\n        this.redrawTiles = [];\n        this.options.async = true;\n        this.drawTile = function (canvas, tilePoint, zoom) {\n            var ctx = {\n                canvas: canvas,\n                tile: tilePoint,\n                zoom: zoom\n            };\n            if (this.options.debug) {\n                this._drawDebugInfo(ctx);\n            }\n            this._draw(ctx, this.options.boolPixelCrs, this.options.parse);\n        };\n        // by chenx on 2016-9-23:\n        // this.on('loading', function() {\n        //     this._beginTime = new Date().getTime();\n        // });\n        // var that = this;\n        // this.on('load', function() {\n        //     var endTime = new Date().getTime();\n        //     var cnt = 0,\n        //         dataCnt = 0;\n        //     for (var key in that.tiles) {\n        //         if (that.tiles[key].data.length) {\n        //             dataCnt += that.tiles[key].data.length;\n        //         }\n        //         cnt++;\n        //     }\n        //     console.log('------Tilelayer load info:' + this._beginTime + '|' + endTime + '|' +\n        // cnt + '|' + dataCnt); });\n    },\n    redraw: function () {\n        if (this._map) {\n            this._reset({\n                hard: true\n            });\n            this._update();\n        }\n        return this;\n    },\n    _redrawTile: function (tile) {\n        this.drawTile(tile, tile._tilePoint, this._map._zoom);\n    },\n    /** *\n     * id\n     * @param {String}key\n     * @private\n     */\n    _removeTile: function (key) {\n        var tile = this._tiles[key];\n        this.fire('tileunload', {\n            tile: tile,\n            url: tile.src\n        });\n        if (this.options.reuseTiles) {\n            L.DomUtil.removeClass(tile, 'leaflet-tile-loaded');\n            this._unusedTiles.push(tile);\n        } else if (tile.parentNode === this._tileContainer) {\n            this._tileContainer.removeChild(tile);\n        }\n        // for https://github.com/CloudMade/Leaflet/issues/137\n        if (!L.Browser.android) {\n            tile.onload = null;\n            tile.src = L.Util.emptyImageUrl;\n        }\n        if (this.tiles[key] !== undefined) {\n            this.tiles[key].xmlhttprequest.abort();\n        }\n        delete this.tiles[key];\n        delete this._tiles[key];\n    },\n    /** *\n     * \n     * @param {Object}e\n     * @private\n     */\n    _reset: function (e) {\n        for (var key in this._tiles) {\n            if (!this._tiles.hasOwnProperty(key)) {\n                continue;\n            }\n            this.fire('tileunload', {\n                tile: this._tiles[key]\n            });\n            if (this.tiles[key] !== undefined) {\n                this.tiles[key].xmlhttprequest.abort();\n            }\n            delete this.tiles[key];\n        }\n        this._tiles = {};\n        this._tilesToLoad = 0;\n        if (this.options.reuseTiles) {\n            this._unusedTiles = [];\n        }\n        this._tileContainer.innerHTML = '';\n        if (this._animated && e && e.hard) {\n            this._clearBgBuffer();\n        }\n        this._initContainer();\n    },\n    /** *\n     * \n     * @param {Object}ctx\n     * @private\n     */\n    _drawDebugInfo: function (ctx) {\n        var max = this.tileSize;\n        var g = ctx.canvas.getContext('2d');\n        g.strokeStyle = '#000000';\n        g.fillStyle = '#FFFF00';\n        g.strokeRect(0, 0, max, max);\n        g.font = '12px Arial';\n        g.fillRect(0, 0, 5, 5);\n        g.fillRect(0, max - 5, 5, 5);\n        g.fillRect(max - 5, 0, 5, 5);\n        g.fillRect(max - 5, max - 5, 5, 5);\n        g.fillRect(max / 2 - 5, max / 2 - 5, 10, 10);\n        g.strokeText(ctx.tile.x + ' ' + ctx.tile.y + ' ' + ctx.zoom, max / 2 - 30, max / 2 - 10);\n    },\n    /** *\n     * tilepoint\n     * @param {Object}ctx  {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param {Array}coords \n     * @returns {{x: number, y: number}}\n     * @private\n     */\n    _tilePoint: function (ctx, coords) {\n        // start coords to tile 'space'\n        var s = ctx.tile.multiplyBy(this.tileSize);\n        // actual coords to tile 'space'\n        var p = this._map.project(new L.LatLng(coords[1], coords[0]));\n        // point to draw\n        var x = Math.round(p.x - s.x);\n        var y = Math.round(p.y - s.y);\n        return {\n            x: x,\n            y: y\n        };\n    },\n    /** *\n     *  \n     * @param coords\n     */\n    mousePointToTilepoint: function (coords) {\n        var p = this._map.project(new L.LatLng(coords[1], coords[0]));\n        return p.divideBy(this.tileSize, false);\n    },\n    /** *\n     *\n     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param {Array}points \n     * @returns {Array}\n     * @private\n     */\n    _clip: function (ctx, points) {\n        var nw = ctx.tile.multiplyBy(this.tileSize);\n        var se = nw.add(new L.Point(this.tileSize, this.tileSize));\n        var bounds = new L.Bounds([nw, se]);\n        var len = points.length;\n        var out = [];\n        for (var i = 0; i < len - 1; i++) {\n            var seg = L.LineUtil.clipSegment(points[i], points[i + 1], bounds, i);\n            if (!seg) {\n                continue;\n            }\n            out.push(seg[0]);\n            // if segment goes out of screen, or it's the last one, it's the end of the line part\n            if ((seg[1] !== points[i + 1]) || (i === len - 2)) {\n                out.push(seg[1]);\n            }\n        }\n        return out;\n    },\n    /** *\n     * \n     * @param {Array}coords\n     * @returns {boolean}\n     * @private\n     */\n    _isActuallyVisible: function (coords) {\n        var coord = coords[0];\n        var min = [coord.x, coord.y];\n        var max = [coord.x, coord.y];\n        for (var i = 1; i < coords.length; i++) {\n            coord = coords[i];\n            min[0] = Math.min(min[0], coord.x);\n            min[1] = Math.min(min[1], coord.y);\n            max[0] = Math.max(max[0], coord.x);\n            max[1] = Math.max(max[1], coord.y);\n        }\n        var diff0 = max[0] - min[0];\n        var diff1 = max[1] - min[1];\n        // if (this.options.debug) {\n        //    console.log(diff0 + ' ' + diff1);\n        // }\n        var visible = diff0 > 1 || diff1 > 1;\n        return visible;\n    },\n    /**\n     * geojsonparse\n     * @param {Object}ctx\n     * @param {Boolean}boolPixelCrs\n     * @param parse\n     * @private\n     */\n    _draw: function (ctx, boolPixelCrs, parse) {\n        //\n        this.options.zoomlevel = this._map;\n        var nwPoint = ctx.tile.multiplyBy(this.tileSize);\n        var sePoint = nwPoint.add(new L.Point(this.tileSize, this.tileSize));\n        // optionally, enlarge request area.\n        // with this I can draw points with coords outside this tile area,\n        // but with part of the graphics actually inside this tile.\n        // NOTE: that you should use this option only if you're actually drawing points!\n        var buf = this.options.buffer;\n        if (buf > 0) {\n            var diff = new L.Point(buf, buf);\n            nwPoint = nwPoint.subtract(diff);\n            sePoint = sePoint.add(diff);\n        }\n        var nwCoord = this._map.unproject(nwPoint, ctx.zoom, true);\n        var seCoord = this._map.unproject(sePoint, ctx.zoom, true);\n        var bounds = [nwCoord.lng, seCoord.lat, seCoord.lng, nwCoord.lat];\n        var url = this.createUrl(bounds);\n        if (!url) { // url\n            this.tileDrawn(ctx.canvas);\n            return;\n        }\n        this.key = ctx.tile.x + ':' + ctx.tile.y;\n        var zoom = this._map.getZoom();\n        var self = this;\n        this.tileobj = fastmap.mapApi.tile(url);\n        this.tileobj.options.context = ctx.canvas;\n        this.tiles[this.key] = this.tileobj;\n        var options = {\n            url: url,\n            responseType: 'json',\n            onSuccess: this._onAjaxSuccess,\n            parameter: {\n                self: self,\n                key: this.key,\n                zoom: zoom,\n                parse: parse,\n                ctx: ctx\n            }\n        };\n        this.request = fastmap.mapApi.ajax.get(options);\n        this.tiles[this.key].setRequest(this.request);\n    },\n    _onAjaxSuccess: function (json, parameter) {\n        var self = parameter.self;\n        var key = parameter.key;\n        var zoom = parameter.zoom;\n        var parse = parameter.parse;\n        var ctx = parameter.ctx;\n        var data = parse(json.data, key, zoom);\n        self.tiles[key].setData(data);\n        var urls = self._getDependencyResource(data);\n        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);\n        loader.load(function () {\n            self._drawFeature(data, ctx);\n            self.tileDrawn(ctx.canvas);\n        });\n    },\n    /** *\n     * \n     * @param data data\n     * @param {Object}ctx {canvas: canvas,tile: tilePoint,zoom: zoom}\n     * @param {Boolean}boolPixelCrs \n     * @private\n     */\n    _drawFeature: function (data, ctx, boolPixelCrs) {\n        for (var i = 0; i < data.length; i++) {\n            var feature = data[i];\n            var symbol = feature.properties.symbol;\n            if (!symbol) {\n                continue;\n            }\n\n            var g = ctx.canvas.getContext('2d');\n            if (FM.Util.isArray(symbol)) {\n                this._drawSymbolArray(g, symbol);\n            } else {\n                symbol.draw(g);\n            }\n        }\n        this.eventController.fire(this.eventController.eventTypes.TILEDRAWEND, {\n            layer: this,\n            id: ctx.tile.x + ':' + ctx.tile.y,\n            zoom: ctx.zoom\n        });\n    },\n    _drawSymbolArray: function (g, array) {\n        array.forEach(function (item) {\n            item.draw(g);\n        });\n    },\n    _getDependencyResource: function (data) {\n        var urls = [];\n        for (var i = 0; i < data.length; i++) {\n            var feature = data[i];\n            var symbol = feature.properties.symbol;\n            if (!symbol) {\n                continue;\n            }\n\n            if (FM.Util.isArray(symbol)) {\n                urls = urls.concat(this._getUrlsFromSymbolArray(symbol));\n            } else {\n                var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n                urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));\n            }\n        }\n\n        return urls;\n    },\n    _getUrlsFromSymbolArray: function (symbols) {\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        var urls = [];\n        for (var i = 0; i < symbols.length; i++) {\n            var symbol = symbols[i];\n            var symbolUrls = symbolFactory.getUrlsFromSymbol(symbol);\n            urls = urls.concat(symbolUrls);\n        }\n\n        return urls;\n    },\n    /** *\n     * boundsurl\n     * @param {Array}bounds bounds\n     * @returns url\n     */\n    createUrl: function (bounds) {\n        var tiles = this.mecator.lonlat2Tile((bounds[0] + bounds[2]) / 2, (bounds[1] + bounds[3]) / 2, this._map.getZoom());\n        var tempUrl = null;\n        if (this.options.subdomains && this.options.id != 'highlightLayer' && this.options.id != 'mousemovelightlayer') {\n            tempUrl = L.Util.template(this.url.url, { s: this._getSubdomain(L.point(tiles[0], tiles[1])) });\n        }\n        var parameter = null;\n        if (this.url != '') {\n            if (this._map.getZoom() >= this.options.minZoom && this._map.getZoom() <= this.options.maxZoom) {\n                parameter = this.url.parameter;\n                if (parameter != null) {\n                    parameter.z = this._map.getZoom();\n                    parameter.x = tiles[0];\n                    parameter.y = tiles[1];\n                }\n                tempUrl = tempUrl + 'parameter=' + JSON.stringify(parameter);\n            }\n        }\n        return tempUrl;\n    },\n    // \n    distance: function (pointA, pointB) {\n        var len;\n        if (pointA.x) {\n            len = Math.pow((pointA.x - pointB.x), 2) + Math.pow((pointA.y - pointB.y), 2);\n        } else {\n            len = Math.pow((pointA[0] - pointB[0]), 2) + Math.pow((pointA[1] - pointB[1]), 2);\n        }\n        return Math.sqrt(len);\n    }\n});\nfastmap.mapApi.TileJSON.addInitHook(function () {\n    this.isVisiable = this.options.visible;\n    this.isSelectable = this.options.selectable;\n});\nfastmap.mapApi.tileJSON = function (url, options) {\n    return new fastmap.mapApi.TileJSON(url, options);\n};\n","/**\n * Created by zhongxiaoming on 2015/10/19\n * Class EditLayer \n */\nfastmap.mapApi.EditLayer = fastmap.mapApi.WholeLayer.extend({\n    /**\n     * \n     * @property includes\n     */\n    includes: L.Mixin.Events,\n\n    /** *\n     * \n     * @param {Object}options\n     */\n    initialize: function (url, options) {\n        this.options = options || {};\n        this.url = url;\n        fastmap.mapApi.WholeLayer.prototype.initialize(this, options);\n        this.eventController = fastmap.uikit.EventController();\n        this.minShowZoom = this.options.minShowZoom || 9;\n        this.maxShowZoom = this.options.maxShowZoom || 18;\n        this.eventController = fastmap.uikit.EventController();\n        this.initEvent();\n        this.drawGeometry = null;\n    },\n\n    initEvent: function () {\n        var that = this;\n        this.shapeEditor = fastmap.uikit.ShapeEditorController();\n\n        this.eventController.on(this.eventController.eventTypes.SNAPED, function (event) {\n            that.snaped = event.snaped;\n        });\n        function delegateDraw(event) {\n            that.selectCtrl = fastmap.uikit.SelectController();\n            if (that.shapeEditor.shapeEditorResult == null) {\n                return;\n            }\n            that.drawGeometry = that.shapeEditor.shapeEditorResult.getFinalGeometry();\n            that.clear();\n            that.draw(that.drawGeometry, that, event.index);\n            if (that.snaped == true) {\n                var crosspoint = (event.index != null && that.drawGeometry && that.drawGeometry.components[event.index]) ? that.drawGeometry.components[event.index] : event.point;\n                if (crosspoint != undefined) {\n                    crosspoint = fastmap.mapApi.point(crosspoint.x, crosspoint.y);\n                    crosspoint.type = 'Cross';\n                    that.draw(crosspoint, that);\n                }\n            }\n        }\n        this.eventController.on(this.eventController.eventTypes.STARTSHAPEEDITRESULTFEEDBACK, delegateDraw);\n\n\n        this.eventController.on(this.eventController.eventTypes.STOPSHAPEEDITRESULTFEEDBACK, function () {\n            that.map._container.style.cursor = '';\n\n            var coordinate1 = [];\n            if (that.drawGeometry) {\n                if (that.drawGeometry.components) {\n                    var keys = Object.getOwnPropertyNames(that.drawGeometry.components);\n                    for (var j = 0; j < keys.length; j++) {\n                        var index = keys[j];\n                        coordinate1.push([that.drawGeometry.components[index].x, that.drawGeometry.components[index].y]);\n                    }\n                }\n                that._redraw();\n            }\n        });\n\n        this.eventController.on(this.eventController.eventTypes.ABORTSHAPEEDITRESULTFEEDBACK, function () {\n            that.drawGeometry = that.shapEditor.shapeEditorResult.getOriginalGeometry();\n            that.shapEditor.shapeEditorResult.setFinalGeometry(that.drawGeometry.clone());\n            that._redraw();\n        });\n    },\n    /** *\n     * \n     * @param{L.Map} map\n     */\n    onAdd: function (map) {\n        this.map = map;\n        this._initContainer(this.options);\n        map.on('moveend', this._redraw, this);\n        this._redraw();\n    },\n\n    /** *\n     * \n     * @param {L.Map}map\n     */\n    onRemove: function (map) {\n        map.getPanes().tilePane.removeChild(this._div);\n        map.off('moveend', this._redraw, this);\n    },\n\n    /** *\n     * \n     * @param currentGeo \n     * @param self\n     * @param index \n     */\n    draw: function (currentGeo, self, index) {\n        // this.clear();\n        if (!currentGeo) {\n            return;\n        }\n\n        function drawPoint(geom, style, boolPixelCrs) {\n            if (!geom) {\n                return;\n            }\n            var p = null;\n            if (boolPixelCrs) {\n                p = { x: geom.x, y: geom.y };\n            } else {\n                p = this.map.latLngToContainerPoint([geom.y, geom.x]);\n            }\n\n            var g = self._ctx;\n            g.beginPath();\n            g.fillStyle = style.color;\n            g.arc(p.x, p.y, style.radius, 0, Math.PI * 2);\n            g.closePath();\n            g.fill();\n            g.restore();\n        }\n\n        function drawArrow(ctx, direct, data, self1) {\n            var g = ctx.canvas.getContext('2d');\n            g.linewidth = 2;\n            g.strokeStyle = '#ff0000';\n            if (direct == 0 || direct == 1) {\n                return;\n            }\n\n            for (var i = 0, len = data.length; i < len; i++) {\n                for (var j = 0, len2 = data[i].length; j < len2 - 1; j += 2) {\n                    g.beginPath();\n                    g.translate(0, 0, 0);\n\n                    var point1 = data[i][j];\n                    var point2 = data[i][j + 1];\n                    var distance = self1.distance(point1, point2);\n                    if (distance < 20) {\n                        break;\n                    }\n\n                    g.save();\n                    var centerPoint = L.point((point1.x + point2.x) / 2, (point1.y + point2.y) / 2);\n\n                    g.translate(centerPoint.x, centerPoint.y);\n                    // y(0,-1)\n\n\n                    var ang = 0;\n                    if (point1.y - point2.y == 0) {\n                        if (point1.x - point2.x > 0) {\n                            ang = Math.PI / -2;\n                        } else {\n                            ang = Math.PI / 2;\n                        }\n                    } else {\n                        ang = (point1.x - point2.x) / (point1.y - point2.y);\n                        ang = Math.atan(ang);\n                    }\n                    if (point2.y - point1.y >= 0) {\n                        if (direct == 2) {\n                            g.rotate(-ang);\n                        } else if (direct == 3) {\n                            g.rotate(-ang + Math.PI);\n                        }\n                    } else if (direct == 2) {\n                        g.rotate(Math.PI - ang); // 180\n                    } else if (direct == 3) {\n                        g.rotate(-ang);\n                    }\n                    g.lineTo(-6, -12);\n                    g.lineTo(0, 2);\n                    g.lineTo(6, -12);\n                    g.lineTo(0, 0);\n                    g.stroke();\n                    g.fill(); // \n                    g.closePath();\n                    g.restore();   // \n                }\n            }\n        }\n\n        function drawLineString(geom, direct, style, boolPixelCrs, index1, boolnode, boolselectnode, self1) {\n            if (!geom) {\n                return;\n            }\n\n            var proj = [];\n            var i;\n\n            for (i = 0; i < geom.length; i++) {\n                if (boolPixelCrs) {\n                    proj.push({ x: geom[i].x, y: geom[i].y });\n                } else {\n                    proj.push(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]));\n\n                    if (boolselectnode && self1.selectCtrl) {\n                        if (self1.selectCtrl.selectedFeatures.latlng && self1.selectCtrl.selectedFeatures.latlng.lat == geom[i].y && self1.selectCtrl.selectedFeatures.latlng.lng == geom[i].x) {\n                            drawPoint(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]), {\n                                color: 'blue',\n                                radius: 4\n                            }, true);\n                        }\n                    } else if (i == 0 || i == geom.length - 1) {\n                        drawPoint(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]), {\n                            color: 'red',\n                            radius: 4\n                        }, true);\n                    } else if (!boolnode) {\n                        drawPoint(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]), {\n                            color: 'blue',\n                            radius: 4\n                        }, true);\n                    }\n                }\n            }\n\n            var g = self1._ctx;\n            g.strokeStyle = style.color;\n            g.lineWidth = style.size;\n            // g.opacity = 0.5;\n            g.beginPath();\n            for (i = 0; i < proj.length; i++) {\n                var method = (i === 0 ? 'move' : 'line') + 'To';\n                g[method](proj[i].x, proj[i].y);\n            }\n            g.stroke();\n            g.restore();\n            if (direct == 2 || direct == 3) {\n                var coords = proj;\n                var arrowList = [];\n                for (var k = 0; k < coords.length; k++) {\n                    if (k < coords.length - 1) {\n                        var oneArrow = [{ x: coords[k].x, y: coords[k].y }, {\n                            x: coords[k + 1].x,\n                            y: coords[k + 1].y\n                        }];\n                        arrowList.push(oneArrow);\n                    }\n                }\n                drawArrow(self1._ctx, direct, arrowList, self1);\n            }\n        }\n\n        function drawCross(geom, style, boolPixelCrs, self1) {\n            if (!geom) {\n                return;\n            }\n            var p = null;\n            if (boolPixelCrs) {\n                p = { x: geom.x, y: geom.y };\n            } else {\n                p = this.map.latLngToContainerPoint([geom.y, geom.x]);\n            }\n\n            var verLineArr = [{ x: p.x, y: p.y + 20 }, { x: p.x, y: p.y - 20 }];\n            drawLineString(verLineArr, null, { color: 'blue', size: 1 }, true, null, null, null, self1);\n            var horLineArr = [{ x: p.x - 20, y: p.y }, { x: p.x + 20, y: p.y }];\n            drawLineString(horLineArr, null, { color: 'blue', size: 1 }, true, null, null, null, self1);\n        }\n        function drawGSC(geom, style, boolPixelCrs, self1) {\n            if (!geom) {\n                return;\n            }\n            geom.conPoints = [];\n            for (var i = 0; i < geom.length; i++) {\n                var p = null;\n                var q = null;\n                if (boolPixelCrs) {\n                    p = { x: geom[i][0].x, y: geom[i][0].y };\n                    q = { x: geom[i][geom[i].length - 1].x, y: geom[i][geom[i].length - 1].y };\n                } else {\n                    p = this.map.latLngToContainerPoint([geom[i][0].y, geom[i][0].x]);\n                    q = this.map.latLngToContainerPoint([geom[i][geom[i].length - 1].y, geom[i][geom[i].length - 1].x]);\n                }\n                geom.conPoints.push([{ x: p.x, y: p.y }, { x: q.x, y: q.y }]);\n                var verLineArr = [{ x: p.x, y: p.y }, { x: q.x, y: q.y }];\n                drawLineString(verLineArr, null, { color: style[i], size: 4 }, true, null, null, null, self1);\n            }\n        }\n\n        function drawBuffer(geom, width, self1) {\n            var proj = [];\n            var method;\n            this.transform = new fastmap.mapApi.MecatorTranform();\n            var scale = this.transform.scale(map);\n            var linkWidth = parseFloat(width * scale);\n            linkWidth = linkWidth.toFixed(2);\n            for (var i = 0; i < geom.length; i++) {\n                proj.push(this.map.latLngToContainerPoint([geom[i].y, geom[i].x]));\n            }\n            var ctx = self1._ctx;\n            ctx.lineWidth = width * 2;\n            ctx.save();\n            ctx.beginPath();\n            ctx.lineCap = 'round';\n            for (i = 0; i < proj.length; i++) {\n                method = (i === 0 ? 'move' : 'line') + 'To';\n                ctx[method](proj[i].x, proj[i].y);\n            }\n            ctx.stroke();\n            for (i = 0; i < proj.length; i++) {\n                method = (i === 0 ? 'move' : 'line') + 'To';\n                ctx[method](proj[i].x, proj[i].y);\n            }\n            ctx.lineWidth = (width - 1) * 2;\n            ctx.strokeStyle = 'white';\n            ctx.stroke();\n            ctx.clip();\n            ctx.restore();\n            for (i = 0; i < proj.length; i++) {\n                method = (i === 0 ? 'move' : 'line') + 'To';\n                ctx[method](proj[i].x, proj[i].y);\n            }\n            ctx.lineWidth = 1;\n            ctx.stroke();\n            ctx.fillText(linkWidth + 'm', proj[0].x, proj[0].y);\n        }\n\n        // // ;\n        function lineEquation(pt1, pt2) {\n            if (pt1.x != pt2.x) {\n                var a = (pt2.y - pt1.y) / (pt2.x - pt1.x);\n                return {\n                    a: a,\n                    b: pt1.y - a * pt1.x\n                };\n            }\n            if (pt1.y != pt2.y) {\n                return { x: pt1.x };\n            }\n            return null;\n        }\n\n        function intersection(l1a, l1b, l2a, l2b) {\n            var line1 = lineEquation(l1a, l1b);\n            var line2 = lineEquation(l2a, l2b);\n\n            if (line1 == null || line2 == null) {\n                return null;\n            }\n\n            if (line1.hasOwnProperty('x')) {\n                if (line2.hasOwnProperty('x')) {\n                    return null;\n                }\n                return L.point(line1.x, line2.a * line1.x + line2.b);\n            }\n            if (line2.hasOwnProperty('x')) {\n                return L.point(line2.x, line1.a * line2.x + line1.b);\n            }\n\n            if (line1.a == line2.a) {\n                return null;\n            }\n\n            var x = (line2.b - line1.b) / (line1.a - line2.a);\n            var y = line1.a * x + line1.b;\n\n            return L.point(x, y);\n        }\n\n        function joinSegments(s1, s2, offset, joinStyle) {\n            var jointPoints = [];\n            jointPoints = [intersection(s1.offset[0], s1.offset[1], s2.offset[0], s2.offset[1])];\n            return jointPoints.filter(function (v) {\n                return v;\n            });\n        }\n\n        function joinLineSegments(segments, offset, joinStyle) {\n            var l = segments.length;\n            var joinedPoints = [];\n            var s1 = segments[0];\n            var s2 = segments[0];\n            joinedPoints.push(s1.offset[0]);\n\n            for (var i = 1; i < l; i++) {\n                s2 = segments[i];\n                joinedPoints = joinedPoints.concat(joinSegments(s1, s2, offset, joinStyle));\n                s1 = s2;\n            }\n            joinedPoints.push(s2.offset[1]);\n\n            return joinedPoints;\n        }\n\n        function translatePoint(pt, dist, radians) {\n            return L.point(pt.x + dist * Math.cos(radians), pt.y + dist * Math.sin(radians));\n        }\n\n        function offsetPointLine(points, distance) {\n            var l = points.length;\n            if (l < 2) {\n                throw new Error('Line should be defined by at least 2 points');\n            }\n            var a = points[0];\n            var offsetSegments = [];\n            var offsetAngle,\n                segmentAngle,\n                b;\n            for (var i = 1; i < l; i++) {\n                b = points[i];\n                // angle in (-PI, PI]\n                segmentAngle = Math.atan2(a.y - b.y, a.x - b.x);\n                // angle in (-1.5 * PI, PI/2]\n                offsetAngle = segmentAngle - Math.PI / 2;\n                // store offset point and other information to avoid recomputing it later\n                offsetSegments.push({\n                    angle: segmentAngle,\n                    offsetAngle: offsetAngle,\n                    distance: distance,\n                    original: [a, b],\n                    offset: [\n                        translatePoint(a, distance, offsetAngle),\n                        translatePoint(b, distance, offsetAngle)\n                    ]\n                });\n                a = b;\n            }\n            return offsetSegments;\n        }\n\n        function drawSideBuffer(geom, width, showSide, self1) {\n            var proOriginArr = [];\n            var proLeftProArr = [];\n            var proRightProArr = [];\n            var proMiddleArr = [];\n            this.transform = new fastmap.mapApi.MecatorTranform();\n            var scale = this.transform.scale(map);\n            var linkWidth = parseFloat(width * scale);\n            linkWidth = linkWidth.toFixed(2);\n            geom = Utils.distinctArr(geom);\n            for (var i = 0; i < geom.length; i++) {\n                geom[i] = geom[i].split(',');\n                proOriginArr.push(this.map.latLngToContainerPoint([geom[i][1], geom[i][0]]));\n            }\n            proMiddleArr = joinLineSegments(offsetPointLine(proOriginArr, 0), 0);\n            proRightProArr = joinLineSegments(offsetPointLine(proOriginArr, parseFloat(width)), parseFloat(width));\n            proLeftProArr = joinLineSegments(offsetPointLine(proOriginArr, -parseFloat(width)), -parseFloat(width));\n            var ctx = self1._ctx;\n            ctx.strokeStyle = 'blue';\n            ctx.save();\n            ctx.beginPath();\n            for (i = 0; i < proMiddleArr.length; i++) {\n                var method1 = (i === 0 ? 'move' : 'line') + 'To';\n                ctx[method1](proMiddleArr[i].x, proMiddleArr[i].y);\n            }\n            ctx.stroke();\n            if (showSide == 3 || showSide == 1) {\n                for (i = 0; i < proLeftProArr.length; i++) {\n                    var method2 = (i === 0 ? 'move' : 'line') + 'To';\n                    ctx[method2](proLeftProArr[i].x, proLeftProArr[i].y);\n                }\n                ctx.stroke();\n            }\n            if (showSide == 2 || showSide == 1) {\n                for (i = 0; i < proRightProArr.length; i++) {\n                    var method3 = (i === 0 ? 'move' : 'line') + 'To';\n                    ctx[method3](proRightProArr[i].x, proRightProArr[i].y);\n                }\n                ctx.stroke();\n            }\n            ctx.fillText(linkWidth + 'm', proOriginArr[0].x, proOriginArr[0].y);\n        }\n\n        function drawDirectionLine(x1, y1, x2, y2, ctx) {\n            var angle = Math.abs(Math.atan((x2 - x1) / (y2 - y1))); // \n            var length = 10; // \n            var degree = Math.PI / 6; // \n            var theta = 0;\n            var altha = 0;\n            var a1 = 0;\n            var b1 = 0;\n            var a2 = 0;\n            var b2 = 0;\n\n            if (angle >= degree && angle <= Math.PI / 2 - degree) {\n                theta = angle - degree;\n                altha = Math.PI / 2 - 2 * degree - theta;\n                if (x2 >= x1) {\n                    a1 = x2 - length * Math.sin(theta);\n                    a2 = x2 - length * Math.cos(altha);\n                } else {\n                    a1 = x2 + length * Math.sin(theta);\n                    a2 = x2 + length * Math.cos(altha);\n                }\n                if (y2 >= y1) {\n                    b1 = y2 - length * Math.cos(theta);\n                    b2 = y2 - length * Math.sin(altha);\n                } else {\n                    b1 = y2 + length * Math.cos(theta);\n                    b2 = y2 + length * Math.sin(altha);\n                }\n            } else {\n                theta = angle - degree;\n                altha = theta + 2 * degree - Math.PI / 2;\n                if (x2 >= x1 && y2 >= y1) {\n                    a1 = x2 - length * Math.sin(theta);\n                    b1 = y2 - length * Math.cos(theta);\n                    a2 = x2 - length * Math.cos(altha);\n                    b2 = y2 + length * Math.sin(altha);\n                } else if (x2 >= x1 && y2 < y1) {\n                    a1 = x2 - length * Math.sin(theta);\n                    b1 = y2 + length * Math.cos(theta);\n                    a2 = x2 - length * Math.cos(altha);\n                    b2 = y2 - length * Math.sin(altha);\n                } else if (x2 < x1 && y2 < y1) {\n                    a1 = x2 + length * Math.sin(theta);\n                    b1 = y2 + length * Math.cos(theta);\n                    a2 = x2 + length * Math.cos(altha);\n                    b2 = y2 - length * Math.sin(altha);\n                } else {\n                    a1 = x2 + length * Math.sin(theta);\n                    b1 = y2 - length * Math.cos(theta);\n                    a2 = x2 + length * Math.cos(altha);\n                    b2 = y2 + length * Math.sin(altha);\n                }\n            }\n\n            ctx.beginPath();\n            ctx.moveTo(x1, y1);\n            ctx.lineTo(x2, y2);\n            ctx.lineTo(a1, b1);\n            ctx.stroke();\n            ctx.moveTo(x2, y2);\n            ctx.lineTo(a2, b2);\n            ctx.stroke();\n        }\n        // geo\n        function getMiddleGeo(geom, geoms) {\n            // \n            if (geom.coordinates.length % 2 == 0) {\n                geoms.push(geom.coordinates[geom.coordinates.length / 2 - 1]);\n                geoms.push(geom.coordinates[geom.coordinates.length / 2]);\n            } else { // \n                geoms.push(geom.coordinates[Math.floor(geom.coordinates.length / 2)]);\n                geoms.push(geom.coordinates[Math.floor(geom.coordinates.length / 2) + 1]);\n            }\n            return geoms;\n        }\n        // link\n        function drawLinkArrowGuide(geom, links, width, showSide, self1) {\n            var proOriginArr = [];\n            var proLeftProArr = [];\n            var proRightProArr = [];\n            var proMiddleArr = [];\n            var geoms = [];\n            this.transform = new fastmap.mapApi.MecatorTranform();\n            var scale = this.transform.scale(map);\n            var linkWidth = parseFloat(width * scale);\n            linkWidth = linkWidth.toFixed(2);\n\n            geoms = Utils.distinctArr(geom);\n\n            for (var i = 0; i < geoms.length; i++) {\n                geoms[i] = geoms[i].split(',');\n                proOriginArr.push(this.map.latLngToContainerPoint([geoms[i][1], geoms[i][0]]));\n            }\n            // proOriginArr.push(this.map.latLngToContainerPoint([geoms[1], geoms[0]]));\n            proRightProArr = joinLineSegments(offsetPointLine(proOriginArr, parseFloat(width)), parseFloat(width));\n            proLeftProArr = joinLineSegments(offsetPointLine(proOriginArr, -parseFloat(width)), -parseFloat(width));\n            var ctx = self1._ctx;\n            ctx.strokeStyle = 'red';\n            ctx.save();\n            ctx.beginPath();\n            if (showSide == 0) {\n                proLeftProArr = proLeftProArr.reverse();\n                for (i = 0; i < proLeftProArr.length; i++) {\n                    if (i != proLeftProArr.length - 1) {\n                        drawDirectionLine(proLeftProArr[i].x, proLeftProArr[i].y, proLeftProArr[i + 1].x, proLeftProArr[i + 1].y, ctx);\n                    }\n                }\n            }\n            if (showSide == 1) {\n                for (i = 0; i < proRightProArr.length; i++) {\n                    if (i != proRightProArr.length - 1) {\n                        drawDirectionLine(proRightProArr[i].x, proRightProArr[i].y, proRightProArr[i + 1].x, proRightProArr[i + 1].y, ctx);\n                    }\n                }\n            }\n            ctx.fillText('', proOriginArr[0].x, proOriginArr[0].y);\n        }\n        // link\n        function drawLinkArrow(geoms, width, showSide, self1) {\n            this.transform = new fastmap.mapApi.MecatorTranform();\n            var scale = this.transform.scale(map);\n            for (var i = 0; i < geoms.length; i++) {\n                var proOriginArr = [];\n                var proLeftProArr = [];\n                var proRightProArr = [];\n                proOriginArr.push(this.map.latLngToContainerPoint([geoms[i][0][1], geoms[i][0][0]]));\n                proOriginArr.push(this.map.latLngToContainerPoint([geoms[i][1][1], geoms[i][1][0]]));\n                proRightProArr = joinLineSegments(offsetPointLine(proOriginArr, parseFloat(width)), parseFloat(width));\n                proLeftProArr = joinLineSegments(offsetPointLine(proOriginArr, -parseFloat(width)), -parseFloat(width));\n                var ctx = self1._ctx;\n                ctx.strokeStyle = 'red';\n                ctx.save();\n                ctx.beginPath();\n                if (showSide == 0) {\n                    proLeftProArr = proLeftProArr.reverse();\n                    drawDirectionLine(proLeftProArr[0].x, proLeftProArr[0].y, proLeftProArr[1].x, proLeftProArr[1].y, ctx);\n                }\n                if (showSide == 1) {\n                    drawDirectionLine(proRightProArr[0].x, proRightProArr[0].y, proRightProArr[1].x, proRightProArr[1].y, ctx);\n                }\n            }\n        }\n\n        function drawSymbol(geom, style, boolPixelCrs) {\n            if (!geom) {\n                return;\n            }\n            var p = null;\n            if (boolPixelCrs) {\n                p = { x: geom.x, y: geom.y };\n            } else {\n                p = this.map.latLngToContainerPoint([geom.y, geom.x]);\n            }\n\n            var g = self._ctx;\n            g.beginPath();\n            g.fillStyle = style.color;\n            g.arc(p.x, p.y, style.radius, 0, Math.PI * 2);\n            g.closePath();\n            g.fill();\n            g.restore();\n        }\n\n        function drawMultiPolyline(geom, style, self1) {\n            for (var i = 0, len = geom.length; i < len; i++) {\n                drawLineString(geom[i].components, 1, style, false, null, true, true, self1);\n            }\n        }\n\n        function drawPolygon(geom, style) {\n            if (!style) {\n                return;\n            }\n\n            var coords = geom.components;\n            var proj = [];\n            var i;\n\n            for (i = 0; i < coords.length; i++) {\n                proj.push(this.map.latLngToContainerPoint([coords[i].y, coords[i].x]));\n            }\n\n            var g = self._ctx;\n            var outline = style.outline;\n            g.fillStyle = style.color;\n            if (outline) {\n                g.strokeStyle = outline.color;\n                g.lineWidth = outline.size;\n            }\n            g.beginPath();\n            for (i = 0; i < proj.length; i++) {\n                var method = (i === 0 ? 'move' : 'line') + 'To';\n                g[method](proj[i].x, proj[i].y);\n            }\n            g.closePath();\n            g.fill();\n            if (outline) {\n                g.stroke();\n            }\n        }\n\n        function loadImg(url, callBack) {\n            var img = new Image();\n            img.onload = function () {\n                callBack(img);\n            };\n            img.src = url;\n        }\n\n        function directOfPoint(point, length, width, angle) {\n            point.x += length;\n            point.y += width / 2;\n            point.x += Math.tan(angle);\n            point.y += Math.tan(angle);\n            // point=this.map.containerPointToLatLng(point);\n            return point;\n        }\n\n        function drawMarker(geom, type, angle, boolPixelCrs, self1) {\n            var url;\n            var p = null;\n            var angleOfTran = angle;\n            var that = this;\n            if (!geom) {\n                return;\n            }\n\n            if (boolPixelCrs) {\n                p = { x: geom.x, y: geom.y };\n            } else {\n                p = this.map.latLngToContainerPoint([geom.y, geom.x]);\n            }\n            // if(type===\"3\") {\n            //    angleOfTran = angleOfTran + Math.PI;\n            // }\n            url = '../../images/road/img/' + type + '.svg';\n            var g = self1._ctx;\n            loadImg(url, function (img) {\n                g.save();\n                g.translate(p.x, p.y);\n                g.rotate(angleOfTran);\n                g.drawImage(img, 0, 0);\n                g.restore();\n                currentGeo.pointForDirect = directOfPoint(p, 61, 32, angle);\n                self1.eventController.fire(self1.eventController.eventTypes.DIRECTEVENT, { geometry: currentGeo });\n            });\n        }\n\n        function drawRticMarker(geom, type, angle, boolPixelCrs, self1) {\n            var url;\n            var p = null;\n            var angleOfTran = angle;\n            var that = this;\n            if (!geom) {\n                return;\n            }\n\n            if (boolPixelCrs) {\n                p = { x: geom.x, y: geom.y };\n            } else {\n                p = this.map.latLngToContainerPoint([geom.y, geom.x]);\n            }\n            if (type === '1') {\n                angleOfTran += Math.PI;\n            }\n            url = '../../images/road/intRtic/' + type + '.svg';\n            var g = self1._ctx;\n            loadImg(url, function (img) {\n                g.save();\n                g.translate(p.x, p.y);\n                g.rotate(angleOfTran);\n                g.drawImage(img, 0, 0);\n                g.restore();\n                currentGeo.pointForDirect = directOfPoint(p, 61, 32, angle);\n                self1.eventController.fire(self1.eventController.eventTypes.DIRECTEVENT, { geometry: currentGeo });\n            });\n        }\n\n        function drawPoi(geom, style, boolPixelCrs) {\n            if (!geom) {\n                return;\n            }\n            var p = null;\n            if (boolPixelCrs) {\n                p = { x: geom.x, y: geom.y };\n            } else {\n                p = this.map.latLngToContainerPoint([geom.y, geom.x]);\n            }\n            var g = self._ctx;\n            var image = new Image();\n            image.src = style.src;\n            image.onload = function () {\n                var scalex = style.scalex ? style.scalex : 1;\n                var scaley = style.scaley ? style.scaley : 1;\n                var drawx = style.drawx ? style.drawx : -image.width * scalex / 2;\n                var drawy = style.drawy ? style.drawy : -image.height * scalex / 2;\n                g.save();\n                g.translate(p.x, p.y);\n                g.drawImage(image, drawx, drawy, image.width * scalex, image.height * scaley);\n                g.restore();\n            };\n        }\n        function drawSymbolLineString(ctx, geom, boolPixelCrs, symbol) {\n            var that = this;\n            if (!symbol) {\n                return;\n            }\n            var geometry = [];\n            for (var i = 0; i < geom.length; i++) {\n                if (boolPixelCrs) {\n                    geometry.push([geom[i][0], geom[i][1]]);\n                } else {\n                    var point = this._tilePoint(ctx, geom[i]);\n                    geometry.push([point.x, point.y]);\n                }\n            }\n\n            var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n            var a = gf.createLineString(geometry);\n            var g = ctx.canvas.getContext('2d');\n            symbol.geometry = a;\n            symbol.draw(g);\n        }\n\n        function drawPoiAndLink(geom, style, self1) {\n            if (!geom) {\n                return;\n            }\n            this.transform = new fastmap.mapApi.MecatorTranform();\n            var proj = [];\n            for (var i = 0; i < geom.length; i++) {\n                var point = this.map.latLngToContainerPoint([geom[i].y, geom[i].x]);\n                proj.push([point.x, point.y]);\n                if (i == 0) {\n                    drawPoi(point, {\n                        src: '../../images/poi/map/marker_blue_32.png',\n                        drawy: -32\n                    }, true);\n                } else if (i == 1) {\n                    drawPoi(point, {\n                        src: '../../images/poi/map/marker_circle_blue_16.png'\n                    }, true);\n                }\n            }\n            var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n            var symbol = symbolFactory.createSymbol({\n                type: 'SimpleLineSymbol',\n                style: 'dash',\n                color: 'blue'\n            });\n            drawSymbolLineString(self1._ctx, proj, true, symbol);\n        }\n\n        function drawAdminPointAndLink(geom, style, self1) {\n            if (!geom) {\n                return;\n            }\n            this.transform = new fastmap.mapApi.MecatorTranform();\n            var proj = [];\n            var flag = geom[0].y > geom[1].y;\n            for (var i = 0; i < geom.length; i++) {\n                var point = this.map.latLngToContainerPoint([geom[i].y, geom[i].x]);\n                proj.push([point.x, point.y]);\n                if (i == 0) {\n                    drawPoi(point, {\n                        src: '../../images/road/img/star.png',\n                        drawy: flag ? -8 : 0,\n                        drawX: flag ? -8 : 0\n                    }, true);\n                } else if (i == 1) {\n                    drawPoi(point, {\n                        src: '../../images/poi/map/marker_circle_blue_16.png'\n                    }, true);\n                }\n            }\n            var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n            var symbol = symbolFactory.createSymbol({\n                type: 'SimpleLineSymbol',\n                style: 'dash',\n                color: 'blue'\n            });\n            drawSymbolLineString(self1._ctx, proj, true, symbol);\n        }\n\n        switch (currentGeo.type) {\n            case 'LineString':\n                if (currentGeo.noFormNode) {\n                    drawLineString(currentGeo.components, null, {\n                        color: 'red',\n                        size: 2\n                    }, false, null, true, false, self);\n                } else {\n                    drawLineString(currentGeo.components, null, {\n                        color: 'red',\n                        size: 2\n                    }, false, null, false, false, self);\n                }\n                break;\n            case 'Link':\n                self.clear();\n                drawLineString(currentGeo.geometry.components, currentGeo.direct, {\n                    color: 'red',\n                    size: 2\n                }, false, null, false, true, self);\n                break;\n            case 'Point':\n                drawPoint(currentGeo, { color: 'red', radius: 3 }, false);\n                break;\n            case 'Symbol':\n                drawSymbol(currentGeo, { color: 'red', radius: 3 }, false);\n                break;\n            case 'SpeedLimit':\n                drawPoint(currentGeo.components[0], { color: 'red', radius: 3 }, false);\n                break;\n            case 'Polygon':\n                drawPolygon(currentGeo, { color: 'red', outline: 3 }, false);\n                break;\n            case 'Cross':\n                drawCross(currentGeo, { color: 'blue', width: 1 }, false, self);\n                break;\n            case 'GSC':\n                drawGSC(currentGeo.geos, currentGeo.style, false, self);\n                break;\n            case 'marker':\n                drawMarker(currentGeo.point, currentGeo.orientation, currentGeo.angle, false, self);\n                break;\n            case 'MultiPolyline':\n                // MultiPolyline\n                if (currentGeo.activeCoordinates.length) {\n                    drawMultiPolyline(currentGeo.activeCoordinates, {\n                        color: 'red',\n                        size: (currentGeo.activeOptions && currentGeo.activeOptions.size) ? currentGeo.activeOptions.size : 2\n                    }, self);\n                }\n                drawMultiPolyline(currentGeo.coordinates, {\n                    color: (currentGeo.options && currentGeo.options.color) ? currentGeo.options.color : 'red',\n                    size: (currentGeo.options && currentGeo.options.size) ? currentGeo.options.size : 2\n                }, self);\n                break;\n            case 'intRticMarker':\n                drawRticMarker(currentGeo.point, currentGeo.orientation, currentGeo.angle, false, self);\n                break;\n            case 'Buffer':\n                drawBuffer(currentGeo.geometry.components, currentGeo.linkWidth, self, currentGeo.type);\n                break;\n            case 'sideBuffer':\n                drawSideBuffer(currentGeo.geometry, currentGeo.linkWidth, currentGeo.showSide, self, currentGeo.type);\n                break;\n            case 'linkArrowGuide':\n                drawLinkArrow(currentGeo.geometry, currentGeo.linkWidth, currentGeo.showSide, self, currentGeo.type);\n                break;\n            case 'IXPOI':\n                drawPoiAndLink(currentGeo.components, { color: 'blue', size: 2 }, self);\n                break;\n            case 'ADMINPOINT':\n                drawAdminPointAndLink(currentGeo.components, { color: 'blue', size: 2 }, self);\n                break;\n            default:\n                break;\n        }\n    },\n\n\n    /** *\n     * \n     */\n    clear: function () {\n        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);\n    },\n    distance: function (pointA, pointB) {\n        var len;\n        if (pointA.x) {\n            len = Math.pow((pointA.x - pointB.x), 2) + Math.pow((pointA.y - pointB.y), 2);\n        } else {\n            len = Math.pow((pointA[0] - pointB[0]), 2) + Math.pow((pointA[1] - pointB[1]), 2);\n        }\n\n        return Math.sqrt(len);\n    },\n    _redraw: function () {\n        this.clear();\n\n        this.draw(this.drawGeometry, this);\n        this._resetCanvasPosition();\n        return this;\n    }\n\n});\n\nfastmap.mapApi.editLayer = function (url, options) {\n    return new fastmap.mapApi.EditLayer(url, options);\n};\n\n","/**\n * Created by xujie on 2016-11-26.\n * FeedbackLayer\n * \n */\nfastmap.mapApi.FeedbackLayer = fastmap.mapApi.WholeLayer.extend({\n    /** *\n     *\n     * @param options options\n     */\n    initialize: function (options) {\n        FM.setOptions(this, options);\n\n        this.eventController = fastmap.uikit.EventController();\n        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        this.transform = fastmap.mapApi.symbol.GeometryTransform.getInstance();\n        this.featureSelector = fastmap.mapApi.FeatureSelector.getInstance();\n        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();\n    },\n\n    onAdd: function (map) {\n        this.map = map;\n        this._initContainer(this.options);\n\n        this._unloaded = 0;\n        this._drawItems = [];\n        this.eventController.on(L.Mixin.EventTypes.FEEDBACKREFRESH, this._onFeedbackRefresh, this);\n        map.on('moveend', this._redraw, this);\n        this.map.on('TileLayersLoaded', this._onTilesLoaded, this);\n    },\n\n    onRemove: function (map) {\n        this.map.getPanes().overlayPane.removeChild(this._div);\n\n        this.eventController.off(L.Mixin.EventTypes.FEEDBACKREFRESH, this._onFeedbackRefresh, this);\n        map.off('moveend', this._redraw, this);\n        this.map.off('TileLayersLoaded', this._onTilesLoaded, this);\n\n        this.map = null;\n    },\n\n    /**\n     * FEEDBACKREFRESH\n     * @param items\n     */\n    _onFeedbackRefresh: function (event) {\n        this._unloaded = 0;\n        this._drawItems = [];\n\n        var temp = event.drawItems || [];\n        for (var i = 0; i < temp.length; i++) {\n            if (temp[i].type === 'pid') {\n                this._drawItems.push({\n                    origin: temp[i],\n                    geometry: null,\n                    symbol: temp[i].symbol || null,\n                    drawable: false\n                });\n                this._unloaded++;\n            } else if (temp[i].type === 'geometry') {\n                this._drawItems.push({\n                    origin: temp[i],\n                    geometry: temp[i].geometry || null,\n                    symbol: temp[i].symbol || null,\n                    drawable: true\n                });\n            }\n        }\n\n        this._redraw();\n    },\n\n    /** *\n     * \n     */\n    _draw: function () {\n        var urls = this._getDependencyResource(this._drawItems);\n        var loader = new fastmap.mapApi.symbol.ImageLoader(urls);\n        var self = this;\n        loader.load()\n              .then(function () {\n                  self._onDependencyResourceLoaded();\n              })\n              .catch(function (e) {\n                  FM.Util.log(e);\n              });\n    },\n\n    _onDependencyResourceLoaded: function () {\n        // ,canvas\n        // \n        this._clear();\n        this.transform.setEnviroment(this.map, null, this._convertGeometry);\n        var g = this._ctx.canvas.getContext('2d');\n        for (var i = 0; i < this._drawItems.length; ++i) {\n            var item = this._drawItems[i];\n            if (!item.drawable) {\n                continue;\n            }\n            var convertedGeometry = this.transform.convertGeometry(item.geometry);\n            var symbol = item.symbol;\n            symbol.geometry = convertedGeometry;\n            symbol.draw(g);\n        }\n    },\n\n    _getDependencyResource: function (drawItems) {\n        var urls = [];\n        for (var i = 0; i < drawItems.length; i++) {\n            var item = drawItems[i];\n            if (!item.drawable) {\n                continue;\n            }\n            var symbol = item.symbol;\n            if (!symbol) {\n                continue;\n            }\n\n            var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n            urls = urls.concat(symbolFactory.getUrlsFromSymbol(symbol));\n        }\n\n        return urls;\n    },\n\n    _convertGeometry: function (map, tile, geometry) {\n        var point = map.latLngToContainerPoint([geometry.y, geometry.x]);\n        geometry.x = point.x;\n        geometry.y = point.y;\n        return geometry;\n    },\n\n    _loadData: function () {\n        var item,\n            feature,\n            i,\n            j;\n        var temp,\n            geomType,\n            geoms;\n        for (i = 0; i < this._drawItems.length; i++) {\n            item = this._drawItems[i];\n            if (!item.drawable) {\n                if (item.origin.pid && item.origin.featureType) {\n                    feature = this.featureSelector.selectByFeatureId(item.origin.pid, item.origin.featureType);\n                    if (feature) {\n                        geomType = this.symbolFactory.getGeometryTypeBySymbol(item.symbol);\n                        geoms = this.geometryAlgorithm.getGeometriesByType(feature.geometry, geomType);\n\n                        if (geoms.length === 0) {\n                            this._drawItems.splice(i, 1);\n                            i--;\n                        } else {\n                            item.geometry = this.geometryFactory.fromGeojson(geoms[0]);\n                            item.drawable = true;\n                            for (j = 1; j < geoms.length; j++) {\n                                temp = {\n                                    geometry: this.geometryFactory.fromGeojson(geoms[j]),\n                                    symbol: item.symbol,\n                                    drawable: true\n                                };\n                                this._drawItems.splice(i++, 0, temp);\n                            }\n                        }\n                        this._unloaded--;\n                    }\n                }\n            }\n        }\n    },\n\n    /** *\n     * \n     * @private\n     */\n    _redraw: function () {\n        this._resetCanvasPosition();\n\n        if (this._unloaded > 0) {\n            this._loadData();\n        }\n\n        this._draw();\n    },\n\n    /** *\n     * \n     */\n    _clear: function () {\n        this._ctx.clearRect(0, 0, this.canv.width, this.canv.height);\n    },\n\n    _onTilesLoaded: function () {\n        if (this._unloaded > 0) {\n            this._loadData();\n\n            this._draw();\n        }\n    }\n});\n\nfastmap.mapApi.feedbackLayer = function (options) {\n    return new fastmap.mapApi.FeedbackLayer(options);\n};\n","/**\n * Created by liwanchong on 2016/5/16.\n */\nfastmap.mapApi.GuideLineLayer = fastmap.mapApi.WholeLayer.extend({\n    /**\n     * \n     * @property includes\n     */\n    includes: L.Mixin.Events,\n\n    /** *\n     * \n     * @param {Object}options\n     */\n    initialize: function (url, options) {\n        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);\n        this.url = url;\n        this.g = this._ctx;\n        this.linkFObj = {};\n    },\n    draw: function (guideObj) {\n        var g = this._ctx;\n        if (guideObj) {\n            if (!this.linkFObj[guideObj.id]) {\n                this.linkFObj[guideObj.id] = guideObj;\n                this.drawLineString(guideObj.coordinates, guideObj.guidePoint, g, false, this);\n            }\n        }\n    },\n    drawMove: function (obj) {\n        var g = this._ctx;\n        // g.strokeStyle = \"red\";\n        // g.lineWidth = 2;\n        var keys = Object.getOwnPropertyNames(obj);\n        for (var i = 0; i < keys.length; i++) {\n            var item = keys[i];\n            this.drawLineString(obj[item].coordinates, obj[item].guidePoint, g, false, this);\n        }\n    },\n    /** *\n     * \n     */\n    clear: function () {\n        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);\n    },\n\n    drawLineString: function (geom, guidePoint, g, boolPixelCrs, self) {\n        if (!geom) {\n            return;\n        }\n        if (this.map.getZoom() >= 17) {\n            var proj = [];\n            proj.push(this.map.latLngToLayerPoint([geom[1], geom[0]]));\n            if (guidePoint) {\n                proj.push(this.map.latLngToLayerPoint([guidePoint[1], guidePoint[0]]));\n            }\n            if (g.setLineDash) {\n                g.setLineDash([6, 6]);\n                //  Get the current offset\n                g.lineDashOffset = 0;  // To animate the lines\n                g.lineJoin = 'round';\n                g.lineWidth = '1';\n                g.strokeStyle = 'gray';\n                g.beginPath();\n                for (var i = 0; i < proj.length; i++) {\n                    var method = (i === 0 ? 'move' : 'line') + 'To';\n                    g[method](proj[i].x, proj[i].y);\n                }\n                g.stroke();\n            }\n        }\n    },\n    _redraw: function () {\n        // this._resetCanvasPosition();\n        this.clear();\n        this.drawMove(this.linkFObj);\n\n        return this;\n    }\n\n});\nfastmap.mapApi.guideLineLayer = function (url, options) {\n    return new fastmap.mapApi.GuideLineLayer(url, options);\n};\n","/**\n * Created by wangtun on 2016/2/2.\n */\n/**\n * Created by zhongxiaoming on 2015/9/2.\n * Class 1:25000\n */\nfastmap.mapApi.GridLayer = fastmap.mapApi.MeshLayer.extend({\n    /** *\n     * \n     * @param {Object}options\n     */\n    initialize: function (options) {\n        fastmap.mapApi.MeshLayer.prototype.initialize.call(this, options);\n        this.minZoom = this.options.minZoom || 9;\n        this.maxZoom = this.options.maxZoom || 20;\n        this.divideX = this.options.divideX || 0;\n        this.divideY = this.options.divideY || 0;\n    },\n    /** *\n     * \n     * @param{L.Map} map\n     */\n    onAdd: function (map) {\n        this.map = map;\n        this._initContainer(this.options);\n        var that = this;\n        var center = null;\n        this.canv.onclick = function (e) {\n            var event = e;\n            event.stopPropagation();\n            event.preventDefault();\n            var showFlag = false;\n            for (var i = 0; i < that.gridArr.length; i++) {\n                var latlngbounds = that.gridArr[i].getBounds();\n                var bound = L.bounds(that.map.latLngToContainerPoint(latlngbounds.getNorthWest()), that.map.latLngToContainerPoint(latlngbounds.getSouthEast()));\n                if (e.x <= bound.max.x && e.x >= bound.min.x && e.y <= bound.max.y && e.y >= bound.min.y) {\n                    center = latlngbounds.getCenter();\n                    if (that.options.gridInfo[that.gridArr[i].options.gridId]) {\n                        if (that.options.gridInfo[that.gridArr[i].options.gridId].couldBorrow) {\n                            that.map.openPopup('<a href=\"javascript:void(0)\" class=\"btn btn-warning\"></a>', center);\n                        } else if (that.options.gridInfo[that.gridArr[i].options.gridId].couldReturn) {\n                            that.map.openPopup('<a href=\"javascript:void(0)\" class=\"btn btn-warning\"></a>', center);\n                        } else if (that.options.gridInfo[that.gridArr[i].options.gridId].userId) {\n                            that.map.openPopup('<div style=\"width:200px;text-align: center\"><img src=\"css/img/pie.jpg\" style=\"width:100px;height:100px\"/></div>', center);\n                        }\n                        showFlag = true;\n                    }\n                }\n            }\n            if (!showFlag) {\n                that.map.closePopup();\n            }\n        };\n        this.canv.ondblclick = function () {\n            window.location.href = 'edit.html';\n        };\n        map.on('moveend', this._redraw, this);\n        this._redraw();\n    },\n    /** *\n     * bounds\n     * @param {L.Bounds}bounds\n     */\n    draw: function (bounds) {\n        var pointDL = bounds.getSouthWest();\n        // \n        var pointUR = bounds.getNorthEast();\n        // var ret= this.CalculateMeshIds(pointDL.lng, pointUR.lng, pointDL.lat, pointUR.lat);\n        var minPoint = this.Calculate25TMeshCorner(pointDL);\n        var minLon = minPoint.lng;\n        var minLat = minPoint.lat;\n        this.gridArr = [];\n        var labelArr = [];\n        while (minLon <= pointUR.lng) {\n            var gridObj = this.createGrid(minLon, minLon + 0.125, minLat, pointUR.lat);\n            this.gridArr = this.gridArr.concat(gridObj);\n            minLon += 0.125;\n        }\n        for (var i = 0, len = this.gridArr.length; i < len; i++) {\n            var latlngbounds = this.gridArr[i].getBounds();\n            var bound = L.bounds(this.map.latLngToContainerPoint(latlngbounds.getNorthWest()), this.map.latLngToContainerPoint(latlngbounds.getSouthEast()));\n            var size = bound.getSize();\n            this.drawRect(this._ctx, this.gridArr[i], {\n                x: bound.min.x,\n                y: bound.min.y,\n                width: size.x,\n                height: size.y\n            });\n        }\n    },\n    /** *\n     * \n     * @param {Object}context canvas context\n     * @param meshId id\n     * @param options \n     */\n    drawRect: function (context, grid, options) {\n        context.globalAlpha = 0.3;\n        context.linewidth = 1; // \n        context.strokeStyle = '#000AFF'; // \n        context.strokeRect(options.x, options.y, options.width, options.height);\n    },\n    /** *\n     * \n     * @returns {fastmap.mapApi.MeshLayer}\n     * @private\n     */\n    _redraw: function () {\n        this._resetCanvasPosition();\n        this.clear();\n        if (this.map.getZoom() >= this.minZoom && this.map.getZoom() <= this.maxZoom) {\n            this.draw(this.map.getBounds());\n        }\n        return this;\n    },\n    /** *\n     * \n     * @param {number}minLon \n     * @param {number}maxLon \n     * @param {number}origin \n     * @param {number}destination \n     * @returns {Array}\n     */\n    createGrid: function (minLon, maxLon, origin, destination) {\n        // \n        var grid = [];\n        var labels = [];\n        var plusOri = function () {\n            origin += 0.083333333333333;\n        };\n        while (origin <= destination) {\n            var components = [];\n            components.push([origin, minLon]);\n            components.push([origin + 0.083333333333333, minLon]);\n            components.push([origin + 0.083333333333333, maxLon]);\n            components.push([origin, maxLon]);\n            var meshId = this.Calculate25TMeshId({\n                lng: (minLon + maxLon) / 2,\n                lat: (origin + origin + 0.083333333333333) / 2\n            });\n            var bound = this.Calculate25TMeshBorder(meshId);\n\n            this.createSubGrid(grid, bound, meshId, plusOri);\n        }\n        return grid;\n    },\n    createSubGrid: function (grid, bound, meshId, callback) {\n        var differenceY = bound.maxLat - bound.minLat;\n        if (this.divideY > 0) {\n            differenceY = (bound.maxLat - bound.minLat) / this.divideY;\n        }\n        var differenceX = bound.maxLon - bound.minLon;\n        if (this.divideX > 0) {\n            differenceX = (bound.maxLon - bound.minLon) / this.divideX;\n        }\n        for (var i = 0; i < this.divideX; i++) {\n            var boundXmin = bound.minLon + differenceX * i;\n            var boundXmax = bound.minLon + differenceX * (i + 1);\n            for (var j = 0; j < this.divideY; j++) {\n                var boundYmin = bound.minLat + differenceY * j;\n                var boundYmax = bound.minLat + differenceY * (j + 1);\n                var b = L.latLngBounds([boundYmin, boundXmin], [boundYmax, boundXmax]);\n                var polygon = L.rectangle(b, {\n                    meshId: meshId,\n                    gridId: meshId + '_' + j + '' + i\n                });\n                grid.push(polygon);\n            }\n        }\n        callback();\n    },\n    /** *\n     * \n     */\n    clear: function () {\n        this.canv.getContext('2d').clearRect(0, 0, this.canv.width, this.canv.height);\n    },\n    /** *\n     * \n     * @private\n     */\n    _resetCanvasPosition: function () {\n        var bounds = this.map.getBounds();\n        var topLeft = this.map.latLngToLayerPoint(bounds.getNorthWest());\n        L.DomUtil.setPosition(this._div, topLeft);\n    },\n    /*\n     *  \n     *\n     *  @param{number}lat                       \n     *  @param{number}remainder                 \n     */\n    CalculateIdealRowIndex: function (lat, remainder) {\n        //  =  - 0.0\n        var regionLatitude = lat - 0.0;\n        // \n        var secondLatitude = regionLatitude * 3600;\n        var longsecond;\n        // *10(0.000010.036)\n        if (secondLatitude * 1000 < 0) {\n            longsecond = Math.ceil(secondLatitude * 1000);\n        } else {\n            longsecond = Math.floor(secondLatitude * 1000);\n        }\n        remainder = (longsecond % 300000);\n        return {\n            value: Math.floor(longsecond / 300000),\n            reminder: remainder\n        };\n    },\n    /*\n     *  \n     *\n     *  @param{number}lat                       \n     *  @param{number}remainder                 \n     */\n    CalculateRealRowIndex: function (lat, remainder) {\n        // \n        var idealRow = this.CalculateIdealRowIndex(lat, remainder);\n        switch (idealRow % 3) { // \n            case 0: // \n                // 0.012\n                if (300000 - idealRow.remainder <= 12) {\n                    idealRow.value++;\n                }\n                break;\n            case 1: // \n                break;\n            case 2: // \n                // 0.012\n                if (idealRow.remainder < 12) {\n                    idealRow.value--;\n                }\n                break;\n            default:\n                break;\n        }\n        return idealRow;\n    },\n    /*\n     *  \n     *\n     *  @param{number}lon                \n     */\n    CalculateRealColumnIndex: function (lon, remainder) {\n        return this.CalculateIdealColumnIndex(lon, remainder);\n    },\n    /*\n     * \n     *\n     *  @param{number}lon                \n     *  @param{number}reminder            \n     */\n    CalculateIdealColumnIndex: function (lon, remainder) {\n        //  =  - 60.0\n        var regionLongitude = lon - 60.0;\n        // \n        var secondLongitude = regionLongitude * 3600;\n        // *10(0.000010.036)\n        var longsecond = Math.floor(secondLongitude * 1000);\n        remainder = Math.floor(longsecond % 450000);\n        return {\n            value: Math.floor(longsecond / 450000),\n            reminder: remainder\n        };\n    },\n    MeshLocator_25T: function (lon, lat) {\n        // \n        if ((this.IsAt25TMeshBorder(lon, lat) & 0x0F) == 0x01) {\n            lat += 0.00001;\n        }\n        var remainder = 0;\n        var rowResult = this.CalculateRealRowIndex(lat, remainder);\n        var colResult = this.CalculateRealColumnIndex(lon, rowResult.remainder);\n        // 12 : 1.5\n        var M1M2 = Math.floor(lat * 1.5);\n        // 34 :  60\n        var M3M4 = Math.floor(lon) - 60;\n        // 5 :\n        var M5 = rowResult.value % 8;\n        // 6 : 4508\n        var M6 = colResult.value % 8;\n        // ,\n        var sMeshId = '' + M1M2 + M3M4 + M5 + M6;\n        while (sMeshId.length < 6) {\n            sMeshId = '0' + sMeshId;\n        }\n        return sMeshId;\n    },\n    /*\n     *  ,,\n     *\n     *  @param {L.Latlng}point   \n     */\n    Calculate25TMeshId: function (point) {\n        var mesh = this.MeshLocator_25T(point.lng, point.lat);\n        return mesh;\n    },\n    /*\n     *  \n     *\n     *  @param{L.Latlng}point          \n     */\n    Calculate25TMeshCorner: function (point) {\n        return this.Calculate25TMeshCornerByMeshId(this.Calculate25TMeshId(point));\n    },\n    /** *\n     * \n     * @param {String}mesh\n     * @returns {*}\n     * @constructor\n     */\n    Calculate25TMeshCornerByMeshId: function (mesh) {\n        var cc = mesh.split('');\n        var M1 = parseInt(cc[0], 0);\n        var M2 = parseInt(cc[1], 0);\n        var M3 = parseInt(cc[2], 0);\n        var M4 = parseInt(cc[3], 0);\n        var M5 = parseInt(cc[4], 0);\n        var M6 = parseInt(cc[5], 0);\n        var x = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;\n        var y = (M1 * 10 + M2) * 2400 + M5 * 300;\n        var point = L.latLng(y / 3600.0, x / 3600.0);\n        return point;\n    },\n    /** *\n     *  border\n     * @param {String}mesh\n     * @returns {{minLon: (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng), minLat: (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat), maxLon: (*|a.lng|L.LatLng.lng|L.LatLngBounds._southWest.lng|L.LatLngBounds._northEast.lng|o.LatLngBounds._northEast.lng), maxLat: (*|a.lat|L.LatLng.lat|L.LatLngBounds._southWest.lat|L.LatLngBounds._northEast.lat|o.LatLngBounds._northEast.lat)}}\n     * @constructor\n     */\n    Calculate25TMeshBorder: function (mesh) {\n        var cc = mesh.split('');\n        var M1 = parseInt(cc[0], 0);\n        var M2 = parseInt(cc[1], 0);\n        var M3 = parseInt(cc[2], 0);\n        var M4 = parseInt(cc[3], 0);\n        var M5 = parseInt(cc[4], 0);\n        var M6 = parseInt(cc[5], 0);\n        var xConner = (M3 * 10 + M4) * 3600 + M6 * 450 + 60 * 3600;\n        var yConner = (M1 * 10 + M2) * 2400 + M5 * 300;\n        var xUpper = xConner + 450.0;\n        var yUpper = yConner + 300.0;\n        var leftBottom = L.latLng(yConner / 3600.0, xConner / 3600.0);\n        var rightTop = L.latLng(yUpper / 3600.0, xUpper / 3600.0);\n        return {\n            minLon: leftBottom.lng,\n            minLat: leftBottom.lat,\n            maxLon: rightTop.lng,\n            maxLat: rightTop.lat\n        };\n    },\n    /*\n     *  \n     *\n     *  @param{number}lon               \n     *  @param{number}lat               \n     */\n    IsAt25TMeshBorder: function (lon, lat) {\n        var model = 0;\n        var remainder = 0;\n        var rowResult = this.CalculateIdealRowIndex(lat, remainder);\n        switch (rowResult.value % 3) {\n            case 0: // \n                // 0.012\n                if (300000 - rowResult.remainder == 12) {\n                    model |= 0x01;\n                } else if (rowResult.remainder == 0) model |= 0x01;\n                break;\n            case 1: // \n                break;\n            case 2: // \n                // 0.012\n                if (rowResult.remainder == 12) {\n                    model |= 0x01;\n                }\n                break;\n            default:\n                break;\n        }\n        var colResult = this.CalculateRealColumnIndex(lon, rowResult.remainder);\n        if (colResult.remainder == 0) model |= 0x10;\n        return model;\n    }\n});\nfastmap.mapApi.gridLayer = function (options) {\n    return new fastmap.mapApi.GridLayer(options);\n};\n","/**\n * Created by xujie on 2016-11-26.\n * WholeCanvasLayer\n */\nfastmap.mapApi.TileBoundsLayer = fastmap.mapApi.WholeLayer.extend({\n    /** *\n     *\n     * @param options options\n     */\n    initialize: function (options) {\n        fastmap.mapApi.WholeLayer.prototype.initialize.call(this, options);\n\n        // \n        FM.Util.bind(this);\n\n        this.options = options || {};\n        this._tiles = {};\n\n        this._transform = fastmap.mapApi.symbol.GeometryTransform.getInstance();\n    },\n\n    /** *\n     * \n     */\n    _redraw: function (features) {\n        this.clear();\n        this._updateTiles();\n        this._resetCanvasPosition();\n        this._drawTiles(this._tiles);\n    },\n\n    /** *\n     * \n     */\n    clear: function () {\n        this._ctx.clearRect(0, 0, this.canv.width, this.canv.height);\n        this._tiles = {};\n    },\n\n    _createTileSymbol: function (tile) {\n        var symbolData = {\n            type: 'CompositeFillSymbol',\n            symbols: [\n                {\n                    type: 'CenterMarkerFillSymbol',\n                    marker: {\n                        type: 'TextMarkerSymbol',\n                        font: '',\n                        size: 20,\n                        color: 'red',\n                        text: tile.x + '/' + tile.y + '/' + tile.z\n                    }\n                },\n                {\n                    type: 'SimpleFillSymbol',\n                    color: 'transparent',\n                    outLine: {\n                        type: 'SimpleLineSymbol',\n                        color: 'red',\n                        width: 1\n                    }\n                }\n            ]\n        };\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        var symbol = symbolFactory.createSymbol(symbolData);\n        var geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        symbol.geometry = geometryFactory.fromGeojson(tile.bounds);\n        return symbol;\n    },\n\n    _drawTiles: function (tiles) {\n        this._transform.setEnviroment(this.map, null, this._convertGeometry);\n        var g = this._ctx.canvas.getContext('2d');\n        var keys = Object.getOwnPropertyNames(this._tiles);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var tile = this._tiles[key];\n            var symbol = this._createTileSymbol(tile);\n            var convertedGeometry = this._transform.convertGeometry(symbol.geometry);\n            symbol.geometry = convertedGeometry;\n            symbol.draw(g);\n        }\n    },\n\n    _updateTiles: function () {\n        var map = this.map;\n        var bounds = map.getPixelBounds();\n        var zoom = map.getZoom();\n        var tileSize = this.options.tileSize;\n\n        var tileBounds = L.bounds(\n            bounds.min.divideBy(tileSize)._floor(),\n            bounds.max.divideBy(tileSize)._floor());\n\n        this._addTilesFromCenterOut(tileBounds);\n    },\n\n    _addTilesFromCenterOut: function (bounds) {\n        var queue = [];\n        var center = bounds.getCenter();\n        var zoom = this.map.getZoom();\n\n        for (var j = bounds.min.y; j <= bounds.max.y; j++) {\n            for (var i = bounds.min.x; i <= bounds.max.x; i++) {\n                var point = new L.Point(i, j);\n                queue.push(point);\n            }\n        }\n\n        // load tiles in order of their distance to center\n        queue.sort(function (a, b) {\n            return a.distanceTo(center) - b.distanceTo(center);\n        });\n\n        for (i = 0; i < queue.length; i++) {\n            var x = queue[i].x;\n            var y = queue[i].y;\n            var tile = this._createTile(x, y, zoom);\n            this._tiles[tile.name] = tile;\n        }\n    },\n\n    _createTile: function (x, y, z) {\n        var bounds = this._getTileBounds(x, y);\n        var tile = {\n            name: x + ':' + y,\n            x: x,\n            y: y,\n            z: z,\n            size: this.options.tileSize,\n            bounds: bounds\n        };\n        return tile;\n    },\n\n    _getTileBounds: function (x, y) {\n        var tileSize = this.options.tileSize;\n        var tilePoint = new L.Point(x, y);\n        var nwPoint = tilePoint.multiplyBy(tileSize);\n        var sePoint = nwPoint.add([tileSize, tileSize]);\n        var nw = this.map.unproject(nwPoint);\n        var se = this.map.unproject(sePoint);\n\n        var bounds = {\n            type: 'Polygon',\n            coordinates: [\n                [\n                    [nw.lng, nw.lat],\n                    [se.lng, nw.lat],\n                    [se.lng, se.lat],\n                    [nw.lng, se.lat],\n                    [nw.lng, nw.lat]\n                ]\n            ]\n        };\n\n        return bounds;\n    },\n\n    _convertGeometry: function (map, tile, geometry) {\n        var point = map.latLngToContainerPoint([geometry.y, geometry.x]);\n        geometry.x = point.x;\n        geometry.y = point.y;\n        return geometry;\n    }\n});\n\nfastmap.mapApi.tileBoundsLayer = function (options) {\n    return new fastmap.mapApi.TileBoundsLayer(options);\n};\n","/**\n * Created by Chenx on 2017/7/10.\n * Class 1:25000\n */\nfastmap.mapApi.OverlayLayer = fastmap.mapApi.MeshLayer.extend({\n    /** *\n     * \n     * @param {Object}context canvas context\n     * @param meshId id\n     * @param options \n     */\n    drawRect: function (context, meshId, options) {\n        var meshList = this.options.meshList;\n\n        if (!meshList || meshList.length === 0) {\n            return;\n        }\n\n        if (meshList.indexOf(parseInt(meshId, 10)) >= 0) {\n            return;\n        }\n\n        // \n        context.globalAlpha = 0.2;\n        context.fillStyle = 'gray'; // \n        context.fillRect(options.min.x, options.min.y, options.getSize().x, options.getSize().y); //  x y  \n    }\n});\nfastmap.mapApi.overlayLayer = function (options) {\n    return new fastmap.mapApi.OverlayLayer(options);\n};\n","/**\n * ajax,optionsajax\n * url:url,\n * header:,json,null\n * responseType:,,''\n * timeout:,0\n * requestParameter:,url\n * parameter: ,onSuccessonFail,null\n * debug:true,,false\n * onSuccess:,,null\n * onFail:,null\n * onAbort:,null\n * onError:,null\n * onTimeout:,null\n * @param options nullundefined\n * @returns {XMLHttpRequest}\n */\nfastmap.mapApi.ajax.get = function (options) {\n    if (!options) {\n        throw new Error('options!');\n    }\n    var url = options.url;\n    if (!url) {\n        throw new Error('url!');\n    }\n\n    var headers = options.headers || null;\n    var responseType = options.responseType || '';\n    var timeout = options.timeout || 0;\n    var requestParameter = options.requestParameter || null;\n    if (requestParameter) {\n        url += '&parameter=' + encodeURIComponent(JSON.stringify(requestParameter));\n    }\n\n    var parameter = options.parameter || null;\n    var debug = options.debug || false;\n\n    var onSuccess = options.onSuccess || null;\n    var onFail = options.onFail || null;\n    var onAbort = options.onAbort || null;\n    var onError = options.onError || null;\n    var onTimeout = options.onTimeout || null;\n\n    var xhr = new XMLHttpRequest();\n    if (!xhr) {\n        throw new Error('XMLHttpRequest!');\n    }\n\n    var startTime = null;\n    var endTime = null;\n\n    xhr.onloadstart = function (event) {\n        if (debug) {\n            startTime = new Date().getTime();\n            FM.Util.log(':' + url + '    :' + startTime);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n    };\n    xhr.onabort = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n        var errmsg = ':' + url + '    :' + startTime + '    :' + diff;\n\n        if (debug) {\n            FM.Util.log(errmsg);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n\n        if (onAbort) {\n            onAbort(errmsg, parameter);\n        }\n    };\n    xhr.onerror = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n        var errmsg = ':' + url + '    :' + startTime + '    :' + diff;\n\n        if (debug) {\n            FM.Util.log(errmsg);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n\n        if (onError) {\n            onError(errmsg, parameter);\n        }\n    };\n    xhr.ontimeout = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n        var errmsg = ':' + url + '    :' + startTime + '    :' + diff;\n\n        if (debug) {\n            FM.Util.log(errmsg);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n\n        if (onTimeout) {\n            onTimeout(errmsg, parameter);\n        }\n    };\n    xhr.onload = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n\n        // 2xx304\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n            if (debug) {\n                FM.Util.log(':' + url + '    :' + startTime + '    :' + diff);\n                FM.Util.log(':' + JSON.stringify(parameter));\n                FM.Util.log(xhr.response);\n            }\n            if (onSuccess) {\n                onSuccess(xhr.response, parameter);\n            }\n        } else {\n            var errmsg = ':' + url + '    :' + startTime + '    :' + diff + '    :' + xhr.status;\n            if (debug) {\n                FM.Util.log(errmsg);\n                FM.Util.log(':' + JSON.stringify(parameter));\n                FM.Util.log(xhr);\n            }\n            if (onFail) {\n                onFail(errmsg, parameter);\n            }\n        }\n    };\n    xhr.open('GET', url);\n    if (headers) {\n        var keys = Object.getOwnPropertyNames(headers);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = headers[key];\n            xhr.setRequestHeader(key, value);\n        }\n    }\n    xhr.responseType = responseType;\n    xhr.timeout = timeout;\n    xhr.send();\n    return xhr;\n};\n\n/**\n * ajax,optionsajax\n * url:url,\n * header:,json,null\n * responseType:,,''\n * timeout:,0\n * requestParameter:\n * parameter: ,onSuccessonFail,null\n * debug:true,,false\n * onSuccess:,,null\n * onFail:,null\n * onAbort:,null\n * onError:,null\n * onTimeout:,null\n * @param options nullundefined\n * @returns {XMLHttpRequest}\n */\nfastmap.mapApi.ajax.post = function (options) {\n    if (!options) {\n        throw new Error('options!');\n    }\n    var url = options.url;\n    if (!url) {\n        throw new Error('url!');\n    }\n\n    var headers = options.headers || null;\n    var responseType = options.responseType || '';\n    var timeout = options.timeout || 0;\n    var requestParameter = options.requestParameter || null;\n    if (!requestParameter) {\n        throw new Error('requestParameter!');\n    }\n    var parameter = options.parameter || null;\n    var debug = options.debug || false;\n\n    var onSuccess = options.onSuccess || null;\n    var onFail = options.onFail || null;\n    var onAbort = options.onAbort || null;\n    var onError = options.onError || null;\n    var onTimeout = options.onTimeout || null;\n\n    var xhr = new XMLHttpRequest();\n    if (!xhr) {\n        throw new Error('XMLHttpRequest!');\n    }\n\n    var startTime = null;\n    var endTime = null;\n\n    xhr.onloadstart = function (event) {\n        if (debug) {\n            startTime = new Date().getTime();\n            FM.Util.log(':' + url + '    :' + startTime);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n    };\n    xhr.onabort = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n        var errmsg = ':' + url + '    :' + startTime + '    :' + diff;\n\n        if (debug) {\n            FM.Util.log(errmsg);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n\n        if (onAbort) {\n            onAbort(errmsg, parameter);\n        }\n    };\n    xhr.onerror = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n        var errmsg = ':' + url + '    :' + startTime + '    :' + diff;\n\n        if (debug) {\n            FM.Util.log(errmsg);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n\n        if (onError) {\n            onError(errmsg, parameter);\n        }\n    };\n    xhr.ontimeout = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n        var errmsg = ':' + url + '    :' + startTime + '    :' + diff;\n\n        if (debug) {\n            FM.Util.log(errmsg);\n            FM.Util.log(':' + JSON.stringify(parameter));\n            FM.Util.log(event);\n        }\n\n        if (onTimeout) {\n            onTimeout(errmsg, parameter);\n        }\n    };\n    xhr.onload = function (event) {\n        endTime = new Date().getTime();\n        var diff = endTime - startTime;\n\n        // 2xx304\n        if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 304) {\n            if (debug) {\n                FM.Util.log(':' + url + '    :' + startTime + '    :' + diff);\n                FM.Util.log(':' + JSON.stringify(parameter));\n                FM.Util.log(xhr.response);\n            }\n            if (onSuccess) {\n                onSuccess(xhr.response, parameter);\n            }\n        } else {\n            var errmsg = ':' + url + '    :' + startTime + '    :' + diff + '    :' + xhr.status;\n            if (debug) {\n                FM.Util.log(errmsg);\n                FM.Util.log(':' + JSON.stringify(parameter));\n                FM.Util.log(xhr);\n            }\n            if (onFail) {\n                onFail(errmsg, parameter);\n            }\n        }\n    };\n    xhr.open('POST', url);\n    xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');\n    if (headers) {\n        var keys = Object.getOwnPropertyNames(headers);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = headers[key];\n            xhr.setRequestHeader(key, value);\n        }\n    }\n    xhr.responseType = responseType;\n    xhr.timeout = timeout;\n    var data = encodeURIComponent(JSON.stringify(requestParameter));\n    xhr.send('parameter=' + data);\n    return xhr;\n};\n","/**\n * Bounds\n * \n *\n * @namespace mapApi\n * @class Bounds\n */\nfastmap.mapApi.Parallel = function () {\n// ;\n    var obj = {};\n    obj.lineEquation = function (pt1, pt2) {\n        if (pt1.x != pt2.x) {\n            var a = (pt2.y - pt1.y) / (pt2.x - pt1.x);\n            return {\n                a: a,\n                b: pt1.y - a * pt1.x\n            };\n        }\n        if (pt1.y != pt2.y) {\n            return { x: pt1.x };\n        }\n        return null;\n    };\n\n    obj.intersection = function (l1a, l1b, l2a, l2b) {\n        var line1 = this.lineEquation(l1a, l1b);\n        var line2 = this.lineEquation(l2a, l2b);\n\n        if (line1 == null || line2 == null) {\n            return null;\n        }\n\n        if (line1.hasOwnProperty('x')) {\n            if (line2.hasOwnProperty('x')) {\n                return null;\n            }\n            return L.point(line1.x, line2.a * line1.x + line2.b);\n        }\n        if (line2.hasOwnProperty('x')) {\n            return L.point(line2.x, line1.a * line2.x + line1.b);\n        }\n\n        if (line1.a == line2.a) {\n            return null;\n        }\n\n        var x = (line2.b - line1.b) / (line1.a - line2.a);\n        var y = line1.a * x + line1.b;\n\n        return L.point(x, y);\n    };\n\n    obj.translatePoint = function (pt, dist, radians) {\n        return L.point(pt.x + dist * Math.cos(radians), pt.y + dist * Math.sin(radians));\n    };\n\n    obj.joinSegments = function (s1, s2, offset, joinStyle) {\n        var jointPoints = [];\n        jointPoints = [this.intersection(s1.offset[0], s1.offset[1], s2.offset[0], s2.offset[1])];\n        return jointPoints.filter(function (v) {\n            return v;\n        });\n    };\n\n    obj.offsetPointLine = function (points, distance) {\n        var l = points.length;\n        if (l < 2) {\n            throw new Error('Line should be defined by at least 2 points');\n        }\n        var a = points[0];\n        var offsetSegments = [];\n        var offsetAngle,\n            segmentAngle,\n            b;\n        for (var i = 1; i < l; i++) {\n            b = points[i];\n            // angle in (-PI, PI]\n            segmentAngle = Math.atan2(a.y - b.y, a.x - b.x);\n            // angle in (-1.5 * PI, PI/2]\n            offsetAngle = segmentAngle - Math.PI / 2;\n            // store offset point and other information to avoid recomputing it later\n            offsetSegments.push({\n                angle: segmentAngle,\n                offsetAngle: offsetAngle,\n                distance: distance,\n                original: [a, b],\n                offset: [\n                    this.translatePoint(a, distance, offsetAngle),\n                    this.translatePoint(b, distance, offsetAngle)\n                ]\n            });\n            a = b;\n        }\n        return offsetSegments;\n    };\n\n    obj.joinLineSegments = function (segments, offset, joinStyle) {\n        var l = segments.length;\n        var joinedPoints = [];\n        var s1 = segments[0];\n        var s2 = segments[0];\n        joinedPoints.push(s1.offset[0]);\n\n        for (var i = 1; i < l; i++) {\n            s2 = segments[i];\n            joinedPoints = joinedPoints.concat(this.joinSegments(s1, s2, offset, joinStyle));\n            s1 = s2;\n        }\n        joinedPoints.push(s2.offset[1]);\n\n        return joinedPoints;\n    };\n    return obj;\n};\n\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.scene.SceneLayer = L.Class.extend({\n    options: {\n        visible: true,\n        editable: true\n    },\n\n    initialize: function (id, config) {\n        FM.setOptions(this, config.options);\n\n        this.id = id;\n        this.name = config.name || '';\n        this.type = config.type;\n        this.label = config.label || '';\n    },\n\n    setOptions: function (options) {\n        return FM.setOptions(this, options);\n    },\n\n    setLeafletLayer: function (leafletLayer) {\n        this._leafletLayer = leafletLayer;\n    },\n\n    setLabel: function (label) {\n        this.label = label || '';\n    },\n\n    setVisible: function (flag) {\n        this.options.visible = flag === undefined ? true : flag;\n    },\n\n    getOptions: function () {\n        return this.options;\n    },\n\n    getLeafletLayer: function () {\n        return this._leafletLayer;\n    },\n\n    getFeatureType: function () {\n        return this.options.featureType || null;\n    },\n\n    getRender: function () {\n        return this.options.render || null;\n    },\n\n    getSourceName: function () {\n        return this.options.source || null;\n    },\n\n    visible: function () {\n        return this.options.visible === undefined ? true : this.options.visible;\n    },\n\n    canDraw: function (zoom) {\n        if (this.type !== 'vector') {\n            // vectorleaflet\n            return true;\n        }\n        if (!this.options) {\n            // vectorOpitions\n            return false;\n        }\n        var sourceName = this.options.source;\n        var visible = this.options.visible;\n        var featureType = this.options.featureType;\n        if (!visible || !sourceName || !featureType) {\n            return false;\n        }\n\n        var minZoom = this.options.minZoom;\n        var maxZoom = this.options.maxZoom;\n        if (zoom < minZoom || zoom > maxZoom) {\n            return false;\n        }\n\n        return true;\n    },\n\n    useSameData: function (layer) {\n        if (this.type !== layer.type) {\n            return false;\n        }\n        if (this.options.source !== layer.options.source) {\n            return false;\n        }\n        if (this.options.featureType !== layer.options.featureType) {\n            return false;\n        }\n\n        return true;\n    },\n\n    clone: function () {\n        var options = {\n            name: this.name,\n            type: this.type,\n            label: this.label,\n            options: this.options\n        };\n        return new fastmap.mapApi.scene.SceneLayer(this.id, options);\n    },\n\n    isEditable: function () {\n        return this.options.editable;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.scene.Scene = L.Class.extend({\n    initialize: function (id, config) {\n        this.id = id;\n        this.name = config.name || '';\n        this.type = config.type;\n        this.label = config.label;\n        this.layers = [];\n    },\n\n    addLayer: function (sceneLayer) {\n        this.layers.push(sceneLayer);\n    },\n\n    removeLayer: function (sceneLayer) {\n        var index = this.layers.indexOf(sceneLayer);\n\n        this.layers.splice(index, 1);\n    },\n\n    getLayerById: function (sceneLayerId) {\n        var layer;\n        for (var i = 0; i < this.layers.length; ++i) {\n            layer = this.layers[i];\n            if (layer.id === sceneLayerId) {\n                return layer;\n            }\n        }\n\n        return null;\n    },\n\n    contains: function (layerId) {\n        var layer;\n        for (var i = 0; i < this.layers.length; ++i) {\n            layer = this.layers[i];\n            if (layer.id === layerId) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n});\n","/**\n * Created by xujie on 2017/01/11\n * Recreated by chenx on 2017-5-12\n * \n */\nFM.mapApi.scene.SceneController = L.Class.extend({\n    initialize: function () {\n        this._map = null;\n        this._currentScene = null;\n\n        this._scenes = [];\n        this._layers = [];\n\n        // \n        this._backgrounds = [];\n        // \n        this._overlays = [];\n        // \n        this._temporaries = [];\n        // _temporaries\n        this._sceneLayers = [];\n    },\n\n    setMap: function (map) {\n        this._map = map;\n    },\n\n    getLeafletMap: function () {\n        return this._map.getLeafletMap();\n    },\n\n    getZoom: function () {\n        return this._map.getZoom();\n    },\n\n    setDefaultZoom: function (config) {\n        config = config || {};\n        this.defaultZoom = {\n            minZoom: config.minZoom || 1,\n            maxZoom: config.maxZoom || 20,\n            minEditZoom: config.minEditZoom || 17\n        };\n    },\n\n    loadLayers: function (config, label) {\n        var keys = Object.getOwnPropertyNames(config);\n        var key,\n            value,\n            layer;\n        for (var i = 0; i < keys.length; ++i) {\n            key = keys[i];\n            value = config[key];\n            if (this.getLayerById(key)) {\n                throw new Error('ID:' + key);\n            }\n            value.label = value.label || label || 'None';\n\n            if (this.defaultZoom) {\n                value.options = value.options || {};\n                value.options.minZoom = value.options.minZoom || this.defaultZoom.minZoom;\n                value.options.maxZoom = value.options.maxZoom || this.defaultZoom.maxZoom;\n                if (value.type === 'vector') {\n                    value.options.minEditZoom = value.options.minEditZoom || this.defaultZoom.minEditZoom;\n                }\n            }\n\n            layer = new FM.mapApi.scene.SceneLayer(key, value);\n            this._layers.push(layer);\n        }\n    },\n\n    _createScene: function (sceneId, config) {\n        var scene = new FM.mapApi.scene.Scene(sceneId, config);\n\n        var orderedLayers = [];\n        var item,\n            sceneLayer,\n            label,\n            tempLayers;\n\n        // \n        var i,\n            j;\n        for (i = 0; i < config.layers.length; ++i) {\n            item = config.layers[i];\n            sceneLayer = this.getLayerById(item);\n            if (sceneLayer) {\n                scene.addLayer(sceneLayer);\n            } else if (item.charAt(0) === '[' && item.charAt(item.length - 1) === ']') {\n                label = item.slice(1, item.length - 1);\n                tempLayers = this.getLayersByLabel(label);\n                for (j = 0; j < tempLayers.length; j++) {\n                    scene.addLayer(tempLayers[j]);\n                }\n            } else {\n                throw new Error(':' + item);\n            }\n        }\n        return scene;\n    },\n\n    loadScenes: function (config) {\n        var keys = Object.getOwnPropertyNames(config.scenes);\n        var key,\n            value;\n        var scene;\n        for (var i = 0; i < keys.length; ++i) {\n            key = keys[i];\n            value = config.scenes[key];\n            if (this.getSceneById(key)) {\n                throw new Error('ID:' + key);\n            }\n            scene = this._createScene(key, value);\n            this._scenes.push(scene);\n        }\n\n        if (config.defaultScene) {\n            this.changeScene(config.defaultScene);\n        }\n    },\n\n    loadBackground: function (list) {\n        var layer;\n        for (var i = 0; i < list.length; i++) {\n            layer = this.getLayerById(list[i]);\n            if (!layer) {\n                throw new Error('BackgroundID:' + list[i]);\n            }\n            this._addToBackground(layer);\n        }\n\n        this.refreshBackground();\n    },\n\n    loadOverlay: function (list) {\n        var layer;\n        for (var i = 0; i < list.length; i++) {\n            layer = this.getLayerById(list[i]);\n            if (!layer) {\n                throw new Error('OverlayID:' + list[i]);\n            }\n            this._addToOverlay(layer);\n        }\n\n        this.refreshOverlay();\n    },\n\n    _addToBackground: function (sceneLayer) {\n        var layer = sceneLayer.clone();\n        this._map.addLayer(layer);\n        this._backgrounds.push(layer);\n\n        return layer;\n    },\n\n    addToBackground: function (sceneLayer) {\n        this._addToBackground(sceneLayer);\n\n        this.refreshBackground();\n    },\n\n    removeFromBackground: function (sceneLayerId) {\n        var layer;\n        for (var i = 0; i < this._backgrounds.length; i++) {\n            layer = this._backgrounds[i];\n            if (layer.id === sceneLayerId) {\n                this._map.removeLayer(layer);\n                this._backgrounds.splice(i, 1);\n                break;\n            }\n        }\n        this._map.refresh();\n    },\n\n    _resetBackground: function () {\n        var leafletLayer;\n        for (var i = this._backgrounds.length - 1; i >= 0; i--) {\n            leafletLayer = this._backgrounds[i].getLeafletLayer();\n            leafletLayer.bringToBack();\n        }\n    },\n\n    refreshBackground: function () {\n        this._resetBackground();\n        this._map.refresh();\n    },\n\n    _addToOverlay: function (sceneLayer) {\n        var layer = sceneLayer.clone();\n        this._map.addLayer(layer);\n        this._overlays.push(layer);\n\n        return layer;\n    },\n\n    addToOverlay: function (sceneLayer) {\n        this._addToOverlay(sceneLayer);\n\n        this.refreshOverlay();\n    },\n\n    removeFromOverlay: function (sceneLayerId) {\n        var layer;\n        for (var i = 0; i < this._overlays.length; i++) {\n            layer = this._overlays[i];\n            if (layer.id === sceneLayerId) {\n                this._map.removeLayer(layer);\n                this._overlays.splice(i, 1);\n                break;\n            }\n        }\n        this._map.refresh();\n    },\n\n    _resetOverlay: function () {\n        var leafletLayer;\n        for (var i = 0; i < this._overlays.length; i++) {\n            leafletLayer = this._overlays[i].getLeafletLayer();\n            leafletLayer.bringToFront();\n        }\n    },\n\n    refreshOverlay: function () {\n        this._resetOverlay();\n        this._map.refresh();\n    },\n\n    _addToScene: function (sceneLayer) {\n        var layer = sceneLayer.clone();\n        this._map.addLayer(layer);\n        this._sceneLayers.push(layer);\n\n        return layer;\n    },\n\n    addToScene: function (sceneLayers) {\n        var layers;\n        if (FM.Util.isObject(sceneLayers)) {\n            layers = [sceneLayers];\n        } else if (FM.Util.isArray(sceneLayers)) {\n            layers = sceneLayers;\n        }\n        if (!layers || layers.length === 0) {\n            return;\n        }\n\n        for (var i = 0; i < layers.length; i++) {\n            this._addToScene(layers[i]);\n        }\n\n        this.refreshOverlay();\n    },\n\n    removeFromScene: function (sceneLayerIds) {\n        var ids,\n            layer;\n        if (FM.Util.isArray(sceneLayerIds)) {\n            ids = sceneLayerIds;\n        } else if (sceneLayerIds) {\n            ids = [sceneLayerIds];\n        }\n        if (!ids || ids.length === 0) {\n            return;\n        }\n\n        for (var i = this._sceneLayers.length - 1; i >= 0; i--) {\n            layer = this._sceneLayers[i];\n            if (ids.indexOf(layer.id) >= 0) {\n                this._map.removeLayer(layer);\n                this._sceneLayers.splice(i, 1);\n            }\n        }\n        this._map.refresh();\n    },\n\n    _clearScene: function () {\n        for (var i = 0; i < this._sceneLayers.length; i++) {\n            this._map.removeLayer(this._sceneLayers[i]);\n        }\n        this._temporaries.length = 0;\n        this._sceneLayers.length = 0;\n    },\n\n    addToTemporary: function (layers) {\n        var addLayer;\n        for (var i = 0; i < layers.length; i++) {\n            this._temporaries.push(this._addToScene(layers[i]));\n        }\n\n        this.refreshOverlay();\n    },\n\n    removeFromTemporary: function (temporaryLayerIds) {\n        var ids,\n            layer;\n        if (FM.Util.isArray(temporaryLayerIds)) {\n            ids = temporaryLayerIds;\n        } else if (temporaryLayerIds) {\n            ids = [temporaryLayerIds];\n        }\n        if (!ids || ids.length === 0) {\n            return;\n        }\n\n        for (var i = this._temporaries.length - 1; i >= 0; i--) {\n            layer = this._temporaries[i];\n            if (ids.indexOf(layer.id) >= 0) {\n                this._temporaries.splice(i, 1);\n            }\n        }\n\n        this.removeFromScene(temporaryLayerIds);\n    },\n\n    clearTemporary: function () {\n        var ids = [];\n        for (var i = 0; i < this._temporaries.length; i++) {\n            ids.push(this._temporaries[i].id);\n        }\n\n        this.removeFromScene(ids);\n\n        this._temporaries.length = 0;\n    },\n\n    getScenes: function () {\n        return this._scenes;\n    },\n\n    getCurrentScene: function () {\n        return this._currentScene;\n    },\n\n    getSceneById: function (sceneId) {\n        for (var i = 0; i < this._scenes.length; i++) {\n            if (this._scenes[i].id === sceneId) {\n                return this._scenes[i];\n            }\n        }\n        return null;\n    },\n\n    getLayers: function () {\n        return this._layers;\n    },\n\n    getLayerById: function (layerId) {\n        for (var i = 0; i < this._layers.length; i++) {\n            if (this._layers[i].id === layerId) {\n                return this._layers[i];\n            }\n        }\n        return null;\n    },\n\n    getLayersByLabel: function (label) {\n        var layers = [];\n        for (var i = 0; i < this._layers.length; i++) {\n            if (this._layers[i].label === label) {\n                layers.push(this._layers[i]);\n            }\n        }\n        return layers;\n    },\n\n    getLayersBySourceName: function (sourceName) {\n        var layers = [];\n        for (var i = 0; i < this._layers.length; i++) {\n            if (this._layers[i].getSourceName() === sourceName) {\n                layers.push(this._layers[i]);\n            }\n        }\n        return layers;\n    },\n\n    getLayersByFeatureType: function (featureType, label) {\n        var layers = [];\n        var layer;\n        var type;\n        for (var i = 0; i < this._layers.length; i++) {\n            layer = this._layers[i];\n            type = layer.getFeatureType();\n            if (!type || type !== featureType) {\n                continue;\n            }\n            if (label && (!layer.label || layer.label !== label)) {\n                continue;\n            }\n\n            layers.push(layer);\n        }\n\n        return layers;\n    },\n\n    getBackgroundLayers: function () {\n        return this._backgrounds;\n    },\n\n    getOverlayLayers: function () {\n        return this._overlays;\n    },\n\n    getTemporaryLayers: function () {\n        return this._temporaries;\n    },\n\n    getSceneLayers: function () {\n        return this._sceneLayers;\n    },\n\n    getLoadedLayers: function () {\n        var layers = [];\n        Array.prototype.push.apply(layers, this._backgrounds);\n        Array.prototype.push.apply(layers, this._sceneLayers);\n        Array.prototype.push.apply(layers, this._overlays);\n\n        return layers;\n    },\n\n    getLoadedLayersByFeatureType: function (featureType) {\n        var layers = [];\n        var i;\n        for (i = 0; i < this._backgrounds.length; i++) {\n            if (this._backgrounds[i].getFeatureType() === featureType) {\n                layers.push(this._backgrounds[i]);\n            }\n        }\n\n        for (i = 0; i < this._sceneLayers.length; i++) {\n            if (this._sceneLayers[i].getFeatureType() === featureType) {\n                layers.push(this._sceneLayers[i]);\n            }\n        }\n\n        for (i = 0; i < this._overlays.length; i++) {\n            if (this._overlays[i].getFeatureType() === featureType) {\n                layers.push(this._overlays[i]);\n            }\n        }\n\n        return layers;\n    },\n\n    getLoadedFeatureTypes: function () {\n        var types = [];\n        var i;\n        var type;\n        for (i = 0; i < this._backgrounds.length; i++) {\n            type = this._backgrounds[i].getFeatureType();\n            if (type) {\n                types.push(type);\n            }\n        }\n\n        for (i = 0; i < this._sceneLayers.length; i++) {\n            type = this._sceneLayers[i].getFeatureType();\n            if (type) {\n                types.push(type);\n            }\n        }\n\n        for (i = 0; i < this._overlays.length; i++) {\n            type = this._overlays[i].getFeatureType();\n            if (type) {\n                types.push(type);\n            }\n        }\n\n        return FM.Util.unique(types);\n    },\n\n    getEditableFeatureTypes: function () {\n        var types = [];\n        var type;\n        var i;\n        var editable = true;\n\n        for (i = 0; i < this._backgrounds.length; i++) {\n            type = this._backgrounds[i].getFeatureType();\n            editable = this._backgrounds[i].isEditable();\n\n            if (type && editable) {\n                types.push(type);\n            }\n        }\n\n        for (i = 0; i < this._sceneLayers.length; i++) {\n            type = this._sceneLayers[i].getFeatureType();\n            editable = this._sceneLayers[i].isEditable();\n\n            if (type && editable) {\n                types.push(type);\n            }\n        }\n\n        for (i = 0; i < this._overlays.length; i++) {\n            type = this._overlays[i].getFeatureType();\n            editable = this._overlays[i].isEditable();\n\n            if (type && editable) {\n                types.push(type);\n            }\n        }\n\n        return FM.Util.unique(types);\n    },\n\n    changeScene: function (sceneId) {\n        var i;\n        if (this._currentScene && this._currentScene.id === sceneId) {\n            return null;\n        }\n\n        var oldScene = this._currentScene;\n\n        this._clearScene();\n\n        var scene = this.getSceneById(sceneId);\n        for (i = 0; i < scene.layers.length; i++) {\n            this._addToScene(scene.layers[i]);\n        }\n\n        this.refreshOverlay();\n\n        this._currentScene = scene;\n\n        this._map._leafletMap.fire('SceneChanged', {\n            oldScene: oldScene,\n            newScene: scene\n        });\n\n        return scene;\n    },\n\n    _resetScene: function () {\n        var i;\n        for (i = 0; i < this._sceneLayers.length; i++) {\n            this._map.removeLayer(this._sceneLayers[i]);\n        }\n\n        for (i = 0; i < this._sceneLayers.length; i++) {\n            this._map.addLayer(this._sceneLayers[i]);\n        }\n    },\n\n    refreshScene: function () {\n        this._resetScene();\n\n        this._resetBackground();\n\n        this._resetOverlay();\n\n        this._map.refresh();\n    },\n\n    isLayerLoaded: function (layerId) {\n        var i;\n        for (i = 0; i < this._backgrounds.length; i++) {\n            if (this._backgrounds[i].visible() && this._backgrounds[i].id === layerId) {\n                return true;\n            }\n        }\n\n        for (i = 0; i < this._sceneLayers.length; i++) {\n            if (this._sceneLayers[i].visible() && this._sceneLayers[i].id === layerId) {\n                return true;\n            }\n        }\n\n        for (i = 0; i < this._overlays.length; i++) {\n            if (this._overlays[i].visible() && this._overlays[i].id === layerId) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    refreshMap: function () {\n        this._map.refresh();\n    },\n\n    redrawLayerByGeoLiveTypes: function (featureTypes) {\n        var layers = [];\n        var temp = this.getLoadedLayers();\n        var type;\n        for (var i = 0; i < temp.length; i++) {\n            type = temp[i].getFeatureType();\n            if (type && featureTypes.indexOf(type) >= 0) {\n                layers.push(temp[i]);\n            }\n        }\n\n        if (layers.length > 0) {\n            this._map.redraw(layers);\n        }\n    },\n\n    destroy: function () {\n        FM.mapApi.scene.SceneController.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!FM.mapApi.scene.SceneController.instance) {\n                FM.mapApi.scene.SceneController.instance =\n                    new FM.mapApi.scene.SceneController();\n            }\n            return FM.mapApi.scene.SceneController.instance;\n        }\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.SnapActor = L.Class.extend({\n    initialize: function () {\n        this.type = '';\n        // commented by chenx on 2017-8-9\n        // \n        // 0\n        // 0\n        this.priority = 0;\n        this.point = null;\n        this.isSnapped = false;\n        this.map = null;\n\n        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();\n        this.sourceController = fastmap.mapApi.source.SourceController.getInstance();\n        this.sceneController = fastmap.mapApi.scene.SceneController.getInstance();\n        this.geometryTransform = fastmap.mapApi.GeometryTransform.getInstance();\n        this.featureSelector = fastmap.mapApi.FeatureSelector.getInstance();\n        this.feedbackController = fastmap.mapApi.FeedbackController.getInstance();\n        this.feedback = new fastmap.mapApi.Feedback();\n        this.feedback.priority = 999999;\n\n        this.startup();\n    },\n\n    snap: function (point, box) {\n        this.isSnapped = false;\n        this.point = null;\n        return this.getSnapResult();\n    },\n\n    draw: function () {\n        this.feedback.clear();\n\n        if (!this.isSnapped) {\n            this.feedbackController.refresh();\n            return;\n        }\n\n        var symbol = this.symbolFactory.getSymbol('snap_pt_cross');\n        this.feedback.add(this.point, symbol);\n\n        this.feedbackController.refresh();\n    },\n\n    clear: function () {\n        this.feedback.clear();\n        this.feedbackController.refresh();\n    },\n\n    shutdown: function () {\n        this.feedbackController.del(this.feedback);\n        this.feedbackController.refresh();\n    },\n\n    startup: function () {\n        this.feedbackController.add(this.feedback);\n        this.feedbackController.refresh();\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        return {\n            type: this.type,\n            point: this.point\n        };\n    },\n\n    getPriority: function () {\n        return this.priority;\n    },\n\n    setMap: function (map) {\n        this.map = map;\n    },\n\n    getMap: function (map) {\n        return this.map;\n    },\n\n    distance: function (geometry1, geometry2) {\n        var self = this;\n        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);\n        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);\n        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);\n        return this.geometryAlgorithm.distance(pGeometry1, pGeometry2);\n    },\n\n    nearestPoints: function (geometry1, geometry2) {\n        var self = this;\n        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);\n        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);\n        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);\n        var res = this.geometryAlgorithm.nearestPoints(pGeometry1, pGeometry2);\n        this.geometryTransform.setEnviroment(this.map, null, this.mercatorToLatlng);\n        res.point1 = this.geometryTransform.convertGeometry(res.point1);\n        res.point2 = this.geometryTransform.convertGeometry(res.point2);\n        return res;\n    },\n\n    nearestLocations: function (geometry1, geometry2) {\n        var self = this;\n        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);\n        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);\n        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);\n        var res = this.geometryAlgorithm.nearestLocations(pGeometry1, pGeometry2);\n        this.geometryTransform.setEnviroment(this.map, null, this.mercatorToLatlng);\n        res.point = this.geometryTransform.convertGeometry(res.point);\n        res.previousPoint = this.geometryTransform.convertGeometry(res.previousPoint);\n        res.nextPoint = this.geometryTransform.convertGeometry(res.nextPoint);\n        return res;\n    },\n\n    latlngToMercator: function (map, tile, coordinates) {\n        var x = coordinates[0];\n        var y = coordinates[1];\n        var point = map.project([y, x]);\n        return [point.x, point.y];\n    },\n\n    mercatorToLatlng: function (map, tile, coordinates) {\n        var x = coordinates[0];\n        var y = coordinates[1];\n        var latlng = map.unproject([x, y]);\n        return [latlng.lng, latlng.lat];\n    },\n\n    /**\n     * \n     * @param  {[type]} geometry1 [description]\n     * @param  {[type]} geometry2 [description]\n     * @return {Boolean}          [description]\n     */\n    intersects: function (geometry1, geometry2) {\n        var self = this;\n        this.geometryTransform.setEnviroment(this.map, null, this.latlngToMercator);\n        var pGeometry1 = this.geometryTransform.convertGeometry(geometry1);\n        var pGeometry2 = this.geometryTransform.convertGeometry(geometry2);\n        return this.geometryAlgorithm.intersects(pGeometry1, pGeometry2);\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.FeatureSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.type = 'FeatureSnapActor';\n        this.feature = null;\n        this.layerId = '';\n        this.snapExceptions = [];\n        this.snapFunction = null;\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n        this.feature = null;\n\n        if (!this.layerId) {\n            return null;\n        }\n\n        var features = this.featureSelector.selectByGeometry(box, [this.layerId]);\n\n        if (features.length === 0) {\n            return null;\n        }\n\n        var minDis = Number.MAX_VALUE;\n        for (var i = 0; i < features.length; ++i) {\n            var feature = features[i];\n            if (this.isSnapException(feature.properties.id)) {\n                continue;\n            }\n\n            if (this.snapFunction && !this.snapFunction(feature)) {\n                continue;\n            }\n\n            var res = this.nearestPoints(point, feature.geometry);\n            if (res.distance < minDis) {\n                minDis = res.distance;\n                this.point = res.point2;\n                this.feature = feature;\n                this.isSnapped = true;\n            }\n        }\n\n        return this.getSnapResult();\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);\n        result.feature = this.feature;\n        return result;\n    },\n\n    addSnapException: function (id) {\n        for (var i = 0; i < this.snapExceptions.length; ++i) {\n            if (id === this.snapExceptions[i]) {\n                return;\n            }\n        }\n\n        this.snapExceptions.push(id);\n    },\n\n    delSnapException: function (id) {\n        for (var i = 0; i < this.snapExceptions.length; ++i) {\n            if (id === this.snapExceptions[i]) {\n                this.snapExceptions.splice(i, 1);\n                return;\n            }\n        }\n    },\n\n    clearSnapException: function () {\n        this.snapExceptions = [];\n    },\n\n    isSnapException: function (id) {\n        for (var i = 0; i < this.snapExceptions.length; ++i) {\n            if (id === this.snapExceptions[i]) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    setSnapFunction: function (func) {\n        this.snapFunction = func;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.FullScreenFeatureSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.type = 'FullScreenFeatureSnapActor';\n        this.feature = null;\n        this.layerId = '';\n        this.snapExceptions = [];\n        this.snapFunction = null;\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n        this.feature = null;\n\n        if (!this.layerId) {\n            return null;\n        }\n\n        var features = this.featureSelector.selectByGeoLiveType(this.layerId);\n\n        if (features.length === 0) {\n            return null;\n        }\n\n        var minDis = Number.MAX_VALUE;\n        for (var i = 0; i < features.length; ++i) {\n            var feature = features[i];\n            if (this.isSnapException(feature.properties.id)) {\n                continue;\n            }\n\n            if (this.snapFunction && !this.snapFunction(feature)) {\n                continue;\n            }\n\n            var res = this.nearestPoints(point, feature.geometry);\n            if (res.distance < minDis) {\n                minDis = res.distance;\n                this.point = res.point2;\n                this.feature = feature;\n                this.isSnapped = true;\n            }\n        }\n\n        return this.getSnapResult();\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);\n        result.feature = this.feature;\n        return result;\n    },\n\n    addSnapException: function (id) {\n        for (var i = 0; i < this.snapExceptions.length; ++i) {\n            if (id === this.snapExceptions[i]) {\n                return;\n            }\n        }\n\n        this.snapExceptions.push(id);\n    },\n\n    delSnapException: function (id) {\n        for (var i = 0; i < this.snapExceptions.length; ++i) {\n            if (id === this.snapExceptions[i]) {\n                this.snapExceptions.splice(i, 1);\n                return;\n            }\n        }\n    },\n\n    clearSnapException: function () {\n        this.snapExceptions = [];\n    },\n\n    isSnapException: function (id) {\n        for (var i = 0; i < this.snapExceptions.length; ++i) {\n            if (id === this.snapExceptions[i]) {\n                return true;\n            }\n        }\n        return false;\n    },\n\n    setSnapFunction: function (func) {\n        this.snapFunction = func;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.GivenPointSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.type = 'GivenPointSnapActor';\n        this.value = null;\n        this.pairs = [];\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n        this.value = null;\n\n        if (!this.pairs) {\n            return null;\n        }\n\n        var minDis = Number.MAX_VALUE;\n        for (var i = 0; i < this.pairs.length; ++i) {\n            var pair = this.pairs[i];\n            var tmpPoint = pair.key;\n            var tmpValue = pair.value;\n            var dis = this.distance(point, tmpPoint);\n            if (dis < minDis) {\n                minDis = dis;\n                this.point = tmpPoint;\n                this.value = tmpValue;\n                this.isSnapped = true;\n            }\n        }\n\n        return this.getSnapResult();\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);\n        result.value = this.value;\n        return result;\n    },\n\n    draw: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.draw.apply(this, arguments);\n\n        if (!this.isSnapped) {\n            return;\n        }\n\n        if (this.pairs) {\n            for (var i = 0; i < this.pairs.length; ++i) {\n                var pair = this.pairs[i];\n                var symbol = this.symbolFactory.getSymbol('snap_pt_given_point');\n                this.feedback.add(pair.key, symbol);\n            }\n        }\n\n        this.feedbackController.refresh();\n    },\n\n    addPair: function (point, value) {\n        var pair = {\n            key: point,\n            value: value\n        };\n        this.pairs.push(pair);\n    },\n\n    clearPairs: function () {\n        this.pairs = [];\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.GivenFeatureSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.type = 'GivenFeatureSnapActor';\n        this.feature = null;\n        this.features = [];\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n        this.feature = null;\n\n        if (!this.features) {\n            return null;\n        }\n\n        if (this.features.length === 0) {\n            return null;\n        }\n\n        var minDis = Number.MAX_VALUE;\n        for (var i = 0; i < this.features.length; ++i) {\n            var feature = this.features[i];\n            // add by chenx on 2017-5-2\n            if (feature.unloaded) {\n                feature = this.featureSelector.selectByFeatureId(feature.id, feature.geoLiveType);\n                if (feature) {\n                    this.features.splice(i, 1, feature);\n                } else {\n                    continue;\n                }\n            }\n            var res = this.nearestPoints(point, feature.geometry);\n            if (res.distance < minDis) {\n                minDis = res.distance;\n                this.point = res.point2;\n                this.feature = feature;\n                this.isSnapped = true;\n            }\n        }\n\n        return this.getSnapResult();\n    },\n\n    setFeatures: function (features) {\n        var items = features;\n        for (var i = 0; i < items.length; ++i) {\n            var item = items[i];\n\n            var feature = this.featureSelector.selectByFeatureId(item.id, item.geoLiveType);\n            if (!feature) { // add by chenx on 2017-5-2\n                this.features.push({\n                    id: item.id,\n                    geoLiveType: item.geoLiveType,\n                    unloaded: true\n                });\n            } else {\n                this.features.push(feature);\n            }\n        }\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);\n        result.feature = this.feature;\n        return result;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.GivenObjectSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.type = 'GivenObjectSnapActor';\n        this.feature = null;\n        this.features = [];\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n        this.feature = null;\n\n        if (this.features.length === 0) {\n            return null;\n        }\n\n        var minDis = Number.MAX_VALUE;\n        for (var i = 0; i < this.features.length; ++i) {\n            var feature = this.features[i];\n            var res = this.nearestPoints(point, feature.geometry);\n            if (res.distance < minDis) {\n                minDis = res.distance;\n                this.point = res.point2;\n                this.feature = feature;\n                this.isSnapped = true;\n            }\n        }\n\n        return this.getSnapResult();\n    },\n\n    setObjects: function (features) {\n        this.features = [];\n        Array.prototype.push.apply(this.features, features);\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);\n        result.feature = this.feature;\n        return result;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.NearestLocationSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.type = 'NearestLocationSnapActor';\n        this.loc = null;\n        this.geometry = null;\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n        this.value = null;\n\n        if (!this.geometry) {\n            return null;\n        }\n\n        this.loc = this.nearestLocations(point, this.geometry);\n        this.point = this.loc.point;\n        this.isSnapped = true;\n\n        return this.getSnapResult();\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);\n        result.nearestLoactions = this.loc;\n        return result;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.NearestVertexSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.type = 'NearestVertexSnapActor';\n        this.index = null;\n        this.geometry = null;\n        this.canSnapStart = true;\n        this.canSnapEnd = true;\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n        this.value = null;\n\n        if (!this.geometry) {\n            return null;\n        }\n\n        var minDis = Number.MAX_VALUE;\n        for (var i = 0; i < this.geometry.coordinates.length; i++) {\n            if (!this.canSnapStart && i === 0) {\n                continue;\n            }\n            if (!this.canSnapEnd && i === this.geometry.coordinates.length - 1) {\n                continue;\n            }\n            var coordinates = this.geometry.coordinates[i];\n            var vertex = this.coordinatesToPoint(coordinates);\n            var dis = this.distance(point, vertex);\n            if (dis < minDis) {\n                minDis = dis;\n                this.point = vertex;\n                this.index = i;\n                this.isSnapped = true;\n            }\n        }\n\n        return this.getSnapResult();\n    },\n\n    getSnapResult: function () {\n        if (!this.isSnapped) {\n            return null;\n        }\n\n        var result = fastmap.mapApi.snap.SnapActor.prototype.getSnapResult.apply(this, arguments);\n        result.index = this.index;\n        return result;\n    },\n\n    draw: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.draw.apply(this, arguments);\n\n        if (!this.isSnapped) {\n            return;\n        }\n\n        if (this.geometry) {\n            for (var i = 0; i < this.geometry.coordinates.length; ++i) {\n                if (!this.canSnapStart && i === 0) {\n                    continue;\n                }\n                if (!this.canSnapEnd && i === this.geometry.coordinates.length - 1) {\n                    continue;\n                }\n                var coordinates = this.geometry.coordinates[i];\n                var vertex = this.coordinatesToPoint(coordinates);\n                var symbol = this.symbolFactory.getSymbol('snap_pt_vertex');\n                this.feedback.add(vertex, symbol);\n            }\n        }\n\n        this.feedbackController.refresh();\n    },\n\n    coordinatesToPoint: function (coordinates) {\n        var point = {\n            type: 'Point',\n            coordinates: coordinates\n        };\n        return point;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.MeshBorderSnapActor = fastmap.mapApi.snap.SnapActor.extend({\n    initialize: function () {\n        fastmap.mapApi.snap.SnapActor.prototype.initialize.apply(this, arguments);\n\n        this.meshAlgm = fastmap.mapApi.MeshAlgorithm.getInstance();\n        this.type = 'MeshBorderSnapActor';\n    },\n\n    snap: function (point, box) {\n        fastmap.mapApi.snap.SnapActor.prototype.snap.apply(this, arguments);\n\n        var borderLines = this._getMeshBorderLines(point);\n\n        var minDist = Number.MAX_VALUE;\n        for (var i = 0; i < borderLines.length; i++) {\n            if (this.intersects(box, borderLines[i])) {\n                var rest = this.nearestPoints(point, borderLines[i]);\n                if (rest.distance < minDist) {\n                    minDist = rest.distance;\n                    this.point = rest.point2;\n                    this.isSnapped = true;\n                }\n            }\n        }\n\n        return this.getSnapResult();\n    },\n\n    _getMeshBorderLines: function (point) {\n        var latLon = {\n            lng: point.coordinates[0],\n            lat: point.coordinates[1]\n        };\n        var border = this.meshAlgm.Calculate25TMeshBorder(this.meshAlgm.Calculate25TMeshId(latLon));\n\n        var lines = [];\n        lines.push({\n            type: 'LineString',\n            coordinates: [\n                [border.minLon, border.minLat],\n                [border.minLon, border.maxLat]\n            ]\n        });\n        lines.push({\n            type: 'LineString',\n            coordinates: [\n                [border.minLon, border.maxLat],\n                [border.maxLon, border.maxLat]\n            ]\n        });\n        lines.push({\n            type: 'LineString',\n            coordinates: [\n                [border.maxLon, border.maxLat],\n                [border.maxLon, border.minLat]\n            ]\n        });\n        lines.push({\n            type: 'LineString',\n            coordinates: [\n                [border.maxLon, border.minLat],\n                [border.minLon, border.minLat]\n            ]\n        });\n\n        return lines;\n    }\n});\n","/**\n * Created by xujie3949 on 2016/12/8.\n */\n\nfastmap.mapApi.snap.SnapController = L.Class.extend({\n    initialize: function (options) {\n        this.feedbackController = fastmap.mapApi.FeedbackController.getInstance();\n        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        this.geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        this.geometryTransform = fastmap.mapApi.symbol.GeometryTransform.getInstance();\n        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();\n\n        this.map = null;\n        this.snapActors = [];\n        this.activeSnapActor = null;\n        this.isRunning = false;\n        this.drawSnapCross = true;\n        this.tolerance = 20;\n    },\n\n    setMap: function (map) {\n        this.map = map;\n    },\n\n    add: function (snapActor) {\n        for (var i = 0; i < this.snapActors.length; ++i) {\n            if (snapActor === this.snapActors[i]) {\n                return;\n            }\n        }\n\n        snapActor.setMap(this.map);\n        this.snapActors.push(snapActor);\n\n        this.snapActors = this.snapActors.sort(function (a, b) {\n            return b.priority - a.priority;\n        });\n    },\n\n    del: function (snapActor) {\n        for (var i = 0; i < this.snapActors.length; ++i) {\n            if (snapActor === this.snapActors[i]) {\n                snapActor.shutdown();\n                this.snapActors.splice(i, 1);\n                return;\n            }\n        }\n    },\n\n    clear: function () {\n        for (var i = 0; i < this.snapActors.length; ++i) {\n            var snapActor = this.snapActors[i];\n            snapActor.shutdown();\n        }\n\n        this.snapActors = [];\n    },\n\n    startup: function () {\n        for (var i = 0; i < this.snapActors.length; ++i) {\n            var snapActor = this.snapActors[i];\n            snapActor.startup();\n        }\n        this.isRunning = true;\n    },\n\n    shutdown: function () {\n        for (var i = 0; i < this.snapActors.length; ++i) {\n            var snapActor = this.snapActors[i];\n            snapActor.shutdown();\n        }\n        this.isRunning = false;\n    },\n\n    isSnapping: function () {\n        return this.isRunning;\n    },\n\n    snap: function (point) {\n        if (!this.isRunning) {\n            return null;\n        }\n\n        if (this.snapActors.length === 0) {\n            return null;\n        }\n\n        if (this.activeSnapActor) {\n            this.activeSnapActor.clear();\n            this.activeSnapActor = null;\n        }\n\n        var box = this.getBox(point, this.tolerance);\n        var snapResult = null;\n        var minDis = Number.MAX_VALUE;\n\n        for (var i = 0; i < this.snapActors.length; ++i) {\n            var snapActor = this.snapActors[i];\n            // add by chenx on 2017-8-9\n            // SnapActorpriority\n            if (this.activeSnapActor && snapActor.priority < 0) {\n                break;\n            }\n            var tmpSnapResult = snapActor.snap(point, box);\n            if (!tmpSnapResult) {\n                continue;\n            }\n\n            var dis = this.geometryAlgorithm.distance(tmpSnapResult.point, point);\n            if (dis < minDis) {\n                this.activeSnapActor = snapActor;\n                snapResult = tmpSnapResult;\n                minDis = dis;\n            }\n        }\n\n        this.draw();\n\n        return snapResult;\n    },\n\n    getBox: function (point, tolerance) {\n        var x = point.coordinates[0];\n        var y = point.coordinates[1];\n        var pixelPoint = this.map.project([y, x]);\n        var left = pixelPoint.x - tolerance;\n        var right = pixelPoint.x + tolerance;\n        var top = pixelPoint.y - tolerance;\n        var bottom = pixelPoint.y + tolerance;\n\n        var geojson = {\n            type: 'Polygon',\n            coordinates: []\n        };\n\n        var coordinates = [];\n        var leftTop = this.map.unproject([left, top]);\n        var rightTop = this.map.unproject([right, top]);\n        var rightBottom = this.map.unproject([right, bottom]);\n        var leftBottom = this.map.unproject([left, bottom]);\n\n        coordinates.push([leftTop.lng, leftTop.lat]);\n        coordinates.push([rightTop.lng, rightTop.lat]);\n        coordinates.push([rightBottom.lng, rightBottom.lat]);\n        coordinates.push([leftBottom.lng, leftBottom.lat]);\n        coordinates.push([leftTop.lng, leftTop.lat]);\n\n        geojson.coordinates = [coordinates];\n\n        return geojson;\n    },\n\n    getActiveSnapActor: function () {\n        return this.activeSnapActor;\n    },\n\n    setDrawSnapCross: function (value) {\n        this.drawSnapCross = value;\n    },\n\n    getDrawSnapCross: function (value) {\n        return this.drawSnapCross;\n    },\n\n    draw: function () {\n        if (!this.isRunning) {\n            return;\n        }\n\n        if (!this.drawSnapCross) {\n            return;\n        }\n\n        if (!this.activeSnapActor) {\n            return;\n        }\n\n        this.activeSnapActor.draw();\n    },\n\n    destroy: function () {\n        fastmap.mapApi.snap.SnapController.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.snap.SnapController.instance) {\n                fastmap.mapApi.snap.SnapController.instance =\n                    new fastmap.mapApi.snap.SnapController();\n            }\n            return fastmap.mapApi.snap.SnapController.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nFM.mapApi.source.Source = L.Class.extend({\n    initialize: function (name, config) {\n        this.name = name;\n        this.parsor = config.parsor || null;\n        this._sourceUrl = config.sourceUrl || null;\n        this._subdomains = config.subdomains || [];\n        this._requestParameter = FM.Util.clone(config.requestParameter);\n\n        this._data = {};\n    },\n\n    createParameter: function (tile) {\n        var parameter = FM.Util.clone(this._requestParameter);\n        parameter.x = tile.x;\n        parameter.y = tile.y;\n        parameter.z = tile.z;\n        return parameter;\n    },\n\n    setParameter: function (key, value) {\n        this._requestParameter[key] = value;\n    },\n\n    getParameter: function (key) {\n        return this._requestParameter[key];\n    },\n\n    setFeatureTypes: function (types) {\n        this.setParameter('types', types);\n    },\n\n    add: function (feature, tileName) {\n        if (!feature) {\n            throw new Error('feature');\n        }\n        if (!tileName) {\n            throw new Error('tileName');\n        }\n        if (!feature.properties) {\n            throw new Error('featureproperties');\n        }\n\n        var geoLiveType = feature.properties.geoLiveType;\n        if (!geoLiveType) {\n            throw new Error('feature.propertiesgeoLiveType');\n        }\n\n        if (!this._data.hasOwnProperty(tileName)) {\n            this._data[tileName] = {};\n        }\n\n        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {\n            this._data[tileName][geoLiveType] = {\n                features: [],\n                index: {}\n            };\n        }\n\n        var id = feature.properties.id;\n        if (!id) {\n            throw new Error('feature.propertiesid');\n        }\n\n        // var length = this._data[tileName][geoLiveType].features.push(feature);\n\n        // \n        // if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {\n        //     this._data[tileName][geoLiveType].index[id] = [];\n        // }\n        // this._data[tileName][geoLiveType].index[id].push(length - 1);\n\n        if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {\n            var length = this._data[tileName][geoLiveType].features.push(feature);\n            this._data[tileName][geoLiveType].index[id] = [];\n            this._data[tileName][geoLiveType].index[id].push(length - 1);\n        } else {\n            this._data[tileName][geoLiveType].features[this._data[tileName][geoLiveType].index[id][0]] = feature;\n        }\n    },\n\n    del: function (feature, tileName) {\n        if (!feature) {\n            throw new Error('feature');\n        }\n        if (!tileName) {\n            throw new Error('tileName');\n        }\n        if (!feature.properties) {\n            throw new Error('featureproperties');\n        }\n\n        var geoLiveType = feature.properties.geoLiveType;\n        if (!geoLiveType) {\n            throw new Error('feature.propertiesgeoLiveType');\n        }\n\n        if (!this._data.hasOwnProperty(tileName)) {\n            return;\n        }\n\n        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {\n            return;\n        }\n\n        var id = feature.properties.id;\n        if (!id) {\n            throw new Error('feature.propertiesid');\n        }\n\n        if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {\n            return;\n        }\n\n        var posArray = this._data[tileName][geoLiveType].index[id];\n        var features = this._data[tileName][geoLiveType].features;\n        for (var i = 0; i < posArray.length; ++i) {\n            var pos = posArray[i];\n            features.splice(pos, 1);\n        }\n        delete this._data[tileName][geoLiveType].index[id];\n    },\n\n    delByTile: function (tileName) {\n        if (this._data.hasOwnProperty(tileName)) {\n            delete this._data[tileName];\n        }\n    },\n\n    delByType: function (geoLiveType, tileName) {\n        if (!this._data.hasOwnProperty(tileName)) {\n            return;\n        }\n\n        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {\n            return;\n        }\n\n        delete this._data[tileName][geoLiveType];\n    },\n\n    clear: function () {\n        this._data = {};\n    },\n\n    queryTilesById: function (geoLiveType, id) {\n        if (!geoLiveType || !id) {\n            return [];\n        }\n\n        var tileNames = [];\n        var keys = Object.getOwnPropertyNames(this._data);\n        for (var i = 0; i < keys.length; ++i) {\n            var tileName = keys[i];\n            if (!this._data[tileName].hasOwnProperty(geoLiveType)) {\n                continue;\n            }\n            if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {\n                continue;\n            }\n            tileNames.push(tileName);\n        }\n\n        return tileNames;\n    },\n\n    queryFeatureById: function (geoLiveType, id, tileName) {\n        if (!this._data.hasOwnProperty(tileName)) {\n            return null;\n        }\n\n        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {\n            return null;\n        }\n\n        if (!this._data[tileName][geoLiveType].index.hasOwnProperty(id)) {\n            return null;\n        }\n\n        var features = this._data[tileName][geoLiveType].features;\n        var posArray = this._data[tileName][geoLiveType].index[id];\n        var feature = features[posArray[0]];\n\n        return feature;\n    },\n\n    queryFeaturesByType: function (geoLiveType, tileName) {\n        if (!this._data.hasOwnProperty(tileName)) {\n            return [];\n        }\n\n        if (!this._data[tileName].hasOwnProperty(geoLiveType)) {\n            return [];\n        }\n\n        var features = this._data[tileName][geoLiveType].features;\n        return features;\n    },\n\n    queryTiles: function () {\n        return Object.getOwnPropertyNames(this._data);\n    },\n\n    createUrl: function (tile, tileIndex) {\n        return this._template(this._sourceUrl, {\n            s: this._getSubdomain(tileIndex),\n            z: tile.z,\n            x: tile.x,\n            y: tile.y\n        });\n    },\n\n    _getSubdomain: function (tileIndex) {\n        if (this._subdomains.length === 0) {\n            return null;\n        }\n        var index = tileIndex % this._subdomains.length;\n        return this._subdomains[index];\n    },\n\n    _template: function (str, data) {\n        return str.replace(/\\{ *([\\w_]+) *\\}/g, function (matchStr, key) {\n            var value = data[key];\n            if (!value) {\n                throw new Error(':' + matchStr);\n            }\n            return value;\n        });\n    }\n});\n","/**\n * Created by zhongxiaoming on 2017/4/12.\n */\nfastmap.mapApi.source.ClassicalSource = fastmap.mapApi.source.Source.extend({\n    createParameter: function (tile) {\n        var parameter = FM.Util.clone(this._requestParameter);\n        parameter.x = tile.x;\n        parameter.y = tile.y;\n        parameter.z = tile.z;\n        return parameter;\n    }\n});\n","/**\n * Created by zhongxiaoming on 2017/4/12.\n */\nfastmap.mapApi.source.InfoSource = fastmap.mapApi.source.Source.extend({\n    createParameter: function (tile) {\n        var parameter = FM.Util.clone(this._requestParameter);\n        parameter.x = tile.x;\n        parameter.y = tile.y;\n        parameter.z = tile.z;\n        return parameter;\n    }\n});\n","fastmap.mapApi.source.DeletionLinkSource = fastmap.mapApi.source.Source.extend({\n    createParameter: function (tile) {\n        var parameter = FM.Util.clone(this._requestParameter);\n        parameter.x = tile.x;\n        parameter.y = tile.y;\n        parameter.z = tile.z;\n        return parameter;\n    }\n});\n\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.source.SourceController = L.Class.extend({\n    initialize: function () {\n        this._sources = {};\n        this.tileRequestController = fastmap.mapApi.TileRequestController.getInstance();\n    },\n\n    add: function (source) {\n        if (this._sources.hasOwnProperty(source.name)) {\n            throw new Error(':' + source.name);\n        }\n\n        this._sources[source.name] = source;\n    },\n\n    del: function (sourceName) {\n        if (this._sources.hasOwnProperty(sourceName)) {\n            delete this._sources[sourceName];\n        }\n    },\n\n    clear: function () {\n        var keys = Object.getOwnPropertyNames(this._sources);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            this._sources[key].clear();\n        }\n    },\n\n    getSource: function (sourceName) {\n        if (!this._sources.hasOwnProperty(sourceName)) {\n            return null;\n        }\n\n        return this._sources[sourceName];\n    },\n\n    getAllSources: function () {\n        var sources = [];\n        var keys = Object.getOwnPropertyNames(this._sources);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            sources.push(this._sources[key]);\n        }\n        return sources;\n    },\n\n    requestTileData: function (tile, tileIndex, urlObject) {\n        var self = this;\n        var promises = this._createPromises(tile, tileIndex, urlObject);\n        return Promise.all(promises)\n            .then(function (res) {\n                self._tilePromiseSuccess(tile, res);\n                return tile;\n            });\n    },\n\n    loadConfig: function (config) {\n        var keys = Object.getOwnPropertyNames(config);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = config[key];\n            if (this._sources[key]) {\n                throw new Error(':' + key);\n            }\n            this._sources[key] = this._loadSource(key, value);\n        }\n    },\n\n    _loadSource: function (key, config) {\n        var source;\n        switch (config.type) {\n            case 'classical':\n                source = new fastmap.mapApi.source.ClassicalSource(key, config);\n                break;\n            case 'infocustomized':\n                source = new fastmap.mapApi.source.InfoSource(key, config);\n                break;\n            case 'deletioncustomized':\n                source = new fastmap.mapApi.source.DeletionLinkSource(key, config);\n                break;\n            case 'fccustomized':\n                source = new fastmap.mapApi.source.InfoSource(key, config);\n                break;\n            default:\n                source = null;\n                break;\n        }\n        return source;\n    },\n\n    _createPromises: function (tile, tileIndex, urlObject) {\n        this._uniqueFeatureType(urlObject);\n\n        var promises = [];\n        var keys = Object.getOwnPropertyNames(urlObject);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = urlObject[key];\n            if (!value.length) {\n                continue;\n            }\n            var source = this.getSource(key);\n            source.setFeatureTypes(value);\n            var url = source.createUrl(tile, tileIndex);\n            var parameter = source.createParameter(tile);\n            var promise = this._createAjaxPromise(tile, url, parameter, key);\n            promises.push(promise);\n        }\n\n        return promises;\n    },\n\n    _uniqueFeatureType: function (urlObject) {\n        var keys = Object.getOwnPropertyNames(urlObject);\n        for (var i = 0; i < keys.length; ++i) {\n            var key = keys[i];\n            var value = urlObject[key];\n            urlObject[key] = FM.Util.unique(value);\n        }\n    },\n\n    _createAjaxPromise: function (tile, url, requestParameter, additionParameter) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            var options = {\n                url: url,\n                requestParameter: requestParameter,\n                parameter: additionParameter,\n                timeout: 100000,\n                responseType: 'json',\n                // debug: true,\n                onSuccess: function (json, parameter) {\n                    if (json.errcode == 0) { // \n                        resolve({\n                            data: json.data,\n                            parameter: parameter\n                        });\n                    } else {\n                        reject({\n                            errmsg: json.errmsg,\n                            parameter: parameter\n                        });\n                    }\n                },\n                onFail: function (errmsg, parameter) {\n                    reject({\n                        errmsg: errmsg,\n                        parameter: parameter\n                    });\n                },\n                onError: function (errmsg, parameter) {\n                    reject({\n                        errmsg: errmsg,\n                        parameter: parameter\n                    });\n                },\n                onTimeout: function (errmsg, parameter) {\n                    reject({\n                        errmsg: errmsg,\n                        parameter: parameter\n                    });\n                }\n            };\n            var request = fastmap.mapApi.ajax.get(options);\n            self.tileRequestController.add(tile.fullName, request);\n        });\n\n        return promise;\n    },\n\n    _tilePromiseSuccess: function (tile, res) {\n        var allFeatures = {};\n        for (var i = 0; i < res.length; ++i) {\n            var item = res[i];\n            var data = item.data;\n            var parameter = item.parameter;\n            var source = this.getSource(parameter);\n            var features = source.parsor.transform(data, tile, source.parsor);\n            this._addFeaturesToDataSource(source, features, tile);\n        }\n    },\n\n    _addFeaturesToDataSource: function (source, features, tile) {\n        for (var i = 0; i < features.length; ++i) {\n            var feature = features[i];\n            source.add(feature, tile.fullName);\n        }\n    },\n\n    /**\n     * \n     */\n    destroy: function () {\n        fastmap.mapApi.source.SourceController.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.source.SourceController.instance) {\n                fastmap.mapApi.source.SourceController.instance =\n                    new fastmap.mapApi.source.SourceController();\n            }\n            return fastmap.mapApi.source.SourceController.instance;\n        }\n    }\n});\n","/**\n * Created by liwanchong on 2016/12/7.\n * \n */\nfastmap.mapApi.FeatureSelector = L.Class.extend({\n    options: {},\n\n    initialize: function () {\n        this.map = null;\n        this.sourceController = fastmap.mapApi.source.SourceController.getInstance();\n        this.sceneController = fastmap.mapApi.scene.SceneController.getInstance();\n        this.transform = new fastmap.mapApi.MecatorTranform();\n        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();\n        this.geojsonTransform = fastmap.mapApi.GeometryTransform.getInstance();\n    },\n\n    /**\n     * map\n     * @param map\n     */\n    setMap: function (map) {\n        this.map = map;\n    },\n\n    setOptions: function (options) {\n        FM.setOptions(this, options);\n    },\n\n    removeOption: function (key) {\n        if (this.options) {\n            delete this.options[key];\n        }\n    },\n\n    clearOptions: function () {\n        this.options = {};\n    },\n\n    /**\n     * geoemtrygeoLiveTypefeature\n     * geoLiveTypesundefinednull,\n     * feature[]\n     * @param geometry geojson\n     * @param geoLiveTypes geoLiveType\n     * @returns {*} feature\n     */\n    selectByGeometry: function (geometry, geoLiveTypes) {\n        var targetGeoLiveTypes = null;\n        if (!geoLiveTypes) {\n            targetGeoLiveTypes = this.getFeatureTypes();\n        } else {\n            targetGeoLiveTypes = FM.Util.unique(geoLiveTypes);\n        }\n\n        if (targetGeoLiveTypes.length === 0) {\n            return [];\n        }\n\n        // \n        this.geojsonTransform.setEnviroment(this.map, null, this.convertToPixelPoint);\n        var pixelSelectGeometry = this.geojsonTransform.convertGeometry(geometry);\n\n        // tiles\n        var tiles = this.getTilesFromGeometry(pixelSelectGeometry);\n\n        // tiles\n        var self = this;\n        var features = this.getFeaturesFromGeoLiveTypes(targetGeoLiveTypes, tiles);\n        if (features.length > 0) {\n            features = this.uniqueFeatureArray(features);\n\n            // \n            this.geojsonTransform.setEnviroment(this.map, null, this.convertToPixelPoint);\n            features = features.filter(function (feature) {\n                var pixelFeatureGeometry = this.geojsonTransform.convertGeometry(feature.geometry);\n                return this.isHitGeometry(pixelSelectGeometry, pixelFeatureGeometry);\n            }, this);\n\n            if (this.options.filter) {\n                features = features.filter(this.options.filter);\n            }\n        }\n\n        return features;\n    },\n\n    /**\n     * \n     * geoLiveTypeundefinednull,[]\n     * n[]\n     * ,\n     * @param geoLiveType geoLiveType\n     * @returns {*} \n     */\n    selectByGeoLiveType: function (geoLiveType) {\n        if (!geoLiveType) {\n            return [];\n        }\n\n        var features = this.getFeaturesFromGeoLiveTypes([geoLiveType], null);\n\n        if (this.options.filter) {\n            features = features.filter(this.options.filter);\n        }\n\n        return features;\n    },\n\n    /**\n     * id\n     * geoLiveTypeundefinednull,null\n     * featurenull\n     * @param id id\n     * @param geoLiveType geoLiveType\n     * @returns {*} \n     */\n    selectByFeatureId: function (id, geoLiveType) {\n        if (!id || !geoLiveType) {\n            return null;\n        }\n\n        var tileIds = this.getTileIdsFromFeatureId([geoLiveType], id);\n        var tiles = tileIds.map(function (tileId) {\n            return this.getTileInfoFromTileId(tileId);\n        }, this);\n        var features = this.getFeaturesFromGeoLiveTypes([geoLiveType], tiles);\n        features = features.filter(function (feature) {\n            return feature.properties.id === id;\n        }, this);\n\n        if (this.options.filter) {\n            features = features.filter(this.options.filter);\n        }\n\n        if (features.length === 0) {\n            return null;\n        }\n\n        return features[0];\n    },\n\n    /**\n     * funcgeoLiveTypefeature\n     * geoLiveTypeundefinednull,[]\n     * feature[]\n     * ,\n     * @param func ,feature,bool\n     * @param geoLiveType geoLiveType\n     * @returns {*} feature\n     */\n    selectByFunction: function (func, geoLiveType) {\n        if (!geoLiveType) {\n            return [];\n        }\n\n        var features = this.getFeaturesFromGeoLiveTypes([geoLiveType], null);\n        features = features.filter(function (feature) {\n            return func(feature);\n        }, this);\n\n        if (this.options.filter) {\n            features = features.filter(this.options.filter);\n        }\n\n        return features;\n    },\n\n    /**\n     * \n     * geoLiveTypeundefinednull,[]\n     * n[]\n     * ,\n     * @param tile tile\n     * @param geoLiveType geoLiveType\n     * @returns {*} \n     */\n    selectByTile: function (tile, geoLiveType) {\n        if (!geoLiveType || !tile) {\n            return [];\n        }\n\n        var sources = this.getSourcesByFeatureType(geoLiveType);\n\n        var features = [];\n        for (var i = 0; i < sources.length; i++) {\n            Array.prototype.push.apply(features, this.getFeaturesFromTile(sources[i], geoLiveType, tile));\n        }\n\n        if (this.options.filter) {\n            features = features.filter(this.options.filter);\n        }\n\n        return features;\n    },\n\n    getTilesFromGeometry: function (geometry) {\n        var bbox = this.geometryAlgorithm.bbox(geometry);\n        var tiles = this.getTilesFromBBox(bbox);\n        tiles = tiles.filter(function (tile) {\n            var tileBound = this.getTileBoundsByTile(tile);\n            return this.geometryAlgorithm.intersectsAndContains(tileBound, geometry);\n        }, this);\n        return tiles;\n    },\n\n    getTilesFromBBox: function (bbox) {\n        var zoom = this.map.getZoom();\n        var tiles = [];\n        var tileSize = 256;\n        var min = L.point(bbox.minX, bbox.minY).divideBy(tileSize)._floor();\n        var max = L.point(bbox.maxX, bbox.maxY).divideBy(tileSize)._floor();\n\n        for (var j = min.y; j <= max.y; j++) {\n            for (var i = min.x; i <= max.x; i++) {\n                var tile = this.createTile(i, j, zoom);\n                tiles.push(tile);\n            }\n        }\n        return tiles;\n    },\n\n    getTileBoundsByTile: function (tile) {\n        var bounds = {\n            type: 'Polygon',\n            coordinates: []\n        };\n\n        var min = L.point(tile.x, tile.y).multiplyBy(tile.tileSize);\n        var max = min.add([tile.tileSize, tile.tileSize]);\n\n        var coordinates = [];\n        coordinates.push([min.x, min.y]);\n        coordinates.push([max.x, min.y]);\n        coordinates.push([max.x, max.y]);\n        coordinates.push([min.x, max.y]);\n        coordinates.push([min.x, min.y]);\n\n        bounds.coordinates = [coordinates];\n\n        return bounds;\n    },\n\n    getTileIdsFromGeometry: function (geometry, zoom) {\n        var type = geometry.type;\n        switch (type) {\n            case 'Point':\n                return [this.getTileIdFromPoint(geometry.coordinates, zoom)];\n            case 'MultiPoint':\n            case 'LineString':\n                return this.getTileIdsFromLineString(geometry.coordinates, zoom);\n            case 'MultiLineString':\n            case 'Polygon':\n                return this.getTileIdsFromPolygon(geometry.coordinates, zoom);\n            case 'MultiPolygon':\n                return this.getTileIdsFromMultiPolygon(geometry.coordinates, zoom);\n            case 'GeometryCollection':\n                return this.getTileIdsFromGeometryCollection(geometry.geometries, zoom);\n            default:\n                return [];\n        }\n    },\n\n    getTileIdFromPoint: function (coordinates, zoom) {\n        var tileArr = this.transform.lonlat2Tile(coordinates[0], coordinates[1], zoom);\n        return tileArr[0] + ':' + tileArr[1];\n    },\n\n    getTileIdsFromLineString: function (coordinates, zoom) {\n        var tiles = [];\n        for (var i = 0; i < coordinates.length; ++i) {\n            var tile = this.getTileIdFromPoint(coordinates[i], zoom);\n            tiles.push(tile);\n        }\n        return tiles;\n    },\n\n    getTileIdsFromPolygon: function (coordinates, zoom) {\n        var tiles = [];\n        for (var i = 0; i < coordinates.length; ++i) {\n            var lineStringTiles = this.getTileIdsFromLineString(coordinates[i], zoom);\n            tiles = tiles.concat(lineStringTiles);\n        }\n        return tiles;\n    },\n\n    getTileIdsFromMultiPolygon: function (coordinates, zoom) {\n        var tiles = [];\n        for (var i = 0; i < coordinates.length; ++i) {\n            var polygonTiles = this.getTileIdsFromPolygon(coordinates[i], zoom);\n            tiles = tiles.concat(polygonTiles);\n        }\n        return tiles;\n    },\n\n    getTileIdsFromGeometryCollection: function (geometries, zoom) {\n        var tiles = [];\n        for (var i = 0; i < geometries.length; ++i) {\n            var multiGeometries = this.getTileIdsFromGeometry(geometries[i], zoom);\n            tiles = tiles.concat(multiGeometries);\n        }\n        return tiles;\n    },\n\n    getTileIdsFromFeatureId: function (geoLiveTypes, id) {\n        var tileIds = [];\n        var featureType,\n            sources;\n        var i,\n            j;\n        for (i = 0; i < geoLiveTypes.length; ++i) {\n            featureType = geoLiveTypes[i];\n            sources = this.getSourcesByFeatureType(featureType);\n            for (j = 0; j < sources.length; ++j) {\n                Array.prototype.push.apply(tileIds, sources[j].queryTilesById(featureType, id));\n            }\n        }\n\n        return tileIds;\n    },\n\n    getFeaturesFromGeoLiveTypes: function (geoLiveTypes, tiles) {\n        var features = [];\n        var featureType,\n            sources;\n        var i,\n            j;\n        for (i = 0; i < geoLiveTypes.length; ++i) {\n            featureType = geoLiveTypes[i];\n            sources = this.getSourcesByFeatureType(featureType);\n            for (j = 0; j < sources.length; ++j) {\n                Array.prototype.push.apply(features, this.getFeaturesFromTiles(sources[j], featureType, tiles));\n            }\n        }\n\n        features = this.uniqueFeatureArray(features);\n        return features;\n    },\n\n    getFeaturesFromTiles: function (source, geoLiveType, tiles) {\n        var tileIds = null;\n        if (!tiles) {\n            tileIds = source.queryTiles();\n        } else {\n            tileIds = tiles.map(function (tile) {\n                return tile.fullName;\n            }, this);\n        }\n\n        var features = [];\n        for (var i = 0; i < tileIds.length; ++i) {\n            var tileId = tileIds[i];\n            features = features.concat(this.getFeaturesFromTile(source, geoLiveType, tileId));\n        }\n        return features;\n    },\n\n    getFeaturesFromTile: function (source, geoLiveType, tileId) {\n        var resFeatures = [];\n        var features = source.queryFeaturesByType(geoLiveType, tileId);\n        var tileInfo = this.getTileInfoFromTileId(tileId);\n        this.geojsonTransform.setEnviroment(this.map, tileInfo, this.convertToLngLat);\n        for (var i = 0; i < features.length; ++i) {\n            var feature = features[i];\n            if (!this.geometryAlgorithm.isValidGeometry(feature.geometry)) {\n                continue;\n            }\n            // ,,\n            var cloneFeature = FM.Util.clone(feature);\n            cloneFeature.geometry = this.geojsonTransform.convertGeometry(cloneFeature.geometry);\n            resFeatures.push(cloneFeature);\n        }\n        return resFeatures;\n    },\n\n    getTileInfoFromTileId: function (tileId) {\n        var array = tileId.split(':');\n\n        var tile = this.createTile(array[0], array[1], array[2]);\n\n        return tile;\n    },\n\n    createTile: function (x, y, z) {\n        var tile = {\n            name: x + ':' + y,\n            fullName: x + ':' + y + ':' + z,\n            x: x,\n            y: y,\n            z: z,\n            tileSize: 256\n        };\n        return tile;\n    },\n\n    convertToLngLat: function (map, tileInfo, coordinates) {\n        var x = tileInfo.x * tileInfo.tileSize + coordinates[0];\n        var y = tileInfo.y * tileInfo.tileSize + coordinates[1];\n        var lnglat = map.unproject([x, y]);\n        return [lnglat.lng, lnglat.lat];\n    },\n\n    convertToPixelPoint: function (map, tileInfo, coordinates) {\n        var x = coordinates[0];\n        var y = coordinates[1];\n        var point = map.project([y, x]);\n        return [point.x, point.y];\n    },\n\n    isHitGeometry: function (selectGeometry, geometry) {\n        var type = selectGeometry.type;\n        switch (type) {\n            case 'Point':\n            case 'MultiPoint':\n                return this.geometryAlgorithm.isWithinDistance(selectGeometry, geometry, 5);\n            case 'LineString':\n            case 'MultiLineString':\n                return this.geometryAlgorithm.intersects(selectGeometry, geometry);\n\n            case 'Polygon':\n            case 'MultiPolygon':\n                return this.geometryAlgorithm.intersectsAndContains(selectGeometry, geometry);\n\n            case 'GeometryCollection':\n                return selectGeometry.geometries.some(function (item) {\n                    return this.isHitGeometry(selectGeometry, item);\n                }, this);\n            default:\n                throw new Error(':' + type);\n        }\n    },\n\n    uniqueFeatureArray: function (arr) {\n        var res = [];\n        var obj = {};\n        for (var i = 0; i < arr.length; i++) {\n            var feature = arr[i];\n            var key = feature.properties.geoLiveType + ':' + feature.properties.id;\n            if (!obj[key]) {\n                res.push(feature);\n                obj[key] = true;\n            }\n        }\n        return res;\n    },\n\n    getFeatureTypes: function () {\n        return this.sceneController.getLoadedFeatureTypes();\n    },\n\n    getSourcesByFeatureType: function (featureType) {\n        var sources = [];\n        var layers = this.sceneController.getLoadedLayersByFeatureType(featureType);\n        for (var i = 0; i < layers.length; i++) {\n            sources.push(this.sourceController.getSource(layers[i].getSourceName()));\n        }\n\n        return FM.Util.unique(sources);\n    },\n\n    /**\n     * \n     */\n    destroy: function () {\n        fastmap.mapApi.FeatureSelector.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.FeatureSelector.instance) {\n                fastmap.mapApi.FeatureSelector.instance =\n                    new fastmap.mapApi.FeatureSelector();\n            }\n            return fastmap.mapApi.FeatureSelector.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.symbol.Point = L.Class.extend({\n\n    initialize: function (x, y) {\n        this.type = 'Point';\n\n        this.x = x || 0;\n        this.y = y || 0;\n    },\n\n    /**\n     * \n     * @method clone\n     * @return fastmap.mapApi.symbol.Point \n     */\n    clone: function () {\n        var clonePt = new fastmap.mapApi.symbol.Point();\n        clonePt.x = this.x;\n        clonePt.y = this.y;\n\n        return clonePt;\n    },\n\n    /**\n     * \n     * @method distance\n     * @param p\n     * @return Number \n     */\n    distance: function (p) {\n        return Math.sqrt((this.x - p.x) * (this.x - p.x) + (this.y - p.y) * (this.y - p.y));\n    },\n\n    /**\n     * p\n     * @method minus\n     * @param p\n     * @return fastmap.mapApi.symbol.Vector p\n     */\n    minus: function (p) {\n        var x = this.x - p.x;\n        var y = this.y - p.y;\n        return new fastmap.mapApi.symbol.Vector(x, y);\n    },\n\n    /**\n     * \n     * \n     * @method crossMatrix\n     * @param m\n     * @return fastmap.mapApi.symbol.Point \n     */\n    crossMatrix: function (m) {\n        var tmpVec = [this.x, this.y, 1];\n        var newVec = new fastmap.mapApi.symbol.Point(0, 0);\n        newVec.x = (tmpVec[0] * m.data[0][0]) +\n                   (tmpVec[1] * m.data[1][0]) +\n                   (tmpVec[2] * m.data[2][0]);\n        newVec.y = (tmpVec[0] * m.data[0][1]) +\n                   (tmpVec[1] * m.data[1][1]) +\n                   (tmpVec[2] * m.data[2][1]);\n\n        return newVec;\n    },\n\n    /**\n     * \n     * @method equal\n     * @param p\n     * @return {boolean}\n     */\n    equal: function (p) {\n        if (this.x !== p.x) {\n            return false;\n        }\n\n        if (this.y !== p.y) {\n            return false;\n        }\n\n        return true;\n    },\n\n    /**\n     * \n     * \n     * \n     * @method plusVector\n     * @param v\n     * @return fastmap.mapApi.symbol.Point\n     */\n    plusVector: function (v) {\n        var point = new fastmap.mapApi.symbol.Point();\n        point.x = this.x + v.x;\n        point.y = this.y + v.y;\n\n        return point;\n    },\n\n    /**\n     * bound\n     * @returns bound\n     */\n    getBound: function () {\n        return new fastmap.mapApi.symbol.Bound(\n            this.x,\n            this.y,\n            this.x,\n            this.y\n        );\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\nfastmap.mapApi.symbol.Matrix = L.Class.extend({\n\n    initialize: function () {\n        this.data = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];\n    },\n\n    cross: function (other) {\n        var m = new fastmap.mapApi.symbol.Matrix();\n\n        m.data[0][0] = (this.data[0][0] * other.data[0][0]) +\n                       (this.data[0][1] * other.data[1][0]) +\n                       (this.data[0][2] * other.data[2][0]);\n        m.data[0][1] = (this.data[0][0] * other.data[0][1]) +\n                       (this.data[0][1] * other.data[1][1]) +\n                       (this.data[0][2] * other.data[2][1]);\n        m.data[0][2] = (this.data[0][0] * other.data[0][2]) +\n                       (this.data[0][1] * other.data[1][2]) +\n                       (this.data[0][2] * other.data[2][2]);\n\n        m.data[1][0] = (this.data[1][0] * other.data[0][0]) +\n                       (this.data[1][1] * other.data[1][0]) +\n                       (this.data[1][2] * other.data[2][0]);\n        m.data[1][1] = (this.data[1][0] * other.data[0][1]) +\n                       (this.data[1][1] * other.data[1][1]) +\n                       (this.data[1][2] * other.data[2][1]);\n        m.data[1][2] = (this.data[1][0] * other.data[0][2]) +\n                       (this.data[1][1] * other.data[1][2]) +\n                       (this.data[1][2] * other.data[2][2]);\n\n        m.data[2][0] = (this.data[2][0] * other.data[0][0]) +\n                       (this.data[2][1] * other.data[1][0]) +\n                       (this.data[2][2] * other.data[2][0]);\n        m.data[2][1] = (this.data[2][0] * other.data[0][1]) +\n                       (this.data[2][1] * other.data[1][1]) +\n                       (this.data[2][2] * other.data[2][1]);\n        m.data[2][2] = (this.data[2][0] * other.data[0][2]) +\n                       (this.data[2][1] * other.data[1][2]) +\n                       (this.data[2][2] * other.data[2][2]);\n\n        return m;\n    },\n\n    makeTranslate: function (x, y) {\n        var m = new fastmap.mapApi.symbol.Matrix();\n\n        m.data[0][0] = 1;\n        m.data[0][1] = 0;\n        m.data[0][2] = 0;\n\n        m.data[1][0] = 0;\n        m.data[1][1] = 1;\n        m.data[1][2] = 0;\n\n        m.data[2][0] = x;\n        m.data[2][1] = y;\n        m.data[2][2] = 1;\n\n        return m;\n    },\n\n    makeRotate: function (a) {\n        var arca = (Math.PI / 180) * a;\n        var m = new fastmap.mapApi.symbol.Matrix();\n\n        m.data[0][0] = Math.cos(arca);\n        m.data[0][1] = Math.sin(arca);\n        m.data[0][2] = 0;\n\n        m.data[1][0] = -Math.sin(arca);\n        m.data[1][1] = Math.cos(arca);\n        m.data[1][2] = 0;\n\n        m.data[2][0] = 0;\n        m.data[2][1] = 0;\n        m.data[2][2] = 1;\n\n        return m;\n    },\n\n    makeScale: function (sx, sy) {\n        var m = new fastmap.mapApi.symbol.Matrix();\n\n        m.data[0][0] = sx;\n        m.data[0][1] = 0;\n        m.data[0][2] = 0;\n\n        m.data[1][0] = 0;\n        m.data[1][1] = sy;\n        m.data[1][2] = 0;\n\n        m.data[2][0] = 0;\n        m.data[2][1] = 0;\n        m.data[2][2] = 1;\n\n        return m;\n    },\n\n    makeRotateToVector: function (v) {\n        var vY = new fastmap.mapApi.symbol.Vector(0, -1);\n        var angle = vY.angleTo(v);\n        var signal = vY.cross(v);\n\n        if (signal < 0) {\n            angle = -angle;\n        }\n\n        return this.makeRotate(angle);\n    }\n});\n","/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.symbol.Vector = L.Class.extend({\n\n    initialize: function (x, y) {\n        if (x === undefined) {\n            this.x = 0;\n        } else {\n            this.x = x;\n        }\n\n        if (y === undefined) {\n            this.y = 0;\n        } else {\n            this.y = y;\n        }\n    },\n\n    /**\n     * \n     * \n     * @method minus\n     * @param v\n     * @return fastmap.mapApi.symbol.Vector\n     */\n    minus: function (v) {\n        var x = this.x - v.x;\n        var y = this.y - v.y;\n        return new fastmap.mapApi.symbol.Vector(x, y);\n    },\n\n    /**\n     * \n     * \n     * @method plus\n     * @param v\n     * @return fastmap.mapApi.symbol.Vector\n     */\n    plus: function (v) {\n        var x = this.x + v.x;\n        var y = this.y + v.y;\n        return new fastmap.mapApi.symbol.Vector(x, y);\n    },\n\n    /**\n     * \n     * \n     * @method multiNumber\n     * @param n\n     * @return fastmap.mapApi.symbol.Vector\n     */\n    multiNumber: function (n) {\n        var x = this.x * n;\n        var y = this.y * n;\n        return new fastmap.mapApi.symbol.Vector(x, y);\n    },\n\n    /**\n     * \n     * \n     * @method dividNumber\n     * @param n\n     * @return fastmap.mapApi.symbol.Vector\n     */\n    dividNumber: function (n) {\n        var x = this.x / n;\n        var y = this.y / n;\n        return new fastmap.mapApi.symbol.Vector(x, y);\n    },\n\n    /**\n     * \n     * \n     * Z\n     * @method cross\n     * @param v\n     * @return Number\n     */\n    cross: function (v) {\n        return this.x * v.y - this.y * v.x;\n    },\n\n    /**\n     * \n     * \n     * @method dot\n     * @param v\n     * @return Number\n     */\n    dot: function (v) {\n        return this.x * v.x + this.y * v.y;\n    },\n\n    /**\n     * \n     * \n     * @method length2\n     * @return Number\n     */\n    length2: function () {\n        return this.x * this.x + this.y * this.y;\n    },\n\n    /**\n     * \n     * \n     * @method length\n     * @return Number\n     */\n    length: function () {\n        return Math.sqrt(this.length2());\n    },\n\n    /**\n     * \n     * @method normalize\n     */\n    normalize: function () {\n        var length = this.length();\n        this.x = this.x / length;\n        this.y = this.y / length;\n    },\n\n    /**\n     * \n     * \n     * \n     * @method crossMatrix\n     * @param m\n     * @return fastmap.mapApi.symbol.Vector\n     */\n    crossMatrix: function (m) {\n        var tmpVec = [this.x, this.y, 1];\n        var newVec = new fastmap.mapApi.symbol.Vector(0, 0);\n        newVec.x = tmpVec[0] * m.data[0][0] + tmpVec[1] * m.data[1][0] + tmpVec[2] * m.data[2][0];\n        newVec.y = tmpVec[0] * m.data[0][1] + tmpVec[1] * m.data[1][1] + tmpVec[2] * m.data[2][1];\n\n        return newVec;\n    },\n\n    /**\n     * \n     * \n     * @method angleTo\n     * @param v\n     * @return Number\n     */\n    angleTo: function (v) {\n        var cos = this.dot(v) / (this.length() * v.length());\n        var arcA = Math.acos(cos);\n\n        return arcA * 180 / Math.PI;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.LineSegment = L.Class.extend({\n\n    initialize: function (start, end) {\n        this.type = 'LineSegment';\n\n        this.start = start ? start.clone() : new fastmap.mapApi.symbol.Point();\n        this.end = end ? end.clone() : new fastmap.mapApi.symbol.Point();\n    },\n\n    /**\n     * \n     * @method clone\n     * @return fastmap.mapApi.symbol.LineSegment \n     */\n    clone: function () {\n        var cloneLineSegment = new fastmap.mapApi.symbol.LineSegment(this.start, this.end);\n        return cloneLineSegment;\n    },\n\n    /**\n     * \n     * @method length\n     * @return Number \n     */\n    length: function () {\n        return this.start.distance(this.end);\n    },\n\n    /**\n     * \n     * 0start.clone\n     * end.clone\n     * @method getPointByLength\n     * @param length \n     * @return Point \n     */\n    getPointByLength: function (length) {\n        var lineLength,\n            vector,\n            point;\n        if (length <= 0) {\n            return this.start.clone();\n        }\n\n        lineLength = this.length();\n\n        if (length >= lineLength) {\n            return this.end.clone();\n        }\n\n        vector = this.end.minus(this.start);\n        vector.normalize();\n\n        vector = vector.multiNumber(length);\n\n        point = this.start.plusVector(vector);\n\n        return point;\n    }\n\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.LineString = L.Class.extend({\n\n    initialize: function () {\n        this.type = 'LineString';\n\n        this.coordinates = [];\n    },\n\n    /**\n     * \n     * @method clone\n     * @return fastmap.mapApi.symbol.LineString \n     */\n    clone: function () {\n        var cloneLineString = new fastmap.mapApi.symbol.LineString();\n        for (var i = 0; i < this.coordinates.length; ++i) {\n            var point = this.coordinates[i].clone();\n            cloneLineString.coordinates.push(point);\n        }\n\n        return cloneLineString;\n    },\n\n    /**\n     * \n     * @method length\n     * @return Number \n     */\n    length: function () {\n        if (this.coordinates.length < 2) {\n            return 0;\n        }\n\n        var length = 0;\n\n        for (var i = 1; i < this.coordinates.length; ++i) {\n            var prePoint = this.coordinates[i - 1];\n            var point = this.coordinates[i];\n            length += point.distance(prePoint);\n        }\n\n        return length;\n    },\n\n    /**\n     * \n     * 0['start']\n     * ['end']\n     * ['vertex',i-1i+1 [xi, yi]]\n     * ['betweenVertex',i-1i [xn, yn]]\n     * @method splitGeometry\n     * @param length \n     * @return Array \n     */\n    getPointByLength: function (length) {\n        var result = [];\n\n        if (length <= 0) {\n            result.push('start');\n            return result;\n        }\n\n        var geometryLength = this.length();\n        if (length >= geometryLength) {\n            result.push('end');\n            return result;\n        }\n\n        var tmpLength = 0;\n\n        for (var i = 1; i < this.coordinates.length; ++i) {\n            var prePoint = this.coordinates[i - 1];\n\n            var curPoint = this.coordinates[i];\n            var segmentLength = curPoint.distance(prePoint);\n            if (tmpLength + segmentLength < length) {\n                tmpLength += segmentLength;\n            } else if (tmpLength + segmentLength === length) {\n                result.push('vertex');\n                result.push(i - 1);\n                result.push(i + 1);\n                result.push(curPoint.clone());\n                break;\n            } else {\n                var remainLength = length - tmpLength;\n                var line = new fastmap.mapApi.symbol.LineSegment(prePoint, curPoint);\n                var point = line.getPointByLength(remainLength);\n                result.push('betweenVertex');\n                result.push(i - 1);\n                result.push(i);\n                result.push(point);\n\n                break;\n            }\n        }\n\n        return result;\n    },\n\n    /**\n     * \n     *\n     * [LineString,null]\n     * 0[null,LineString]\n     * @method splitByLength\n     * @param length \n     * @return Array [subLineString1,subLineString2]\n     */\n    splitByLength: function (length) {\n        var result = this.getPointByLength(length);\n\n        var subLineString1;\n        var subLineString2;\n        switch (result[0]) {\n            case 'start':\n                subLineString1 = null;\n                subLineString2 = this.clone();\n                break;\n            case 'end':\n                subLineString1 = this.clone();\n                subLineString2 = null;\n                break;\n            case 'vertex':\n            case 'betweenVertex':\n                subLineString1 = this.slice(0, result[1] + 1);// 0result[1]\n                subLineString1.coordinates.push(result[3]);\n                subLineString2 = this.slice(result[2]);// result[1]\n                subLineString2.coordinates.unshift(result[3]);// subGeometry2result[2]\n                break;\n            default :\n                throw new Error('');\n        }\n\n        return [subLineString1, subLineString2];\n    },\n\n    /**\n     * LineString[startend\n     * endundefined[start,length - 1]\n     * @method slice\n     * @param start\n     * @param end\n     * @return fastmap.mapApi.symbol.LineString\n     */\n    slice: function (start, end) {\n        if (end === undefined || end > this.coordinates.length) {\n            end = this.coordinates.length;\n        }\n\n        if (start < 0) {\n            start = 0;\n        }\n\n        var newLineString = new fastmap.mapApi.symbol.LineString();\n        for (var i = start; i < end; ++i) {\n            newLineString.coordinates.push(this.coordinates[i].clone());\n        }\n\n        return newLineString;\n    },\n\n    /**\n     * LineString\n     * @method equal\n     * @param lineString\n     * @return {boolean}\n     */\n    equal: function (lineString) {\n        if (this.coordinates.length !== lineString.coordinates.length) {\n            return false;\n        }\n\n        for (var i = 0; i < this.coordinates.length; ++i) {\n            if (!this.coordinates[i].equal(lineString.coordinates[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    },\n\n    /**\n     * linestring\n     * @returns {fastmap.mapApi.symbol.LineString}\n     */\n    reverse: function () {\n        var newLineString = this.clone();\n        newLineString.coordinates.reverse();\n        return newLineString;\n    },\n\n    /**\n     * LineString\n     * @returns {boolean}\n     */\n    isClosed: function () {\n        var length = this.coordinates.length;\n        return this.coordinates[0].equal(this.coordinates[length - 1]);\n    },\n\n    /**\n     * bound\n     * @returns bound\n     */\n    getBound: function () {\n        var bound = new fastmap.mapApi.symbol.Bound();\n        for (var i = 0; i < this.coordinates.length; ++i) {\n            var point = this.coordinates[i];\n            var pointBound = point.getBound();\n            bound = bound.extend(pointBound);\n        }\n\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.Polygon = L.Class.extend({\n\n    initialize: function () {\n        this.type = 'Polygon';\n\n        this.coordinates = [];\n    },\n\n    /**\n     * \n     * @method clone\n     * @return fastmap.mapApi.symbol.LineString \n     */\n    clone: function () {\n        var clonePolygon = new fastmap.mapApi.symbol.Polygon();\n        for (var i = 0; i < this.coordinates.length; ++i) {\n            var lineString = this.coordinates[i].clone();\n            clonePolygon.coordinates.push(lineString);\n        }\n\n        return clonePolygon;\n    },\n\n    /**\n     * \n     * @method length\n     * @return Number \n     */\n    length: function () {\n        if (this.coordinates.length === 0) {\n            return 0;\n        }\n\n        var length = 0;\n\n        for (var i = 0; i < this.coordinates.length; ++i) {\n            var lineString = this.coordinates[i];\n            length += lineString.length();\n        }\n\n        return length;\n    },\n\n    /**\n     * Polygon\n     * @method equal\n     * @param polygon\n     * @return {boolean}\n     */\n    equal: function (polygon) {\n        if (this.coordinates.length !== polygon.coordinates.length) {\n            return false;\n        }\n\n        for (var i = 0; i < this.coordinates.length; ++i) {\n            if (!this.coordinates[i].equal(polygon.coordinates[i])) {\n                return false;\n            }\n        }\n\n        return true;\n    },\n\n    /**\n     * bound\n     * @returns bound\n     */\n    getBound: function () {\n        var bound = new fastmap.mapApi.symbol.Bound();\n        for (var i = 0; i < this.coordinates.length; ++i) {\n            var lineString = this.coordinates[i];\n            var lineStringBound = lineString.getBound();\n            bound = bound.extend(lineStringBound);\n        }\n\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.Bound = L.Class.extend({\n    initialize: function (left, top, right, buttom) {\n        this.left = left || 0;\n        this.top = top || 0;\n        this.right = right || 0;\n        this.buttom = buttom || 0;\n    },\n\n    extend: function (bound) {\n        var left = this.left < bound.left ? this.left : bound.left;\n        var top = this.top < bound.top ? this.top : bound.top;\n        var right = this.right > bound.right ? this.right : bound.right;\n        var buttom = this.buttom > bound.buttom ? this.buttom : bound.buttom;\n        var newBound = new fastmap.mapApi.symbol.Bound(left, top, right, buttom);\n        return newBound;\n    },\n\n    getSize: function () {\n        return {\n            width: this.right - this.left,\n            height: this.buttom - this.top\n        };\n    },\n\n    getCenter: function () {\n        var size = this.getSize();\n        var halfWidth = size.width / 2;\n        var halfHeight = size.height / 2;\n        var cX = this.left + halfWidth;\n        var cY = this.top + halfHeight;\n        var center = new fastmap.mapApi.symbol.Point(cX, cY);\n        return center;\n    },\n\n    /**\n     * boundLineString\n     * LineString\n     * @param bound\n     */\n    toLineString: function () {\n        var coordinates = [];\n        coordinates.push([this.left, this.top]);\n        coordinates.push([this.right, this.top]);\n        coordinates.push([this.right, this.buttom]);\n        coordinates.push([this.left, this.buttom]);\n        coordinates.push([this.left, this.top]);\n\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var lineString = gf.createLineString(coordinates);\n        return lineString;\n    }\n});\n","/**\n * Created by xujie on 2016/5/12 0012.\n */\n\n/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.symbol.Template = L.Class.extend({\n\n    initialize: function (pattern, lineString, startOffset) {\n        if (pattern !== undefined) {\n            this.pattern = pattern;\n        } else {\n            this.pattern = [];\n        }\n\n        if (lineString !== undefined) {\n            this.lineString = lineString;\n        } else {\n            this.lineString = null;\n        }\n\n        if (startOffset !== undefined) {\n            this.startOffset = startOffset;\n        } else {\n            this.startOffset = 0;\n        }\n    },\n\n    /**\n     * \n     * pattern0[LineString]\n     * 2[]\n     * @method getSegments\n     * @return Array [lineString,lineString,...]\n     */\n    getSegments: function () {\n        var segments = [];\n\n        if (this.lineString.coordinates.length < 2) {\n            return segments;\n        }\n\n        if (this.pattern.length === 0) {\n            segments.push(this.lineString.clone());\n            return segments;\n        }\n\n        // pattern\n        var newPattern = this.processPattern(this.pattern);\n\n        // pattern\n        var patternLength = this.getPatternLength(newPattern);\n\n        // \n        var lineString = this.cutStartOffset(this.startOffset, this.lineString);\n\n        if (!lineString) {\n            return [];\n        }\n\n        // \n        segments = this.breakGeometry(patternLength, lineString);\n\n        return segments;\n    },\n\n    /**\n     * segmentpattern\n     * segment\n     * segmentpattern\n     * \n     * pattern0\n     * @method getMarks\n     * @param segment \n     * @return Array \n     */\n    getMarks: function (segment) {\n        var pattern = this.processPattern(this.pattern);\n\n        var marks = [];\n        if (pattern.length === 0) {\n            marks.push(segment);\n            return marks;\n        }\n\n        var sourceSegment = segment;\n        for (var i = 0; i < pattern.length; ++i) {\n            var subSegments = sourceSegment.splitByLength(pattern[i]);\n            if (i % 2 === 0 && subSegments[0] !== null) {\n                marks.push(subSegments[0]);// subSegmentmark\n            }\n\n            // segmentpatternsubSegments[1][]\n            if (subSegments[1] === null) {\n                break;\n            }\n\n            sourceSegment = subSegments[1];\n        }\n\n        return marks;\n    },\n\n    /**\n     * startOffset.\n     * \n     * startOffset0,\n     * startOffsetnull\n     * @param startOffset\n     * @param lineString\n     * @returns \n     */\n    cutStartOffset: function (startOffset, lineString) {\n        // geometry\n        var geometryLength = lineString.length();\n\n        var segments = [];\n\n        // geometry\n        if (startOffset === 0) {\n            var newGeometry = lineString.clone();// geometry\n            return newGeometry;\n        }\n\n        if (geometryLength <= startOffset) {\n            return null;\n        }\n\n        // \n        var subLineStrings = lineString.splitByLength(startOffset);\n        return subLineStrings[1];\n    },\n\n    /**\n     * pattern\n     * length\n     * segments\n     * @method breakGeometry\n     * @param length \n     * @param lineString \n     * @returns segments \n     */\n    breakGeometry: function (length, lineString) {\n        // geometry\n        var geometryLength = lineString.length();\n\n        var segments = [];\n\n        // geometry\n        if (geometryLength <= length) {\n            var newGeometry = lineString.clone();// geometry\n            return [newGeometry];\n        }\n\n        // \n        var i = 1;\n        var tmpLineString = lineString;\n        while (geometryLength > length * i) {\n            var subLineStrings = tmpLineString.splitByLength(length);\n            segments.push(subLineStrings[0]);\n            tmpLineString = subLineStrings[1];\n            ++i;\n        }\n\n        // \n        segments.push(tmpLineString);\n\n        return segments;\n    },\n\n    /**\n     * \n     * @method getPatternLength\n     * @param patternArray\n     * @return number pattern\n     */\n    getPatternLength: function (patternArray) {\n        var length = 0;\n\n        for (var i = 0; i < patternArray.length; ++i) {\n            length += patternArray[i];\n        }\n\n        return length;\n    },\n\n    /**\n     * \n     * \n     * @method processPattern\n     * @param patternArray\n     */\n    processPattern: function (patternArray) {\n        if (patternArray.length % 2 !== 0) {\n            return patternArray.concat(patternArray);\n        }\n\n        return patternArray;\n    }\n});\n\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.Transformation = L.Class.extend({\n    initialize: function () {\n        this.matrix = new fastmap.mapApi.symbol.Matrix();\n        this.finalMatrix = this.matrix;\n        this.stack = [];\n    },\n\n    /**\n     * \n     */\n    resetTransform: function () {\n        this.finalMatrix = this.matrix;\n    },\n\n    /**\n     * \n     * @param geometry\n     * @returns {*}\n     */\n    transform: function (geometry) {\n        var type = geometry.type;\n        switch (type) {\n            case 'Point':\n                geometry = geometry.crossMatrix(this.finalMatrix);\n                return geometry;\n            case 'LineString':\n                geometry.coordinates = geometry.coordinates.map(function (point) {\n                    return this.transform(point);\n                }, this);\n                return geometry;\n            case 'Polygon':\n                geometry.coordinates = geometry.coordinates.map(function (lineString) {\n                    return lineString.coordinates.map(function (point) {\n                        return this.transform(point);\n                    }, this);\n                }, this);\n                return geometry;\n            default:\n                throw new Error(':' + type);\n        }\n    },\n\n    /**\n     * \n     * @param x x\n     * @param y y\n     */\n    translate: function (x, y) {\n        this.finalMatrix = this.matrix.makeTranslate(x, y).cross(this.finalMatrix);\n    },\n\n    /**\n     * \n     * @param a \n     */\n    rotate: function (a) {\n        this.finalMatrix = this.matrix.makeRotate(a).cross(this.finalMatrix);\n    },\n\n    /**\n     * \n     * @param x x\n     * @param y y\n     */\n    scale: function (x, y) {\n        this.finalMatrix = this.matrix.makeScale(x, y).cross(this.finalMatrix);\n    },\n\n    /**\n     * \n     */\n    save: function () {\n        this.stack.push(this.finalMatrix);\n    },\n\n    /**\n     * \n     */\n    restore: function () {\n        if (this.stack.length > 0) {\n            this.finalMatrix = this.stack.pop();\n            return;\n        }\n\n        this.finalMatrix = this.matrix;\n    },\n\n    destroy: function () {\n        fastmap.mapApi.symbol.Transformation.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.symbol.Transformation.instance) {\n                fastmap.mapApi.symbol.Transformation.instance =\n                    new fastmap.mapApi.symbol.Transformation();\n            }\n            return fastmap.mapApi.symbol.Transformation.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.Symbol = L.Class.extend({\n    initialize: function (options) {\n        this.type = '';\n        this.name = '';\n        this.geometry = null;\n    },\n\n    /**\n     * \n     * @param ctx \n     */\n    draw: function (ctx) {\n        return;\n    },\n\n    /**\n     * json\n     * @param json\n     */\n    fromJson: function (json) {\n        this.setValue('type', json.type);\n        this.setValue('name', json.name);\n    },\n\n    /**\n     * json\n     * @returns {} json\n     */\n    toJson: function () {\n        return {\n            type: this.type,\n            name: this.name\n        };\n    },\n\n    /**\n     * LineString,\n     * \n     * @param ctx \n     * @param geometry LineString\n     */\n    drawLineString: function (ctx, geometry) {\n        if (geometry.coordinates.length > 0) {\n            ctx.moveTo(geometry.coordinates[0].x, geometry.coordinates[0].y);\n            for (var i = 1; i < geometry.coordinates.length; ++i) {\n                ctx.lineTo(geometry.coordinates[i].x, geometry.coordinates[i].y);\n            }\n        }\n    },\n\n    /**\n     * \n     * \n     * \n     * @param property\n     * @param json\n     */\n    setValue: function (property, value) {\n        if (!this.hasOwnProperty(property)) {\n            return;\n        }\n\n        // 0\n        if (value === undefined || value === null) {\n            return;\n        }\n\n        this[property] = value;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.MarkerSymbol = fastmap.mapApi.symbol.Symbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.Symbol.prototype.initialize.apply(this, arguments);\n\n        this.color = 'black';\n        this.opacity = 1;\n        this.offsetX = 0;\n        this.offsetY = 0;\n        this.angle = 0;\n        this.outLine = null;\n\n        // \n        this.resetTransform = true;\n\n        this.transformation = fastmap.mapApi.symbol.Transformation.getInstance();\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.Symbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('color', json.color);\n        this.setValue('opacity', json.opacity);\n        this.setValue('offsetX', json.offsetX);\n        this.setValue('offsetY', json.offsetY);\n        this.setValue('angle', json.angle);\n        this.setValue('outLine', json.outLine);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.Symbol.prototype.toJson.apply(this, arguments);\n\n        json.color = this.color;\n        json.opacity = this.opacity;\n        json.offsetX = this.offsetX;\n        json.offsetY = this.offsetY;\n        json.angle = this.angle;\n        json.outLine = this.outLine;\n        return json;\n    },\n\n    /**\n     * \n     * @param ctx\n     */\n    draw: function (ctx) {\n        if (!this.geometry) {\n            return;\n        }\n\n        // \n        this.save(ctx);\n\n        this.setTransformation(ctx);\n\n        this.drawSymbol(ctx);\n\n        // \n        this.restore(ctx);\n    },\n\n    /**\n     * \n     */\n    setTransformation: function (ctx) {\n        if (this.resetTransform) {\n            this.transformation.resetTransform();\n            ctx.resetTransform();\n        }\n\n        this.transformation.translate(this.geometry.x, this.geometry.y);\n        this.transformation.translate(this.offsetX, this.offsetY);\n        this.transformation.rotate(this.angle);\n\n        ctx.translate(this.geometry.x, this.geometry.y);\n        ctx.translate(this.offsetX, this.offsetY);\n        ctx.rotate(this.angle * Math.PI / 180);\n    },\n\n    /**\n     * \n     */\n    save: function (ctx) {\n        this.transformation.save();\n        ctx.save();\n    },\n\n    /**\n     * \n     */\n    restore: function (ctx) {\n        this.transformation.restore();\n        ctx.restore();\n    },\n\n    /**\n     * ,\n     * @param ctx\n     */\n    drawSymbol: function (ctx) {\n        // \n        this.drawContent(ctx);\n\n        // \n        if (this.outLine) {\n            this.drawOutLine(ctx);\n        }\n    },\n\n    /**\n     * \n     * @param ctx\n     */\n    drawContent: function (ctx) {\n        return;\n    },\n\n    /**\n     * \n     * @param ctx\n     */\n    drawOutLine: function (ctx) {\n        // \n        ctx.strokeStyle = this.outLine.color;\n        ctx.lineWidth = this.outLine.width;\n\n        // \n        var geometry = this.getOutLineGeometry();\n\n        ctx.beginPath();\n\n        // \n        this.drawLineString(ctx, geometry);\n        ctx.closePath();\n\n        ctx.stroke();\n    },\n\n    /**\n     * \n     * @returns {null}\n     */\n    getContentGeometry: function () {\n        return null;\n    },\n\n    /**\n     * \n     * @returns {*}\n     */\n    getOutLineGeometry: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n\n        // \n        var bound = this.getOriginBound();\n        var lineString = bound.toLineString();\n\n        return lineString;\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        return null;\n    },\n\n    /**\n     * \n     * @returns {*}\n     */\n    getBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n\n        // \n        var originBound = this.getOriginBound();\n        var lineString = originBound.toLineString();\n\n        // \n        var geomtry = this.transformation.transform(lineString);\n\n        // \n        var bound = geomtry.getBound();\n\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CircleMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CircleMarkerSymbol';\n\n        this.radius = 10;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('radius', json.radius);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.radius = this.radius;\n\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.fillStyle = this.color;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        ctx.beginPath();\n        ctx.arc(0, 0, this.radius, 0, 2 * Math.PI, false);\n        ctx.fill();\n    },\n\n    drawOutLine: function (ctx) {\n        // \n        ctx.lineWidth = this.outLine.width;\n        ctx.strokeStyle = this.outLine.color;\n\n        // \n        ctx.stroke();\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, this.width, this.height);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.SquareMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'SquareMarkerSymbol';\n\n        this.size = 10;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('size', json.size);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.size = this.size;\n\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.fillStyle = this.color;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        var geometry = this.getContentGeometry();\n\n        ctx.beginPath();\n        // \n        this.drawLineString(ctx, geometry);\n        ctx.closePath();\n\n        ctx.fill();\n    },\n\n    drawOutLine: function (ctx) {\n        // \n        ctx.lineWidth = this.outLine.width;\n        ctx.strokeStyle = this.outLine.color;\n\n        // \n        ctx.stroke();\n    },\n\n    getContentGeometry: function () {\n        return this.getOriginBound().toLineString();\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, this.size, this.size);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.RectangleMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'RectangleMarkerSymbol';\n\n        this.width = 10;\n        this.height = 10;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('width', json.width);\n        this.setValue('height', json.height);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.width = this.width;\n        json.height = this.height;\n\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.fillStyle = this.color;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        var geometry = this.getContentGeometry();\n\n        ctx.beginPath();\n        // \n        this.drawLineString(ctx, geometry);\n        ctx.closePath();\n\n        ctx.fill();\n    },\n\n    drawOutLine: function (ctx) {\n        // \n        ctx.lineWidth = this.outLine.width;\n        ctx.strokeStyle = this.outLine.color;\n\n        // \n        ctx.stroke();\n    },\n\n    getContentGeometry: function () {\n        return this.getOriginBound().toLineString();\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, this.width, this.height);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CrossMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CrossMarkerSymbol';\n\n        this.size = 10;\n        this.width = 1;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('size', json.size);\n        this.setValue('width', json.width);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.size = this.size;\n        json.width = this.width;\n\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        var geometry = this.getContentGeometry();\n\n        // \n        ctx.beginPath();\n        ctx.moveTo(geometry.coordinates[0].x, geometry.coordinates[0].y);\n        ctx.lineTo(geometry.coordinates[1].x, geometry.coordinates[1].y);\n        ctx.moveTo(geometry.coordinates[2].x, geometry.coordinates[2].y);\n        ctx.lineTo(geometry.coordinates[3].x, geometry.coordinates[3].y);\n        ctx.stroke();\n    },\n\n    getContentGeometry: function () {\n        // \n        var coordinates = [];\n        coordinates.push([-this.size / 2, 0]);\n        coordinates.push([this.size / 2, 0]);\n        coordinates.push([0, -this.size / 2]);\n        coordinates.push([0, this.size / 2]);\n\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var geometry = gf.createLineString(coordinates);\n        return geometry;\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, this.size, this.size);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.TiltedCrossMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'TiltedCrossMarkerSymbol';\n\n        this.size = 10;\n        this.width = 1;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('size', json.size);\n        this.setValue('width', json.width);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.size = this.size;\n        json.width = this.width;\n\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        var geometry = this.getContentGeometry();\n\n        // \n        ctx.beginPath();\n        ctx.moveTo(geometry.coordinates[0].x, geometry.coordinates[0].y);\n        ctx.lineTo(geometry.coordinates[1].x, geometry.coordinates[1].y);\n        ctx.moveTo(geometry.coordinates[2].x, geometry.coordinates[2].y);\n        ctx.lineTo(geometry.coordinates[3].x, geometry.coordinates[3].y);\n        ctx.stroke();\n    },\n\n    getContentGeometry: function () {\n        // \n        var coordinates = [];\n        coordinates.push([-this.size / 2, -this.size / 2]);\n        coordinates.push([this.size / 2, this.size / 2]);\n        coordinates.push([-this.size / 2, this.size / 2]);\n        coordinates.push([this.size / 2, -this.size / 2]);\n\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var geometry = gf.createLineString(coordinates);\n        return geometry;\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, this.size, this.size);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.TriangleMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'TriangleMarkerSymbol';\n\n        this.width = 10;\n        this.height = 20;\n        // \n        this.sunken = 0;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('width', json.width);\n        this.setValue('height', json.height);\n        this.setValue('sunken', json.sunken);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.width = this.width;\n        json.height = this.height;\n        json.sunken = this.sunken;\n\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.fillStyle = this.color;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        var geometry = this.getContentGeometry();\n\n        ctx.beginPath();\n\n        // \n        this.drawLineString(ctx, geometry);\n        ctx.closePath();\n\n        ctx.fill();\n    },\n\n    drawOutLine: function (ctx) {\n        // \n        ctx.lineWidth = this.outLine.width;\n        ctx.strokeStyle = this.outLine.color;\n\n        // \n        ctx.stroke();\n    },\n\n    getContentGeometry: function () {\n        // \n        var fPoint = new fastmap.mapApi.symbol.Point(0, -this.height / 2);\n        var vY = new fastmap.mapApi.symbol.Vector(0, 1);\n        var matrix = new fastmap.mapApi.symbol.Matrix();\n\n        // yvLvR\n        var angle = Math.atan(this.width / 2 / this.height) * 180 / Math.PI;\n        var vL = vY.crossMatrix(matrix.makeRotate(-angle));\n        var vR = vY.crossMatrix(matrix.makeRotate(angle));\n\n        // vLvR\n        var triangleLength = Math.sqrt(this.width / 2 * this.width / 2 + this.height * this.height);\n        vL = vL.multiNumber(triangleLength);\n        vR = vR.multiNumber(triangleLength);\n\n        // vLvR\n        var lPoint = fPoint.plusVector(vL);\n        var rPoint = fPoint.plusVector(vR);\n\n        // 0length\n        // \n        var remainder = this.height - this.sunken;\n        if (this.sunken < 0 || this.sunken > this.height) {\n            remainder = this.height;\n        }\n\n        // \n        var vC = vY.multiNumber(remainder);\n        var cPoint = fPoint.plusVector(vC);\n\n        // \n        var geometry = new fastmap.mapApi.symbol.LineString();\n        geometry.coordinates.push(fPoint);\n        geometry.coordinates.push(lPoint);\n        geometry.coordinates.push(cPoint);\n        geometry.coordinates.push(rPoint);\n        geometry.coordinates.push(fPoint);\n\n        return geometry;\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, this.width, this.height);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/11/26.\n */\nfastmap.mapApi.symbol.ImageLoader = L.Class.extend({\n\n    initialize: function (urls) {\n        this.urls = urls;\n        this.resourceFactory = fastmap.mapApi.symbol.ResourceFactory.getInstance();\n    },\n\n    load: function (success, error) {\n        var self = this;\n        var promise = new Promise(function (resolve, reject) {\n            if (self.urls.length === 0) {\n                resolve();\n                return;\n            }\n\n            var promises = self.getPromises();\n\n            if (promises.length === 0) {\n                resolve();\n                return;\n            }\n\n            Promise.all(promises)\n                .then(function (res) {\n                    self.addToResourceFactory(res, self.resourceFactory);\n                    resolve();\n                })\n                .catch(function (e) {\n                    FM.Util.log(e);\n                    reject(e);\n                });\n        });\n\n        return promise;\n    },\n\n    getPromises: function () {\n        var promises = [];\n        for (var i = 0; i < this.urls.length; ++i) {\n            var url = this.urls[i];\n            if (this.resourceFactory.containResource(url)) {\n                continue;\n            }\n            promises.push(this.loadImage(url));\n        }\n        return promises;\n    },\n\n    loadImage: function (url) {\n        var promise = new Promise(function (resolve, reject) {\n            var image = new Image();\n            image.onload = function () {\n                var res = {\n                    url: url,\n                    image: image\n                };\n                resolve(res);\n            };\n            image.onerror = function () {\n                var res = {\n                    url: url,\n                    image: null\n                };\n                resolve(res);\n            };\n            image.src = url;\n        });\n\n        return promise;\n    },\n\n    addToResourceFactory: function (resources, factory) {\n        for (var i = 0; i < resources.length; ++i) {\n            var resource = resources[i];\n            var key = resource.url;\n            var value = resource.image;\n            if (!key || !value) {\n                return;\n            }\n\n            factory.add(key, value);\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.ImageMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'ImageMarkerSymbol';\n\n        this.url = '';\n        this.width = 10;\n        this.height = 10;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('url', json.url);\n        this.setValue('width', json.width);\n        this.setValue('height', json.height);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.url = this.url;\n        json.width = this.width;\n        json.height = this.height;\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.url) {\n            return;\n        }\n\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);\n    },\n\n    drawContent: function (ctx) {\n        var resourceFactory = fastmap.mapApi.symbol.ResourceFactory.getInstance();\n        var image = resourceFactory.getResource(this.url);\n        if (!image) {\n            return;\n        }\n\n        // \n        ctx.globalAlpha = this.opacity;\n\n        // \n        ctx.drawImage(image, -this.width / 2, -this.height / 2, this.width, this.height);\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, this.width, this.height);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.MultiImageMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'MultiImageMarkerSymbol';\n\n        this.width = 10;\n        this.height = 10;\n        this.hGap = 0;\n        this.vGap = 0;\n        this.urls = [];\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('width', json.width);\n        this.setValue('height', json.height);\n        this.setValue('hGap', json.hGap);\n        this.setValue('vGap', json.vGap);\n        this.setValue('urls', json.urls);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.width = this.width;\n        json.height = this.height;\n        json.hGap = this.hGap;\n        json.vGap = this.vGap;\n        json.urls = this.urls;\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.urls) {\n            return;\n        }\n\n        if (this.urls.length === 0) {\n            return;\n        }\n\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);\n    },\n\n    drawContent: function (ctx) {\n        var geometries = this.getGeometries();\n\n        var json = {\n            type: 'ImageMarkerSymbol',\n            width: this.width,\n            height: this.height\n        };\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        var symbol = symbolFactory.createSymbol(json);\n        symbol.resetTransform = false;\n\n        for (var i = 0; i < this.urls.length; ++i) {\n            for (var j = 0; j < this.urls[i].length; ++j) {\n                var geometry = geometries[i][j];\n                var url = this.urls[i][j];\n                if (!url) {\n                    continue;\n                }\n                this.drawImage(url, geometry, ctx, symbol);\n            }\n        }\n\n        symbol.resetTransform = true;\n    },\n\n    getGeometries: function () {\n        var info = this.getRowAndColumn();\n        var actualHGap = this.hGap ? this.hGap : this.width;\n        var actualVGap = this.vGap ? this.vGap : this.height;\n        var totalWidth = this.width + actualHGap * (info.col - 1);\n        var totalHeight = this.height + actualVGap * (info.row - 1);\n        var startX = -totalWidth / 2;\n        var startY = -totalHeight / 2;\n        var geometries = [];\n        for (var i = 0; i < info.row; ++i) {\n            var y = startY + actualVGap * i + this.height / 2;\n            var row = [];\n            for (var j = 0; j < info.col; ++j) {\n                var x = startX + actualHGap * j + this.width / 2;\n                var geometry = new fastmap.mapApi.symbol.Point(x, y);\n                row.push(geometry);\n            }\n            geometries.push(row);\n        }\n\n        return geometries;\n    },\n\n    getRowAndColumn: function () {\n        var row = this.urls.length;\n        var col = 0;\n        for (var i = 0; i < this.urls.length; ++i) {\n            var temCol = this.urls[i].length;\n            if (col < temCol) {\n                col = temCol;\n            }\n        }\n\n        return {\n            row: row,\n            col: col\n        };\n    },\n\n    drawImage: function (url, geometry, ctx, symbol) {\n        symbol.url = url;\n        symbol.geometry = geometry;\n        symbol.draw(ctx);\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var info = this.getRowAndColumn();\n        var actualHGap = this.hGap ? this.hGap : this.width;\n        var actualVGap = this.vGap ? this.vGap : this.height;\n        var totalWidth = this.width + actualHGap * (info.col - 1);\n        var totalHeight = this.height + actualVGap * (info.row - 1);\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, totalWidth, totalHeight);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.TextMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'TextMarkerSymbol';\n\n        this.text = '';\n        this.font = '';\n        this.size = 10;\n        this.align = 'center';\n        this.baseline = 'middle';\n        this.direction = 'ltr';\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('text', json.text);\n        this.setValue('font', json.font);\n        this.setValue('size', json.size);\n        this.setValue('align', json.align);\n        this.setValue('baseline', json.baseline);\n        this.setValue('direction', json.direction);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.text = this.text;\n        json.font = this.font;\n        json.size = this.size;\n        json.align = this.align;\n        json.baseline = this.baseline;\n        json.direction = this.direction;\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (this.text === null || this.text === undefined || this.text.length === 0) {\n            return;\n        }\n\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.font = this.size + 'px ' + this.font;\n        ctx.textAlign = this.align;\n        ctx.textBaseline = this.baseline;\n        ctx.direction = this.direction;\n        ctx.fillStyle = this.color;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        ctx.fillText(this.text, 0, 0);\n    },\n\n    /**\n     * measureText\n     * measureTextwidth\n     * @returns {*|TextMetrics}\n     */\n    measureText: function () {\n        var canvas = document.createElement('canvas');\n        var ctx = canvas.getContext('2d');\n        ctx.save();\n\n        ctx.font = this.size + 'px ' + this.font;\n        ctx.textAlign = this.align;\n        ctx.textBaseline = this.baseline;\n        ctx.direction = this.direction;\n\n        var m = ctx.measureText(this.text);\n        var width = m.width / 2;\n        var height = this.size / 2;\n        var newM = {\n            width: m.width,\n            actualBoundingBoxLeft: m.actualBoundingBoxLeft !== undefined ?\n                m.actualBoundingBoxLeft : width,\n            actualBoundingBoxRight: m.actualBoundingBoxRight !== undefined ?\n                m.actualBoundingBoxRight : width,\n            actualBoundingBoxAscent: m.actualBoundingBoxAscent !== undefined ?\n                m.actualBoundingBoxAscent : height,\n            actualBoundingBoxDescent: m.actualBoundingBoxDescent !== undefined ?\n                m.actualBoundingBoxDescent : height\n        };\n\n        ctx.restore();\n\n        return newM;\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        var m = this.measureText();\n        var width = m.actualBoundingBoxLeft + m.actualBoundingBoxRight;\n        var height = m.actualBoundingBoxAscent + m.actualBoundingBoxDescent;\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var bound = gf.createBound(null, width, height);\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CompositeMarkerSymbol = fastmap.mapApi.symbol.MarkerSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.MarkerSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CompositeMarkerSymbol';\n\n        this.symbols = [];\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.fromJson.apply(this, arguments);\n\n        if (!json.symbols) {\n            return;\n        }\n\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        for (var i = 0; i < json.symbols.length; ++i) {\n            this.symbols.push(symbolFactory.createSymbol(json.symbols[i]));\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.MarkerSymbol.prototype.toJson.apply(this, arguments);\n\n        json.symbols = [];\n        for (var i = 0; i < this.symbols.length; ++i) {\n            json.symbols.push(this.symbols[i].toJson());\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.symbols.length) {\n            return;\n        }\n\n        if (this.symbols.length === 0) {\n            return;\n        }\n\n        fastmap.mapApi.symbol.MarkerSymbol.prototype.draw.apply(this, arguments);\n    },\n\n    drawContent: function (ctx) {\n        for (var i = 0; i < this.symbols.length; ++i) {\n            var symbol = this.symbols[i];\n            symbol.resetTransform = false;\n            symbol.geometry = new fastmap.mapApi.symbol.Point(0, 0);\n            symbol.draw(ctx);\n            symbol.resetTransform = true;\n        }\n    },\n\n    /**\n     * bound\n     * xy\n     * @returns bound\n     */\n    getOriginBound: function () {\n        this.transformation.save();\n        var bound = new fastmap.mapApi.symbol.Bound();\n        for (var i = 0; i < this.symbols.length; ++i) {\n            this.transformation.resetTransform();\n            var symbol = this.symbols[i];\n            var symbolBound = symbol.getOriginBound();\n            this.transformation.translate(symbol.offsetX, symbol.offsetY);\n            this.transformation.rotate(symbol.angle);\n            var lineString = symbolBound.toLineString();\n            lineString = this.transformation.transform(lineString);\n            bound = bound.extend(lineString.getBound());\n        }\n        this.transformation.restore();\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.LineSymbol = fastmap.mapApi.symbol.Symbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.Symbol.prototype.initialize.apply(this, arguments);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.Symbol.prototype.fromJson.apply(this, arguments);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.Symbol.prototype.toJson.apply(this, arguments);\n\n        return json;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.SimpleLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'SimpleLineSymbol';\n\n        this.width = 1;\n        this.color = 'black';\n        this.style = 'solid';\n        this.opacity = 1;\n        this.cap = 'butt';\n        this.shadowColor = null;\n        this.shadowBlur = 0;\n        this.shadowOffsetX = 0;\n        this.shadowOffsetY = 0;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('width', json.width);\n        this.setValue('color', json.color);\n        this.setValue('style', json.style);\n        this.setValue('opacity', json.opacity);\n        this.setValue('cap', json.cap);\n        this.setValue('shadowColor', json.shadowColor || null);\n        this.setValue('shadowBlur', json.shadowBlur || 0);\n        this.setValue('shadowOffsetX', json.shadowOffsetX || 0);\n        this.setValue('shadowOffsetY', json.shadowOffsetY || 0);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.width = this.width;\n        json.color = this.color;\n        json.style = this.style;\n        json.opacity = this.opacity;\n        json.cap = this.cap;\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.style) {\n            return;\n        }\n\n        // \n        ctx.save();\n\n        var dashPattern = this.styleToPattern(this.style);\n        ctx.setLineDash(dashPattern);// \n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.globalAlpha = this.opacity;\n        ctx.lineCap = this.cap;\n        if (this.shadowColor) {\n            ctx.shadowColor = this.shadowColor;\n            ctx.shadowBlur = this.shadowBlur;\n            ctx.shadowOffsetX = this.shadowOffsetX;\n            ctx.shadowOffsetY = this.shadowOffsetY;\n        }\n\n        ctx.beginPath();\n        this.drawLineString(ctx, this.geometry);\n        if (this.geometry.isClosed()) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n\n        // \n        ctx.restore();\n    },\n\n    styleToPattern: function (style) {\n        var dashPattern = [];\n        switch (style) {\n            case 'solid':\n                dashPattern = [];\n                break;\n            case 'dash':\n                dashPattern = [10, 5];\n                break;\n            case 'dot':\n                dashPattern = [2, 2];\n                break;\n            case 'dashDot':\n                dashPattern = [10, 2, 2, 2];\n                break;\n            case 'dashDotDot':\n                dashPattern = [10, 2, 2, 2, 2, 2];\n                break;\n            default:\n                dashPattern = [];\n                break;\n        }\n\n        return dashPattern;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CartoLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CartoLineSymbol';\n        this.width = 1;\n        this.color = 'black';\n        this.opacity = 1;\n        this.cap = 'butt';\n        this.pattern = [];\n        this.startOffset = 0;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('width', json.width);\n        this.setValue('color', json.color);\n        this.setValue('opacity', json.opacity);\n        this.setValue('cap', json.cap);\n        this.setValue('pattern', json.pattern);\n        this.setValue('startOffset', json.startOffset);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.width = this.width;\n        json.color = this.color;\n        json.opacity = this.opacity;\n        json.cap = this.cap;\n        json.pattern = this.pattern;\n        json.startOffset = this.startOffset;\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.pattern) {\n            return;\n        }\n\n        // \n        ctx.save();\n\n        ctx.strokeStyle = this.color;\n        ctx.lineWidth = this.width;\n        ctx.globalAlpha = this.opacity;\n        ctx.lineCap = this.cap;\n\n        var template = new fastmap.mapApi.symbol.Template();\n        template.startOffset = this.startOffset;\n        template.pattern = this.pattern;\n        template.lineString = this.geometry;\n        var segments = template.getSegments();\n\n        ctx.beginPath();\n        for (var i = 0; i < segments.length; ++i) {\n            this.drawSegment(ctx, segments[i], template);\n        }\n        if (this.geometry.isClosed()) {\n            ctx.closePath();\n        }\n        ctx.stroke();\n\n        // \n        ctx.restore();\n    },\n\n    drawSegment: function (ctx, segment, template) {\n        var marks = template.getMarks(segment);\n        for (var i = 0; i < marks.length; ++i) {\n            this.drawLineString(ctx, marks[i]);\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.MarkerLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'MarkerLineSymbol';\n\n        this.pattern = [];\n        this.startOffset = 0;\n        this.direction = 's2e';\n        this.marker = null;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('pattern', json.pattern);\n        this.setValue('startOffset', json.startOffset);\n        this.setValue('direction', json.direction);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.marker) {\n            this.marker = symbolFactory.createSymbol(json.marker);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.pattern = this.pattern;\n        json.startOffset = this.startOffset;\n        json.direction = this.direction;\n        if (this.marker) {\n            json.marker = this.marker.toJson();\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.marker) {\n            return;\n        }\n\n        if (!this.pattern) {\n            return;\n        }\n\n        var template = new fastmap.mapApi.symbol.Template();\n        template.startOffset = this.startOffset;\n        template.pattern = this.pattern;\n        if (this.direction === 's2e') {\n            template.lineString = this.geometry;\n        } else {\n            template.lineString = this.geometry.reverse();\n        }\n        var segments = template.getSegments();\n\n        for (var i = 0; i < segments.length; ++i) {\n            this.drawSegment(ctx, segments[i], template);\n        }\n    },\n\n    drawSegment: function (ctx, segment, template) {\n        // markmarker\n        var marks = template.getMarks(segment);\n        for (var i = 0; i < marks.length; ++i) {\n            var mark = marks[i];\n            var vY = new fastmap.mapApi.symbol.Vector(0, -1);\n            var vN = mark.coordinates[1].minus(mark.coordinates[0]);\n\n            var angle = vY.angleTo(vN);\n            var signal = vY.cross(vN);\n\n            if (signal < 0) {\n                angle = -angle;\n            }\n\n            this.drawMarker(ctx, angle, mark);\n        }\n    },\n\n    drawMarker: function (ctx, angle, mark) {\n        this.marker.angle = angle;\n        this.marker.geometry = mark.coordinates[0];\n        this.marker.draw(ctx);\n    }\n});\n","/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.symbol.HashLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'HashLineSymbol';\n\n        this.hashHeight = 10;\n        this.hashOffset = 0;\n        this.hashAngle = -90;\n        this.hashLine = null;\n        this.pattern = [2, 5];\n        this.startOffset = 0;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('hashHeight', json.hashHeight);\n        this.setValue('hashOffset', json.hashOffset);\n        this.setValue('hashAngle', json.hashAngle);\n        this.setValue('pattern', json.pattern);\n        this.setValue('startOffset', json.startOffset);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.hashLine) {\n            this.hashLine = symbolFactory.createSymbol(json.hashLine);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.hashHeight = this.hashHeight;\n        json.hashOffset = this.hashOffset;\n        json.hashAngle = this.hashAngle;\n        json.pattern = this.pattern;\n        json.startOffset = this.startOffset;\n        if (this.hashLine) {\n            json.hashLine = this.hashLine.toJson();\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.hashLine) {\n            return;\n        }\n\n        if (!this.pattern) {\n            return;\n        }\n\n        var template = new fastmap.mapApi.symbol.Template();\n        template.startOffset = this.startOffset;\n        template.pattern = this.pattern;\n        template.lineString = this.geometry;\n\n        var segments = template.getSegments();\n\n        for (var i = 0; i < segments.length; ++i) {\n            this.drawSegment(ctx, segments[i], template);\n        }\n    },\n\n    drawSegment: function (ctx, segment, template) {\n        var marks = template.getMarks(segment);\n        for (var i = 0; i < marks.length; ++i) {\n            var mark = marks[i];\n\n            // mark\n            var vector = mark.coordinates[1].minus(mark.coordinates[0]);\n            vector.normalize();\n\n            // \n            var matrix = new fastmap.mapApi.symbol.Matrix();\n            matrix = matrix.makeRotate(this.hashAngle);\n            vector = vector.crossMatrix(matrix);\n\n            // hash\n            var hashOffsetVector = vector.multiNumber(this.hashOffset);\n\n            // hash\n            vector = vector.multiNumber(this.hashHeight);\n\n            var startPoint = mark.coordinates[0].plusVector(hashOffsetVector);\n            var endPoint = startPoint.plusVector(vector);\n\n            // hash\n            var hashGeo = new fastmap.mapApi.symbol.LineString();\n            hashGeo.coordinates.push(startPoint);\n            hashGeo.coordinates.push(endPoint);\n\n            // hashSymbolgeometrydraw\n            this.hashLine.geometry = hashGeo;\n            this.hashLine.draw(ctx);\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.TextLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'TextLineSymbol';\n\n        this.text = '';\n        this.spaceCount = 0;\n        this.offset = 0;\n        this.gap = 200;\n        this.alwaysisVerticalToLine = false;\n        this.marker = null;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('text', json.text);\n        this.setValue('gap', json.gap);\n        this.setValue('offset', json.offset);\n        this.setValue('spaceCount', json.spaceCount);\n        this.setValue('alwaysisVerticalToLine', json.alwaysisVerticalToLine);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.marker) {\n            this.marker = symbolFactory.createSymbol(json.marker);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.text = this.text;\n        json.gap = this.gap;\n        json.offset = this.offset;\n        json.spaceCount = this.spaceCount;\n        json.alwaysisVerticalToLine = this.alwaysisVerticalToLine;\n        if (this.marker) {\n            json.marker = this.marker.toJson();\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.text) {\n            return;\n        }\n\n        if (!this.marker) {\n            return;\n        }\n\n        var text = this.text;\n        if (this.spaceCount) {\n            text = this.addSpaceToText(this.text);\n        }\n\n        // \n        var size = this.getTextSize(text);\n        var textLength = size.width > size.height ? size.width : size.height;\n\n        // link\n        var length = this.geometry.length();\n\n        if (length < textLength * 2) {\n            return;\n        }\n\n        // \n        var drawCount = this.getDrawCount(length, textLength, this.gap);\n\n        // gap\n        var remainderLength = length - textLength * drawCount;\n\n        // gap+\n        var segLength = remainderLength / (drawCount + 1) + textLength;\n\n        // gap\n        var i = 1;\n        while (i <= drawCount) {\n            // \n            var position = segLength * i - textLength;\n\n            // \n            var info = this.getTextDirection(this.geometry, position + textLength / 2);\n            var drawText = text;\n            if (info.isReverse) {\n                drawText = text.split('').reverse().join('');\n            }\n\n            this.drawTextAtPosition(ctx, this.geometry, position, drawText, info.isVerticalToLine);\n            ++i;\n        }\n    },\n\n    addSpaceToText: function (text) {\n        var spaces = this.getSpaces(this.spaceCount);\n        var textWithSpace = '';\n        for (var i = 0; i < text.length; ++i) {\n            textWithSpace = textWithSpace + text[i] + spaces;\n        }\n        textWithSpace = textWithSpace.substr(0, textWithSpace.length - spaces.length);\n        return textWithSpace;\n    },\n\n    getSpaces: function (count) {\n        var spaces = '';\n        for (var i = 0; i < count; ++i) {\n            spaces += ' ';\n        }\n        return spaces;\n    },\n\n    /**\n     * link\n     * link0\n     * @param length link\n     * @param textLength \n     * @param gap \n     * @returns {number} \n     */\n    getDrawCount: function (length, textLength, gap) {\n        // \n        var count = Math.floor(length / textLength);\n        var bestCount = 0;\n        var dMin = Number.MAX_VALUE;\n        while (count > 0) {\n            var remainderLength = length - textLength * count;\n            var segLength = remainderLength / (count + 1);\n            var d = Math.abs(segLength - gap);\n            if (d < dMin) {\n                bestCount = count;\n                dMin = d;\n            }\n\n            --count;\n        }\n\n        return bestCount;\n    },\n\n    drawTextAtPosition: function (ctx, geometry, position, text, isVerticalToLine) {\n        var curPos = position;\n        var lastLength = 0;\n        var vY = new fastmap.mapApi.symbol.Vector(0, 1);\n        for (var i = 0; i < text.length; ++i) {\n            var size = this.getTextSize(text[i]);\n            if (isVerticalToLine) {\n                curPos += size.width / 2 + lastLength / 2;\n                lastLength = size.width;\n            } else {\n                curPos += size.height / 2 + lastLength / 2;\n                lastLength = size.height;\n            }\n\n            var res = geometry.getPointByLength(curPos);\n            var sPoint = null;\n            var ePoint = null;\n            var curPoint = null;\n            if (res[0] === 'vertex') {\n                sPoint = geometry.coordinates[res[1]];\n                ePoint = res[3];\n                curPoint = ePoint;\n            } else if (res[0] === 'betweenVertex') {\n                sPoint = geometry.coordinates[res[1]];\n                ePoint = geometry.coordinates[res[2]];\n                curPoint = res[3];\n            } else {\n                continue;\n            }\n\n            var vN = ePoint.minus(sPoint);\n\n            var angle = vY.angleTo(vN);\n            var finalAngle = 0;\n\n            if (vN.x === 0 && vN.y === 0) {\n                // \n                finalAngle = 0;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x > 0 && vN.y === 0) {\n                // x\n                finalAngle = -angle;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x < 0 && vN.y === 0) {\n                // x\n                finalAngle = angle;\n                if (isVerticalToLine) {\n                    finalAngle -= 90;\n                }\n            } else if (vN.x === 0 && vN.y > 0) {\n                // y\n                finalAngle = angle;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x === 0 && vN.y < 0) {\n                // yangle + 180\n                finalAngle = angle + 180;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x > 0 && vN.y > 0) {\n                // ,\n                finalAngle = -angle;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x < 0 && vN.y > 0) {\n                // ,\n                finalAngle = angle;\n                if (isVerticalToLine) {\n                    finalAngle -= 90;\n                }\n            } else if (vN.x < 0 && vN.y < 0) {\n                // angle + 180\n                finalAngle = angle + 180;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else {\n                // angle + 180\n                finalAngle = -angle + 180;\n                if (isVerticalToLine) {\n                    finalAngle -= 90;\n                }\n            }\n\n            var matrix = new fastmap.mapApi.symbol.Matrix();\n            var vV = vN.crossMatrix(matrix.makeRotate(90));\n            vV.normalize();\n            vV = vV.multiNumber(this.offset);\n            curPoint = curPoint.plusVector(vV);\n\n            this.drawChar(ctx, text[i], finalAngle, curPoint);\n        }\n    },\n\n    /**\n     * Link\n     * @param geometry\n     * @param position\n     * @returns {{isReverse: boolean, isVerticalToLine: boolean}}\n     */\n    getTextDirection: function (geometry, position) {\n        var res = geometry.getPointByLength(position);\n        var sPoint = null;\n        var ePoint = null;\n        var curPoint = null;\n        if (res[0] === 'vertex') {\n            sPoint = this.geometry.coordinates[res[1]];\n            ePoint = res[3];\n            curPoint = ePoint;\n        } else if (res[0] === 'betweenVertex') {\n            sPoint = this.geometry.coordinates[res[1]];\n            ePoint = this.geometry.coordinates[res[2]];\n            curPoint = res[3];\n        } else {\n            throw new Error('Link');\n        }\n\n        var vN = ePoint.minus(sPoint);\n\n        var isReverse = false;\n        var isVerticalToLine = false;\n\n        var vY = new fastmap.mapApi.symbol.Vector(0, 1);\n        var angle = vY.angleTo(vN);\n\n        if (vN.x === 0 && vN.y === 0) {\n            // ,\n            isReverse = false;\n            isVerticalToLine = false;\n        } else if (vN.x === 0 && vN.y > 0) {\n            // y,\n            isReverse = false;\n            isVerticalToLine = false;\n        } else if (vN.x > 0 && vN.y === 0) {\n            // x,\n            isReverse = false;\n            isVerticalToLine = true;\n        } else if (vN.x === 0 && vN.y < 0) {\n            // y,\n            isReverse = true;\n            isVerticalToLine = false;\n        } else if (vN.x < 0 && vN.y === 0) {\n            // x,\n            isReverse = true;\n            isVerticalToLine = true;\n        } else if (vN.x > 0 && vN.y > 0) {\n            // \n            if (angle < 45) {\n                isVerticalToLine = false;\n            } else {\n                isVerticalToLine = true;\n            }\n            isReverse = false;\n        } else if (vN.x < 0 && vN.y > 0) {\n            // \n            if (angle < 45) {\n                // \n                isReverse = false;\n                isVerticalToLine = false;\n            } else {\n                // \n                isReverse = true;\n                isVerticalToLine = true;\n            }\n        } else if (vN.x < 0 && vN.y < 0) {\n            // \n            // \n            if (angle > 135) {\n                isVerticalToLine = false;\n            } else {\n                isVerticalToLine = true;\n            }\n\n            isReverse = true;\n        } else {\n            // \n            // \n            isReverse = false;\n            isVerticalToLine = true;\n\n            if (angle > 135) {\n                // \n                isReverse = true;\n                isVerticalToLine = false;\n            }\n        }\n\n        // ,\n        if (this.alwaysisVerticalToLine) {\n            isVerticalToLine = true;\n        }\n\n        return {\n            isReverse: isReverse,\n            isVerticalToLine: isVerticalToLine\n        };\n    },\n\n    drawChar: function (ctx, char, angle, geometry) {\n        this.marker.align = 'center';\n        this.marker.baseline = 'middle';\n        this.marker.direction = 'ltr';\n        this.marker.text = char;\n        this.marker.angle = angle;\n        this.marker.geometry = geometry;\n        this.marker.draw(ctx);\n    },\n\n    getTextSize: function (text) {\n        this.marker.text = text;\n        var size = this.marker.getOriginBound().getSize();\n        return size;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CenterTextLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CenterTextLineSymbol';\n\n        this.text = '';\n        this.spaceCount = 0;\n        this.offset = 0;\n        this.times = 2;\n        this.alwaysisVerticalToLine = false;\n        this.marker = null;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('text', json.text);\n        this.setValue('spaceCount', json.spaceCount);\n        this.setValue('offset', json.offset);\n        this.setValue('times', json.times);\n        this.setValue('alwaysisVerticalToLine', json.alwaysisVerticalToLine);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.marker) {\n            this.marker = symbolFactory.createSymbol(json.marker);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.text = this.text;\n        json.spaceCount = this.spaceCount;\n        json.offset = this.offset;\n        json.times = this.times;\n        json.alwaysisVerticalToLine = this.alwaysisVerticalToLine;\n        if (this.marker) {\n            json.marker = this.marker.toJson();\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.text) {\n            return;\n        }\n\n        if (!this.marker) {\n            return;\n        }\n\n        var text = this.text;\n        if (this.spaceCount) {\n            text = this.addSpaceToText(this.text);\n        }\n\n        // \n        var size = this.getTextSize(text);\n        var textLength = size.width > size.height ? size.width : size.height;\n\n        // link\n        var length = this.geometry.length();\n\n        if (length < textLength * this.times) {\n            return;\n        }\n\n        // gap\n        var remainderLength = length - textLength;\n\n        // \n        var position = remainderLength / 2;\n\n        // \n        var info = this.getTextDirection(this.geometry, position + textLength / 2);\n        if (info.isReverse) {\n            text = text.split('').reverse().join('');\n        }\n\n        this.drawTextAtPosition(ctx, this.geometry, position, text, info.isVerticalToLine);\n    },\n\n    addSpaceToText: function (text) {\n        var spaces = this.getSpaces(this.spaceCount);\n        var textWithSpace = '';\n        for (var i = 0; i < text.length; ++i) {\n            textWithSpace = textWithSpace + text[i] + spaces;\n        }\n        textWithSpace = textWithSpace.substr(0, textWithSpace.length - spaces.length);\n        return textWithSpace;\n    },\n\n    getSpaces: function (count) {\n        var spaces = '';\n        for (var i = 0; i < count; ++i) {\n            spaces += ' ';\n        }\n        return spaces;\n    },\n\n    drawTextAtPosition: function (ctx, geometry, position, text, isVerticalToLine) {\n        var curPos = position;\n        var vY = new fastmap.mapApi.symbol.Vector(0, 1);\n        for (var i = 0; i < text.length; ++i) {\n            var size = this.getTextSize(text[i]);\n            var res = geometry.getPointByLength(curPos);\n            var sPoint = null;\n            var ePoint = null;\n            var curPoint = null;\n            if (res[0] === 'vertex') {\n                sPoint = geometry.coordinates[res[1]];\n                ePoint = res[3];\n                curPoint = ePoint;\n            } else if (res[0] === 'betweenVertex') {\n                sPoint = geometry.coordinates[res[1]];\n                ePoint = geometry.coordinates[res[2]];\n                curPoint = res[3];\n            } else {\n                continue;\n            }\n\n            var vN = ePoint.minus(sPoint);\n\n            var angle = vY.angleTo(vN);\n            var finalAngle = 0;\n\n            if (vN.x === 0 && vN.y === 0) {\n                // \n                finalAngle = 0;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x > 0 && vN.y === 0) {\n                // x\n                finalAngle = -angle;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x < 0 && vN.y === 0) {\n                // x\n                finalAngle = angle;\n                if (isVerticalToLine) {\n                    finalAngle -= 90;\n                }\n            } else if (vN.x === 0 && vN.y > 0) {\n                // y\n                finalAngle = angle;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x === 0 && vN.y < 0) {\n                // yangle + 180\n                finalAngle = angle + 180;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x > 0 && vN.y > 0) {\n                // ,\n                finalAngle = -angle;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else if (vN.x < 0 && vN.y > 0) {\n                // ,\n                finalAngle = angle;\n                if (isVerticalToLine) {\n                    finalAngle -= 90;\n                }\n            } else if (vN.x < 0 && vN.y < 0) {\n                // angle + 180\n                finalAngle = angle + 180;\n                if (isVerticalToLine) {\n                    finalAngle += 90;\n                }\n            } else {\n                // angle + 180\n                finalAngle = -angle + 180;\n                if (isVerticalToLine) {\n                    finalAngle -= 90;\n                }\n            }\n\n            if (isVerticalToLine) {\n                curPos += size.width;\n            } else {\n                curPos += size.height;\n            }\n\n            var matrix = new fastmap.mapApi.symbol.Matrix();\n            var vV = vN.crossMatrix(matrix.makeRotate(90));\n            vV.normalize();\n            vV = vV.multiNumber(this.offset);\n            curPoint = curPoint.plusVector(vV);\n\n            this.drawChar(ctx, text[i], finalAngle, curPoint);\n        }\n    },\n\n    /**\n     * Link\n     * @param geometry\n     * @param position\n     * @returns {{isReverse: boolean, isVerticalToLine: boolean}}\n     */\n    getTextDirection: function (geometry, position) {\n        var res = geometry.getPointByLength(position);\n        var sPoint = null;\n        var ePoint = null;\n        var curPoint = null;\n        if (res[0] === 'vertex') {\n            sPoint = this.geometry.coordinates[res[1]];\n            ePoint = res[3];\n            curPoint = ePoint;\n        } else if (res[0] === 'betweenVertex') {\n            sPoint = this.geometry.coordinates[res[1]];\n            ePoint = this.geometry.coordinates[res[2]];\n            curPoint = res[3];\n        } else {\n            throw new Error('Link');\n        }\n\n        var vN = ePoint.minus(sPoint);\n\n        var isReverse = false;\n        var isVerticalToLine = false;\n\n        var vY = new fastmap.mapApi.symbol.Vector(0, 1);\n        var angle = vY.angleTo(vN);\n\n        if (vN.x === 0 && vN.y === 0) {\n            // ,\n            isReverse = false;\n            isVerticalToLine = false;\n        } else if (vN.x === 0 && vN.y > 0) {\n            // y,\n            isReverse = false;\n            isVerticalToLine = false;\n        } else if (vN.x > 0 && vN.y === 0) {\n            // x,\n            isReverse = false;\n            isVerticalToLine = true;\n        } else if (vN.x === 0 && vN.y < 0) {\n            // y,\n            isReverse = true;\n            isVerticalToLine = false;\n        } else if (vN.x < 0 && vN.y === 0) {\n            // x,\n            isReverse = true;\n            isVerticalToLine = true;\n        } else if (vN.x > 0 && vN.y > 0) {\n            // \n            if (angle < 45) {\n                isVerticalToLine = false;\n            } else {\n                isVerticalToLine = true;\n            }\n            isReverse = false;\n        } else if (vN.x < 0 && vN.y > 0) {\n            // \n            if (angle < 45) {\n                // \n                isReverse = false;\n                isVerticalToLine = false;\n            } else {\n                // \n                isReverse = true;\n                isVerticalToLine = true;\n            }\n        } else if (vN.x < 0 && vN.y < 0) {\n            // \n            if (angle > 135) {\n                isVerticalToLine = false;\n            } else {\n                isVerticalToLine = true;\n            }\n            isReverse = true;\n        } else {\n            // \n            // \n            isReverse = false;\n            isVerticalToLine = true;\n\n            if (angle > 135) {\n                // \n                isReverse = true;\n                isVerticalToLine = false;\n            }\n        }\n\n        // ,\n        if (this.alwaysisVerticalToLine) {\n            isVerticalToLine = true;\n        }\n\n        return {\n            isReverse: isReverse,\n            isVerticalToLine: isVerticalToLine\n        };\n    },\n\n    drawChar: function (ctx, char, angle, geometry) {\n        this.marker.align = 'center';\n        this.marker.baseline = 'middle';\n        this.marker.direction = 'ltr';\n        this.marker.text = char;\n        this.marker.angle = angle;\n        this.marker.geometry = geometry;\n        this.marker.draw(ctx);\n    },\n\n    getTextSize: function (text) {\n        this.marker.text = text;\n        var size = this.marker.getOriginBound().getSize();\n        return size;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.EndMarkerLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'EndMarkerLineSymbol';\n\n        this.marker = null;\n        this.position = 'e';\n        this.times = 10;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('position', json.position);\n        this.setValue('times', json.times);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.marker) {\n            this.marker = symbolFactory.createSymbol(json.marker);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.position = this.position;\n        json.times = this.times;\n        if (this.marker) {\n            json.marker = this.marker.toJson();\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.marker) {\n            return;\n        }\n\n        var length = this.geometry.length();\n        var size = this.marker.getOriginBound().getSize();\n        var maxSize = size.height > size.width ? size.height : size.width;\n\n        if (length < maxSize * this.times) {\n            return;\n        }\n\n        // markermarker\n        var offset = size.height / 2;\n        var geometry = this.geometry;\n        if (this.position === 's') {\n            geometry = geometry.reverse();\n        }\n        var res = geometry.getPointByLength(length - offset);\n        var sP = null;\n        var eP = null;\n        if (res[0] === 'vertex') {\n            sP = geometry.coordinates[res[1]];\n            eP = res[3];\n        } else if (res[0] === 'betweenVertex') {\n            sP = geometry.coordinates[res[1]];\n            eP = res[3];\n        } else {\n            throw new Error('Link');\n        }\n\n        this.drawMarker(ctx, sP, eP);\n    },\n\n    drawMarker: function (ctx, sP, eP) {\n        var vY = new fastmap.mapApi.symbol.Vector(0, -1);\n        var vN = eP.minus(sP);\n        var angle = vY.angleTo(vN);\n        var signal = vY.cross(vN);\n\n        if (signal < 0) {\n            angle = -angle;\n        }\n\n        this.marker.angle = angle;\n        this.marker.geometry = eP;\n        this.marker.draw(ctx);\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CenterMarkerLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CenterMarkerLineSymbol';\n\n        this.marker = null;\n        this.direction = 's2e';\n        this.times = 10;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('direction', json.direction);\n        this.setValue('times', json.times);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.marker) {\n            this.marker = symbolFactory.createSymbol(json.marker);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.direction = this.direction;\n        json.times = this.times;\n        if (this.marker) {\n            json.marker = this.marker.toJson();\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (!this.marker) {\n            return;\n        }\n\n        var length = this.geometry.length();\n        var size = this.marker.getOriginBound().getSize();\n        var maxSize = size.height > size.width ? size.height : size.width;\n\n        if (length < maxSize * this.times) {\n            return;\n        }\n\n        var res = this.geometry.getPointByLength(length / 2);\n        var sP = null;\n        var eP = null;\n        if (res[0] === 'vertex') {\n            sP = this.geometry.coordinates[res[1]];\n            eP = res[3];\n        } else if (res[0] === 'betweenVertex') {\n            sP = this.geometry.coordinates[res[1]];\n            eP = res[3];\n        } else {\n            throw new Error('Link');\n        }\n\n        this.drawMarker(ctx, sP, eP);\n    },\n\n    drawMarker: function (ctx, sP, eP) {\n        var vN = null;\n        if (this.direction === 's2e') {\n            vN = eP.minus(sP);\n        } else if (this.direction === 'e2s') {\n            vN = sP.minus(eP);\n        } else {\n            throw new Error('directions2ee2s');\n        }\n        var vY = new fastmap.mapApi.symbol.Vector(0, -1);\n        var angle = vY.angleTo(vN);\n        var signal = vY.cross(vN);\n\n        if (signal < 0) {\n            angle = -angle;\n        }\n\n        this.marker.angle = angle;\n        this.marker.geometry = eP;\n        this.marker.draw(ctx);\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CompositeLineSymbol = fastmap.mapApi.symbol.LineSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.LineSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CompositeLineSymbol';\n\n        this.symbols = [];\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.LineSymbol.prototype.fromJson.apply(this, arguments);\n\n        if (!json.symbols) {\n            return;\n        }\n\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        for (var i = 0; i < json.symbols.length; ++i) {\n            this.symbols.push(symbolFactory.createSymbol(json.symbols[i]));\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.LineSymbol.prototype.toJson.apply(this, arguments);\n\n        json.symbols = [];\n        for (var i = 0; i < this.symbols.length; ++i) {\n            json.symbols.push(this.symbols[i].toJson());\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        if (this.geometry.coordinates.length < 2) {\n            return;\n        }\n\n        if (this.symbols.length === 0) {\n            return;\n        }\n\n        for (var i = 0; i < this.symbols.length; ++i) {\n            this.symbols[i].geometry = this.geometry;\n            this.symbols[i].draw(ctx);\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.FillSymbol = fastmap.mapApi.symbol.Symbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.Symbol.prototype.initialize.apply(this, arguments);\n\n        this.opacity = 1;\n        this.outLine = null;\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.Symbol.prototype.fromJson.apply(this, arguments);\n\n        this.setValue('opacity', json.opacity);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.outLine) {\n            this.outLine = symbolFactory.createSymbol(json.outLine);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.Symbol.prototype.toJson.apply(this, arguments);\n\n        json.opacity = this.opacity;\n        if (this.outLine) {\n            json.outLine = this.outLine.toJson();\n        }\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.geometry || !this.geometry.coordinates) {\n            return;\n        }\n\n        // \n        if (this.geometry.coordinates.length === 0) {\n            return;\n        }\n\n        // \n        if (this.geometry.coordinates[0].length < 4) {\n            return;\n        }\n\n        // \n        ctx.save();\n\n        this.drawSymbol(ctx);\n\n        // \n        ctx.restore();\n    },\n\n    drawSymbol: function (ctx) {\n        // \n        this.drawContent(ctx);\n\n        // \n        if (this.outLine) {\n            this.drawOutLine(ctx);\n        }\n    },\n\n    drawContent: function (ctx) {\n        return;\n    },\n\n    drawOutLine: function (ctx) {\n        this.outLine.geometry = this.geometry.coordinates[0];\n        this.outLine.draw(ctx);\n    },\n\n    getBound: function () {\n        var gf = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n\n        var bound = this.geometry.getBound();\n\n        return bound;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.SimpleFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'SimpleFillSymbol';\n\n        this.color = 'black';\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);\n        this.setValue('color', json.color);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);\n        json.color = this.color;\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        ctx.fillStyle = this.color;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        ctx.beginPath();\n        this.drawLineString(ctx, this.geometry.coordinates[0]);\n        ctx.fill();\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.PatternFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'PatternFillSymbol';\n\n        this.patternWidth = 10;\n        this.patternHeight = 10;\n        this.patternPath = '';\n        this.patternColor = 'black';\n        this.patternLineDash = [];\n        this.patternLineWidth = 1;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);\n        this.setValue('patternWidth', json.patternWidth);\n        this.setValue('patternHeight', json.patternHeight);\n        this.setValue('patternPath', json.patternPath);\n        this.setValue('patternColor', json.patternColor);\n        this.setValue('patternLineDash', json.patternLineDash);\n        this.setValue('patternLineWidth', json.patternLineWidth);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);\n        json.patternWidth = this.patternWidth;\n        json.patternHeight = this.patternHeight;\n        json.patternPath = this.patternPath;\n        json.patternColor = this.patternColor;\n        json.patternLineDash = this.patternLineDash;\n        json.patternLineWidth = this.patternLineWidth;\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // pattern\n        var pattern = this.getPattern(ctx);\n\n        // \n        ctx.fillStyle = pattern;\n        ctx.globalAlpha = this.opacity;\n\n        // \n        ctx.beginPath();\n        this.drawLineString(ctx, this.geometry.coordinates[0]);\n        ctx.fill();\n    },\n\n    getPattern: function (ctx) {\n        var canvas = document.createElement('canvas');\n        canvas.width = this.patternWidth;\n        canvas.height = this.patternHeight;\n        var ctx1 = canvas.getContext('2d');\n        ctx1.setLineDash(this.patternLineDash);\n        ctx1.lineWidth = this.patternLineWidth;\n        ctx1.strokeStyle = this.patternColor;\n\n        // \n        ctx1.fillStyle = 'white';\n        ctx1.fillRect(0, 0, this.patternWidth, this.patternHeight);\n\n        var path = new Path2D(this.patternPath);\n        ctx1.stroke(path);\n\n        var pattern = ctx.createPattern(canvas, 'repeat');\n\n        return pattern;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.LinearGradientFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'LinearGradientFillSymbol';\n\n        this.direction = 't2b';\n        this.startColor = 'gray';\n        this.endColor = 'black';\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);\n        this.setValue('direction', json.direction);\n        this.setValue('startColor', json.startColor);\n        this.setValue('endColor', json.endColor);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);\n        json.direction = this.direction;\n        json.startColor = this.startColor;\n        json.endColor = this.endColor;\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        var gradient = this.createGradient(ctx);\n\n        // \n        ctx.globalAlpha = this.opacity;\n        ctx.fillStyle = gradient;\n\n        // \n        ctx.beginPath();\n        this.drawLineString(ctx, this.geometry.coordinates[0]);\n        ctx.fill();\n    },\n\n    createGradient: function (ctx) {\n        var bound = this.getBound();\n        var startX = 0;\n        var startY = 0;\n        var endX = 0;\n        var endY = 0;\n        switch (this.direction) {\n            case 't2b':\n                startX = 0;\n                startY = bound.top;\n                endX = 0;\n                endY = bound.buttom;\n                break;\n            case 'b2t':\n                startX = 0;\n                startY = bound.buttom;\n                endX = 0;\n                endY = bound.top;\n                break;\n            case 'l2r':\n                startX = 0;\n                startY = bound.left;\n                endX = 0;\n                endY = bound.right;\n                break;\n            case 'r2l':\n                startX = 0;\n                startY = bound.right;\n                endX = 0;\n                endY = bound.left;\n                break;\n            case 'lt2rb':\n                startX = bound.left;\n                startY = bound.top;\n                endX = bound.right;\n                endY = bound.buttom;\n                break;\n            case 'rb2lt':\n                startX = bound.right;\n                startY = bound.buttom;\n                endX = bound.left;\n                endY = bound.top;\n                break;\n            case 'lb2rt':\n                startX = bound.left;\n                startY = bound.buttom;\n                endX = bound.right;\n                endY = bound.top;\n                break;\n            case 'rt2lb':\n                startX = bound.right;\n                startY = bound.top;\n                endX = bound.left;\n                endY = bound.buttom;\n                break;\n            default:\n                throw new Error('');\n        }\n\n        var gradient = ctx.createLinearGradient(startX, startY, endX, endY);\n        gradient.addColorStop(0, this.startColor);\n        gradient.addColorStop(1, this.endColor);\n\n        return gradient;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.RadialGradientFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'RadialGradientFillSymbol';\n\n        this.direction = 'c2o';\n        this.startColor = 'gray';\n        this.endColor = 'black';\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);\n        this.setValue('direction', json.direction);\n        this.setValue('startColor', json.startColor);\n        this.setValue('endColor', json.endColor);\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);\n        json.direction = this.direction;\n        json.startColor = this.startColor;\n        json.endColor = this.endColor;\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        // \n        var gradient = this.createGradient(ctx);\n\n        // \n        ctx.globalAlpha = this.opacity;\n        ctx.fillStyle = gradient;\n\n        // \n        ctx.beginPath();\n        this.drawLineString(ctx, this.geometry.coordinates[0]);\n        ctx.fill();\n    },\n\n    createGradient: function (ctx) {\n        var bound = this.getBound();\n        var width = bound.right - bound.left;\n        var length = bound.buttom - bound.top;\n        var radius = length > width ? length : width;\n        radius /= 2;\n        var startRadius = 0;\n        var endRadius = 0;\n        switch (this.direction) {\n            case 'c2o':\n                startRadius = 0;\n                endRadius = radius;\n                break;\n            case 'o2c':\n                startRadius = radius;\n                endRadius = 0;\n                break;\n            default:\n                throw new Error('');\n        }\n\n        var centerX = bound.left + radius;\n        var centerY = bound.top + radius;\n        var gradient = ctx.createRadialGradient(centerX, centerY, startRadius, centerX, centerY, endRadius);\n        gradient.addColorStop(0, this.startColor);\n        gradient.addColorStop(1, this.endColor);\n\n        return gradient;\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CenterMarkerFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CenterMarkerFillSymbol';\n\n        this.marker = null;\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        if (json.marker) {\n            this.marker = symbolFactory.createSymbol(json.marker);\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);\n        if (this.marker) {\n            json.marker = this.marker.toJson();\n        }\n\n        return json;\n    },\n\n    drawContent: function (ctx) {\n        var geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();\n        var geometryFactory = fastmap.mapApi.symbol.GeometryFactory.getInstance();\n        var geojsonPolygon = geometryFactory.toGeojson(this.geometry);\n        var geojsonPoint = geometryAlgorithm.centroid(geojsonPolygon);\n        this.marker.geometry = geometryFactory.fromGeojson(geojsonPoint);\n        this.marker.draw(ctx);\n    }\n});\n","/**\n * Created by xujie on 2016/5/13 0013.\n */\n\nfastmap.mapApi.symbol.CompositeFillSymbol = fastmap.mapApi.symbol.FillSymbol.extend({\n    initialize: function (options) {\n        // \n        fastmap.mapApi.symbol.FillSymbol.prototype.initialize.apply(this, arguments);\n\n        this.type = 'CompositeFillSymbol';\n\n        this.symbols = [];\n\n        this.fromJson(options);\n    },\n\n    fromJson: function (json) {\n        fastmap.mapApi.symbol.FillSymbol.prototype.fromJson.apply(this, arguments);\n\n        if (!json.symbols) {\n            return;\n        }\n\n        var symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        for (var i = 0; i < json.symbols.length; ++i) {\n            this.symbols.push(symbolFactory.createSymbol(json.symbols[i]));\n        }\n    },\n\n    toJson: function () {\n        var json = fastmap.mapApi.symbol.FillSymbol.prototype.toJson.apply(this, arguments);\n\n        json.symbols = [];\n        for (var i = 0; i < this.symbols.length; ++i) {\n            json.symbols.push(this.symbols[i].toJson());\n        }\n\n        return json;\n    },\n\n    draw: function (ctx) {\n        if (!this.symbols.length) {\n            return;\n        }\n\n        if (this.symbols.length === 0) {\n            return;\n        }\n\n        fastmap.mapApi.symbol.FillSymbol.prototype.draw.apply(this, arguments);\n    },\n\n    drawContent: function (ctx) {\n        for (var i = 0; i < this.symbols.length; ++i) {\n            this.symbols[i].geometry = this.geometry;\n            this.symbols[i].draw(ctx);\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/11/26.\n */\nfastmap.mapApi.symbol.ResourceFactory = L.Class.extend({\n\n    initialize: function () {\n        this.resources = {};\n    },\n\n    add: function (key, resource) {\n        if (!key || !resource) {\n            return;\n        }\n\n        if (this.resources[key]) {\n            return;\n        }\n\n        this.resources[key] = resource;\n    },\n\n    del: function (key) {\n        if (!key) {\n            return;\n        }\n\n        if (!this.resources.hasOwnProperty(key)) {\n            return;\n        }\n\n        delete this.resources[key];\n    },\n\n    getResource: function (key) {\n        return this.resources[key];\n    },\n\n    containResource: function (key) {\n        return this.resources.hasOwnProperty(key);\n    },\n\n    clear: function () {\n        this.resources = {};\n    },\n\n    destroy: function () {\n        fastmap.mapApi.symbol.ResourceFactory.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.symbol.ResourceFactory.instance) {\n                fastmap.mapApi.symbol.ResourceFactory.instance =\n                    new fastmap.mapApi.symbol.ResourceFactory();\n            }\n            return fastmap.mapApi.symbol.ResourceFactory.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.symbol.GetSymbolFactory = (function () {\n    var instantiated;\n    var symbolGallery = {};\n\n    var SymbolFactory = L.Class.extend({\n        /**\n         * \n         * @method loadSymbols\n         * @param symbolData\n         */\n        loadSymbols: function (symbolData) {\n            for (var i = 0; i < symbolData.length; ++i) {\n                var data = symbolData[i];\n                var symbol = this.createSymbol(data);\n                this.addSymbol(data.name, symbol);\n            }\n        },\n\n        /**\n         * \n         * @method createSymbol\n         * @param symbolType\n         */\n        createSymbol: function (json) {\n            var symbolType = json.type;\n            switch (symbolType) {\n                case 'CircleMarkerSymbol':\n                    return new fastmap.mapApi.symbol.CircleMarkerSymbol(json);\n                case 'SquareMarkerSymbol':\n                    return new fastmap.mapApi.symbol.SquareMarkerSymbol(json);\n                case 'RectangleMarkerSymbol':\n                    return new fastmap.mapApi.symbol.RectangleMarkerSymbol(json);\n                case 'CrossMarkerSymbol':\n                    return new fastmap.mapApi.symbol.CrossMarkerSymbol(json);\n                case 'TiltedCrossMarkerSymbol':\n                    return new fastmap.mapApi.symbol.TiltedCrossMarkerSymbol(json);\n                case 'TriangleMarkerSymbol':\n                    return new fastmap.mapApi.symbol.TriangleMarkerSymbol(json);\n                case 'ImageMarkerSymbol':\n                    return new fastmap.mapApi.symbol.ImageMarkerSymbol(json);\n                case 'MultiImageMarkerSymbol':\n                    return new fastmap.mapApi.symbol.MultiImageMarkerSymbol(json);\n                case 'TextMarkerSymbol':\n                    return new fastmap.mapApi.symbol.TextMarkerSymbol(json);\n                case 'CompositeMarkerSymbol':\n                    return new fastmap.mapApi.symbol.CompositeMarkerSymbol(json);\n                case 'SimpleLineSymbol':\n                    return new fastmap.mapApi.symbol.SimpleLineSymbol(json);\n                case 'CartoLineSymbol':\n                    return new fastmap.mapApi.symbol.CartoLineSymbol(json);\n                case 'MarkerLineSymbol':\n                    return new fastmap.mapApi.symbol.MarkerLineSymbol(json);\n                case 'HashLineSymbol':\n                    return new fastmap.mapApi.symbol.HashLineSymbol(json);\n                case 'TextLineSymbol':\n                    return new fastmap.mapApi.symbol.TextLineSymbol(json);\n                case 'CenterTextLineSymbol':\n                    return new fastmap.mapApi.symbol.CenterTextLineSymbol(json);\n                case 'EndMarkerLineSymbol':\n                    return new fastmap.mapApi.symbol.EndMarkerLineSymbol(json);\n                case 'CenterMarkerLineSymbol':\n                    return new fastmap.mapApi.symbol.CenterMarkerLineSymbol(json);\n                case 'CompositeLineSymbol':\n                    return new fastmap.mapApi.symbol.CompositeLineSymbol(json);\n                case 'SimpleFillSymbol':\n                    return new fastmap.mapApi.symbol.SimpleFillSymbol(json);\n                case 'PatternFillSymbol':\n                    return new fastmap.mapApi.symbol.PatternFillSymbol(json);\n                case 'LinearGradientFillSymbol':\n                    return new fastmap.mapApi.symbol.LinearGradientFillSymbol(json);\n                case 'RadialGradientFillSymbol':\n                    return new fastmap.mapApi.symbol.RadialGradientFillSymbol(json);\n                case 'CenterMarkerFillSymbol':\n                    return new fastmap.mapApi.symbol.CenterMarkerFillSymbol(json);\n                case 'CompositeFillSymbol':\n                    return new fastmap.mapApi.symbol.CompositeFillSymbol(json);\n                default:\n                    throw new Error(': ' + symbolType);\n            }\n        },\n\n        /**\n         * \n         * @method getSymbol\n         * @param symbolName\n         */\n        getSymbol: function (symbolName) {\n            return symbolGallery[symbolName];\n        },\n\n        /**\n         * \n         * @method containSymbol\n         * @param symbolName\n         */\n        containSymbol: function (symbolName) {\n            return symbolGallery.hasOwnProperty(symbolName);\n        },\n\n        /**\n         * \n         * @method getSymbols\n         */\n        getSymbolNames: function () {\n            var symbols = [];\n            for (var p in symbolGallery) {\n                if (symbolGallery.hasOwnProperty(p)) {\n                    symbols.push(p);\n                }\n            }\n            return symbols;\n        },\n\n        /**\n         * \n         * false\n         * @method addSymbol\n         * @param symbol\n         * @param symbolName\n         */\n        addSymbol: function (symbolName, symbol) {\n            if (symbolGallery.hasOwnProperty(symbolName)) {\n                return false;\n            }\n\n            symbolGallery[symbolName] = symbol;\n            return true;\n        },\n\n        /**\n         * \n         * @method removeSymbol\n         * @param symbolName\n         */\n        removeSymbol: function (symbolName) {\n            if (symbolGallery.hasOwnProperty(symbolName)) {\n                delete symbolGallery[symbolName];\n            }\n        },\n\n        /**\n         * urls\n         * @param symbol\n         * @returns {Array}\n         */\n        getUrlsFromSymbol: function (symbol) {\n            var urls = [];\n            var type = symbol.type;\n            switch (type) {\n                case 'ImageMarkerSymbol':\n                    urls.push(symbol.url);\n                    break;\n                case 'MultiImageMarkerSymbol':\n                    symbol.urls.forEach(function (item) {\n                        item.forEach(function (it) {\n                            if (it) {\n                                urls.push(it);\n                            }\n                        });\n                    });\n                    break;\n                case 'MarkerLineSymbol':\n                case 'CenterMarkerLineSymbol':\n                case 'EndMarkerLineSymbol':\n                    urls = this.getUrlsFromSymbol(symbol.marker);\n                    break;\n                case 'CompositeMarkerSymbol':\n                case 'CompositeLineSymbol':\n                    symbol.symbols.forEach(function (item) {\n                        var itemUrls = this.getUrlsFromSymbol(item);\n                        urls = urls.concat(itemUrls);\n                    }, this);\n                    break;\n                default:\n                    break;\n            }\n\n            return urls;\n        },\n\n        getGeometryTypeBySymbol: function (symbol) {\n            if (symbol instanceof fastmap.mapApi.symbol.MarkerSymbol) {\n                return 'Point';\n            }\n            if (symbol instanceof fastmap.mapApi.symbol.LineSymbol) {\n                return 'LineString';\n            }\n            if (symbol instanceof fastmap.mapApi.symbol.FillSymbol) {\n                return 'Polygon';\n            }\n\n            throw new Error('!');\n        },\n\n        /**\n         * \n         */\n        destroy: function () {\n            instantiated = null;\n            symbolGallery = {};\n        }\n    });\n\n    return function () {\n        if (!instantiated) {\n            instantiated = new SymbolFactory();\n        }\n        return instantiated;\n    };\n}());\n","/**\n * Created by xujie on 2016/5/11 0011.\n */\nfastmap.mapApi.symbol.GeometryFactory = L.Class.extend({\n\n    initialize: function () {\n    },\n\n    createPoint: function (coordinates) {\n        return new fastmap.mapApi.symbol.Point(coordinates[0], coordinates[1]);\n    },\n\n    createLineString: function (coordinates) {\n        var lineString = new fastmap.mapApi.symbol.LineString();\n        for (var i = 0; i < coordinates.length; ++i) {\n            var point = this.createPoint(coordinates[i]);\n            lineString.coordinates.push(point);\n        }\n        return lineString;\n    },\n\n    createPolygon: function (coordinates) {\n        var polygon = new fastmap.mapApi.symbol.Polygon();\n        for (var i = 0; i < coordinates.length; ++i) {\n            var lineString = this.createLineString(coordinates[i]);\n            polygon.coordinates.push(lineString);\n        }\n        return polygon;\n    },\n\n    toGeojson: function (geometry) {\n        var type = geometry.type;\n        var coordinates = [];\n        switch (type) {\n            case 'Point':\n                coordinates = [geometry.x, geometry.y];\n                break;\n            case 'LineString':\n                coordinates = geometry.coordinates.map(function (point) {\n                    return [point.x, point.y];\n                }, this);\n                break;\n            case 'Polygon':\n                coordinates = geometry.coordinates.map(function (ls) {\n                    return ls.coordinates.map(function (point) {\n                        return [point.x, point.y];\n                    }, this);\n                }, this);\n                break;\n            default:\n                throw new Error(':' + type);\n        }\n\n        var geojson = {\n            type: type,\n            coordinates: coordinates\n        };\n\n        return geojson;\n    },\n\n    fromGeojson: function (geojson) {\n        var type = geojson.type;\n        switch (type) {\n            case 'Point':\n                var point = new fastmap.mapApi.symbol.Point(geojson.coordinates[0], geojson.coordinates[1]);\n                return point;\n            case 'LineString':\n                var lineString = this.createLineString(geojson.coordinates);\n                return lineString;\n            case 'Polygon':\n                var polygon = this.createPolygon(geojson.coordinates);\n                return polygon;\n            default:\n                throw new Error(':' + type);\n        }\n    },\n\n    /**\n     * bound\n     * xy\n     * centernullundefined[0,0]\n     * @param center\n     * @param width\n     * @param height\n     */\n    createBound: function (center, width, height) {\n        var cX = 0;\n        var cY = 0;\n        if (center) {\n            cX = center.x;\n            cY = center.y;\n        }\n        var halfWidth = width / 2;\n        var halfHeight = height / 2;\n        var left = cX - halfWidth;\n        var top = cY - halfHeight;\n        var right = cX + halfWidth;\n        var buttom = cY + halfHeight;\n        var bound = new fastmap.mapApi.symbol.Bound(\n            left,\n            top,\n            right,\n            buttom\n        );\n        return bound;\n    },\n\n    destroy: function () {\n        fastmap.mapApi.symbol.GeometryFactory.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.symbol.GeometryFactory.instance) {\n                fastmap.mapApi.symbol.GeometryFactory.instance =\n                    new fastmap.mapApi.symbol.GeometryFactory();\n            }\n            return fastmap.mapApi.symbol.GeometryFactory.instance;\n        }\n    }\n});\n","/**\n * Created by xujie on 2016/11/32\n * geometry\n */\nfastmap.mapApi.symbol.GeometryTransform = L.Class.extend({\n\n    initialize: function () {\n        this.convertFunction = null;\n        this.map = null;\n        this.tile = null;\n    },\n\n    /**\n     * \n     * @param map\n     * @param tile\n     * @param convertFuc\n     */\n    setEnviroment: function (map, tile, convertFuc) {\n        this.map = map;\n        this.tile = tile;\n        this.convertFunction = convertFuc;\n    },\n\n    /**\n    * geometry\n    * \n    * @param geometry\n    * @returns geometry\n    */\n    convertGeometry: function (geometry) {\n        var newGeometry = geometry.clone();\n        var type = newGeometry.type;\n        switch (type) {\n            case 'Point':\n                return this.convertPoint(newGeometry);\n            case 'LineString':\n                return this.convertLineString(newGeometry);\n            case 'Polygon':\n                return this.convertPolygon(newGeometry);\n            default:\n                throw new Error(':' + type);\n        }\n    },\n\n    convertPoint: function (geometry) {\n        return this.convertFunction(this.map, this.tile, geometry);\n    },\n\n    convertLineString: function (geometry) {\n        geometry.coordinates = geometry.coordinates.map(function (element, index, array) {\n            return this.convertPoint(element);\n        }, this);\n        return geometry;\n    },\n\n    convertPolygon: function (geometry) {\n        geometry.coordinates = geometry.coordinates.map(function (element, index, array) {\n            return this.convertLineString(element);\n        }, this);\n        return geometry;\n    },\n\n    destroy: function () {\n        fastmap.mapApi.symbol.GeometryTransform.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!fastmap.mapApi.symbol.GeometryTransform.instance) {\n                fastmap.mapApi.symbol.GeometryTransform.instance =\n                    new fastmap.mapApi.symbol.GeometryTransform();\n            }\n            return fastmap.mapApi.symbol.GeometryTransform.instance;\n        }\n    }\n});\n","FM.mapApi.render = {\n    data: {},\n    renderer: {},\n    highlight: {}\n};\n","FM.mapApi.render.data.DataModel = L.Class.extend({\n    symbolFactory: FM.mapApi.symbol.GetSymbolFactory(),\n    geometryFactory: FM.mapApi.symbol.GeometryFactory.getInstance(),\n\n    initialize: function (data) {\n        this.type = 'RenderData';\n        this.geometry = null;\n        this.properties = null;\n\n        if (data) {\n            this.geometry = {};\n            this.geometry.coordinates = data.g;\n\n            this.properties = {};\n            this.properties.id = parseInt(data.i, 10);\n        }\n\n        this.setAttribute.apply(this, arguments);\n    },\n\n    setAttribute: function () {\n        throw new Error('setAttribute');\n    },\n\n    statics: {\n        create: function (data, tile) {\n            throw new Error('create');\n        },\n\n        transform: function (data, tile, caller) {\n            var list = [];\n            var key,\n                i,\n                n,\n                temp,\n                tmp;\n            if (FM.Util.isObject(data)) {\n                for (key in data) {\n                    if (data.hasOwnProperty(key)) {\n                        for (i = 0, n = data[key].length; i < n; i++) {\n                            tmp = caller.create(data[key][i], tile);\n                            if (FM.Util.isObject(tmp)) {\n                                list.push(tmp);\n                            } else if (FM.Util.isArray(tmp)) {\n                                list = list.concat(tmp);\n                            }\n                        }\n                    }\n                }\n            } else if (FM.Util.isArray(data)) {\n                temp = data;\n                if (FM.Util.isArray(data[0])) {\n                    temp = data[0];\n                }\n                for (i = 0, n = temp.length; i < n; i++) {\n                    tmp = caller.create(temp[i], tile);\n                    if (FM.Util.isObject(tmp)) {\n                        list.push(tmp);\n                    } else if (FM.Util.isArray(tmp)) {\n                        Array.prototype.push.apply(list, tmp);\n                    }\n                }\n            }\n            return list;\n        }\n    }\n});\n","/*\n    add by Chenx on 2017-5-9\n    \n */\nFM.mapApi.render.Render = L.Class.extend({\n    getSymbol: function (feature, zoom) {\n        var renderer = this.getRenderer(feature, zoom);\n        if (!renderer) {\n            throw new Error(':' + feature.properties.geoLiveType);\n        }\n        return renderer.getSymbol();\n    },\n\n    getHighlightSymbol: function (feature, zoom) {\n        var renderer = this.getRenderer(feature, zoom);\n        if (!renderer) {\n            throw new Error(':' + feature.properties.geoLiveType);\n        }\n        return renderer.getHighlightSymbol();\n    },\n\n    /**\n     * @param  {Object}\n     * @param  {int}\n     * @return {Object}\n     * \n     */\n    getRenderer: function (feature, zoom) {\n        return null;\n    }\n});\n","/*\n    add by Chenx on 2017-5-9\n    \n */\nFM.mapApi.render.Renderer = L.Class.extend({\n    _symbolFactory: fastmap.mapApi.symbol.GetSymbolFactory(),\n    _geometryFactory: fastmap.mapApi.symbol.GeometryFactory.getInstance(),\n\n    initialize: function (feature, zoom) {\n        this._feature = feature;\n        this._zoom = zoom;\n    },\n\n    /**\n     * @param  {Object}\n     * @param  {int}\n     * @return {Object}\n     * \n     */\n    getSymbol: function (feature, zoom) {\n        throw new Error('RenderergetSymbol');\n    },\n\n    /**\n     * @param  {Object}\n     * @param  {int}\n     * @return {Object}\n     * \n     */\n    getHighlightSymbol: function (feature, zoom) {\n        throw new Error('RenderergetHighlightSymbol');\n    }\n});\n","/**\n * Created by xujie on 2016/11/26.\n */\nFM.mapApi.render.GeoLiveHighlight = L.Class.extend({\n    initialize: function (options) {\n        this.geoLiveObject = options;\n        this.items = [];\n        this.highlightConfig = FM.mapApi.render.highlight;\n        this.feedback = new fastmap.mapApi.Feedback();\n\n        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        this.featureSelector = fastmap.mapApi.FeatureSelector.getInstance();\n        this.geometryAlgorithm = fastmap.mapApi.geometry.GeometryAlgorithm.getInstance();\n    },\n\n    highlight: function () {\n        if (!this.geoLiveObject) {\n            return;\n        }\n\n        var type = this.geoLiveObject.geoLiveType;\n        var rule = this.getRuleByType(type);\n\n        // \n        this.highlightObject(this.geoLiveObject, rule);\n\n        this.addToFeedback();\n    },\n\n    refresh: function () {\n        this.items = [];\n        this.feedback.clear();\n        this.highlight();\n    },\n\n    addToFeedback: function () {\n        this.items = this.items.sort(function (a, b) {\n            return a.zIndex - b.zIndex;\n        });\n\n        this.items.forEach(function (item, index, array) {\n            if (item.geometry) {\n                this.feedback.add(item.geometry, item.symbol);\n            } else {\n                this.feedback.addPid(item.pid, item.featureType, item.symbol);\n            }\n        }, this);\n    },\n\n    getRuleByType: function (type) {\n        return this.highlightConfig[type];\n    },\n\n    highlightObject: function (geoLiveObject, rule) {\n        // \n        this.highlightMain(geoLiveObject, rule);\n\n        // topo\n        if (rule.topo) {\n            this.highlightTopo(geoLiveObject, rule.topo);\n        }\n    },\n\n    highlightMain: function (value, main) {\n        var type = main.type;\n        if (!type) {\n            return;\n        }\n        switch (type) {\n            case 'geoLiveObject':\n                this.highlightGeoLiveObject(value, main);\n                break;\n            case 'pid':\n                this.highlightPid(value, main);\n                break;\n            case 'symbol':\n                this.highlightSymbol(value, main);\n                break;\n            case 'geometry':\n                this.highlightGeometry(value, main);\n                break;\n            case 'Text':\n                this.highlightText(value, main);\n                break;\n            default:\n                throw new Error('' + type + '');\n        }\n    },\n\n    highlightGeoLiveObject: function (geoLiveObject, main) {\n        if (!geoLiveObject) {\n            return;\n        }\n        var layerId = main.layer;\n        var key = main.key;\n        var zIndex = main.zIndex;\n        var symbolName = '';\n        var pid = geoLiveObject[key];\n\n        if (!layerId || !key || !pid) {\n            return;\n        }\n\n        symbolName = this.getSymbolNameFromMain(geoLiveObject, main);\n\n        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));\n        if (!symbol) {\n            return;\n        }\n\n        var feature = this.featureSelector.selectByFeatureId(pid, layerId);\n        var item;\n        if (feature) {\n            var geometryType = this.symbolFactory.getGeometryTypeBySymbol(symbol);\n\n            var geometry = feature.geometry;\n\n            var geometries = this.geometryAlgorithm.getGeometriesByType(geometry, geometryType);\n\n            for (var i = 0; i < geometries.length; ++i) {\n                item = {\n                    geometry: geometries[i]\n                };\n                this.addItem(item, symbol, zIndex);\n            }\n        } else {\n            item = {\n                pid: pid,\n                featureType: layerId\n            };\n            this.addItem(item, symbol, zIndex);\n        }\n    },\n\n    highlightPid: function (pid, main) {\n        var layerId = main.layer;\n        var key = main.key;\n        var zIndex = main.zIndex;\n        var symbolName = main.defaultSymbol;\n\n        if (!layerId || !pid) {\n            return;\n        }\n\n        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));\n        if (!symbol) {\n            return;\n        }\n\n        var feature = this.featureSelector.selectByFeatureId(pid, layerId);\n        var item;\n        if (feature) {\n            item = {\n                geometry: feature.geometry\n            };\n            this.addItem(item, symbol, zIndex);\n        } else {\n            item = {\n                pid: pid,\n                featureType: layerId\n            };\n            this.addItem(item, symbol, zIndex);\n        }\n    },\n\n    highlightSymbol: function (geoLiveObject, main) {\n        if (!geoLiveObject) {\n            return;\n        }\n        var layerId = main.layer;\n        var key = main.key;\n        var zIndex = main.zIndex;\n        var symbolName = '';\n        var pid = geoLiveObject[key];\n\n        if (!layerId || !key || !pid) {\n            return;\n        }\n\n        symbolName = this.getSymbolNameFromMain(geoLiveObject, main);\n\n        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));\n        if (!symbol) {\n            return;\n        }\n\n        var feature = this.featureSelector.selectByFeatureId(pid, layerId);\n        var item;\n        if (feature) {\n            var geometry = feature.geometry;\n\n            var geometries = this.geometryAlgorithm.getGeometriesByType(geometry, 'Point');\n\n            for (var i = 0; i < geometries.length; ++i) {\n                item = {\n                    geometry: geometries[i]\n                };\n                this.addItem(item, symbol, zIndex);\n            }\n        } else {\n            item = {\n                pid: pid,\n                featureType: layerId\n            };\n            this.addItem(item, symbol, zIndex);\n        }\n    },\n\n    highlightGeometry: function (geometry, main) {\n        var zIndex = main.zIndex;\n        var symbolName = main.defaultSymbol;\n        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));\n        if (!symbol) {\n            return;\n        }\n        var type = geometry.type;\n        var item;\n        switch (type) {\n            case 'Point':\n            case 'LineString':\n            case 'Polygon':\n                item = {\n                    geometry: geometry\n                };\n                this.addItem(item, symbol, zIndex);\n                break;\n            case 'MultiPoint':\n                this.highlightMultiGeometry('Point', geometry.coordinates, symbol, zIndex);\n                break;\n            case 'MultiLineString':\n                this.highlightMultiGeometry('LineString', geometry.coordinates, symbol, zIndex);\n                break;\n            case 'MultiPolygon':\n                this.highlightMultiGeometry('Polygon', geometry.coordinates, symbol, zIndex);\n                break;\n            default:\n                throw new Error(':' + type);\n        }\n    },\n\n    highlightText: function (geoLiveObject, main) {\n        if (!geoLiveObject) {\n            return;\n        }\n        var textPropertyName = main.text;\n        var geometryPropertyName = main.geometry;\n        var zIndex = main.zIndex;\n\n        if (!textPropertyName || !geometryPropertyName || !zIndex) {\n            return;\n        }\n\n        var text = geoLiveObject[textPropertyName];\n        var geometry = geoLiveObject[geometryPropertyName];\n        if (!text || !geometry) {\n            return;\n        }\n\n        var symbolName = this.getSymbolNameFromMain(geoLiveObject, main);\n\n        var symbol = FM.Util.clone(this.symbolFactory.getSymbol(symbolName));\n        if (!symbol) {\n            return;\n        }\n\n        this.setSymbolTextProperty(symbol, text);\n\n        var geometryType = this.symbolFactory.getGeometryTypeBySymbol(symbol);\n\n        var geometries = this.geometryAlgorithm.getGeometriesByType(geometry, geometryType);\n\n        var item;\n        for (var i = 0; i < geometries.length; ++i) {\n            item = {\n                geometry: geometries[i]\n            };\n            this.addItem(item, symbol, zIndex);\n        }\n    },\n\n    setSymbolTextProperty: function (symbol, text) {\n        var type = symbol.type;\n        switch (type) {\n            case 'TextMarkerSymbol':\n            case 'TextLineSymbol':\n            case 'CenterTextLineSymbol':\n            case 'TextFillSymbol':\n                symbol.text = text;\n                break;\n            case 'CompositeMarkerSymbol':\n            case 'CompositeLineSymbol':\n            case 'CompositeFillSymbol':\n                for (var i = 0; i < symbol.symbols.length; i++) {\n                    var subSymbol = symbol.symbols[i];\n                    this.setSymbolTextProperty(subSymbol, text);\n                }\n                break;\n            default:\n                break;\n        }\n    },\n\n    highlightMultiGeometry: function (type, coordinates, symbol, zIndex) {\n        for (var i = 0; i < coordinates.length; ++i) {\n            var item = {};\n            item.geometry = {\n                type: type,\n                coordinates: coordinates[i]\n            };\n            this.addItem(item, symbol, zIndex);\n        }\n    },\n\n    addItem: function (item, symbol, zIndex) {\n        if (!item || !symbol) {\n            return;\n        }\n\n        var temp;\n        if (item.geometry) {\n            temp = {\n                geometry: item.geometry,\n                symbol: symbol,\n                zIndex: zIndex\n            };\n        } else if (item.pid && item.featureType) {\n            temp = {\n                pid: item.pid,\n                featureType: item.featureType,\n                symbol: symbol,\n                zIndex: zIndex\n            };\n        }\n\n        if (temp) {\n            this.items.push(temp);\n        }\n    },\n\n    getSymbolNameFromMain: function (geoLiveObject, main) {\n        var symbolName = '';\n        if (main.rule) {\n            symbolName = this.getSymbolNameFromRule(geoLiveObject, main.rule);\n        }\n\n        if (!symbolName) {\n            symbolName = main.defaultSymbol;\n        }\n\n        return symbolName;\n    },\n\n    highlightTopo: function (geoLiveObject, topo) {\n        var self = this;\n        for (var i = 0; i < topo.length; ++i) {\n            var part = topo[i];\n            var joinKey = part.joinKey;\n            var rule = part.highlight;\n            var topoObject = geoLiveObject[joinKey];\n            if (FM.Util.isArray(topoObject)) {\n                this.highlightObjects(topoObject, rule);\n            } else {\n                this.highlightObject(topoObject, rule);\n            }\n        }\n    },\n\n    highlightObjects: function (objectArray, rule) {\n        objectArray.forEach(function (element, index, array) {\n            this.highlightObject(element, rule);\n        }, this);\n    },\n\n    getSymbolNameFromRule: function (geoLiveObject, rule) {\n        var attribute = rule.attribute;\n        var value = geoLiveObject[attribute];\n        var symbolName = this.getSymbolNameFromForks(rule.forks, value);\n        if (!symbolName) {\n            symbolName = rule.defaultSymbol;\n        }\n        return symbolName;\n    },\n\n    getSymbolNameFromForks: function (forks, value) {\n        for (var i = 0; i < forks.length; ++i) {\n            var fork = forks[i];\n            if (value === fork.value) {\n                return fork.symbol;\n            }\n        }\n\n        return null;\n    }\n});\n","/**\n * Created by xujie on 2016/11/26.\n */\nFM.mapApi.render.HighlightController = L.Class.extend({\n    initialize: function () {\n        this.feedbackController = fastmap.mapApi.FeedbackController.getInstance();\n        this.highlightItems = {};\n    },\n\n    highlight: function (geoLiveObject) {\n        if (!geoLiveObject) {\n            return;\n        }\n        var key = geoLiveObject.rowId;\n        if (geoLiveObject instanceof fastmap.dataApi.Tip) {\n            key = geoLiveObject.pid;\n        }\n        if (geoLiveObject instanceof fastmap.dataApi.Info) {\n            key = geoLiveObject.globalId;\n        }\n        if (this.highlightItems[key]) {\n            return;\n        }\n\n        var highlight = new FM.mapApi.render.GeoLiveHighlight(geoLiveObject);\n        highlight.highlight();\n        this.highlightItems[key] = highlight;\n        this.feedbackController.add(highlight.feedback);\n        this.feedbackController.refresh();\n    },\n\n    unHighlight: function (geoLiveObject) {\n        if (!geoLiveObject) {\n            return;\n        }\n\n        var key = geoLiveObject.rowId;\n        if (geoLiveObject instanceof fastmap.dataApi.Tip) {\n            key = geoLiveObject.pid;\n        }\n\n        var highlight = this.highlightItems[key];\n        if (!highlight) {\n            return;\n        }\n\n        this.feedbackController.del(highlight.feedback);\n        this.feedbackController.refresh();\n        delete this.highlightItems[key];\n    },\n\n    clear: function () {\n        var keys = Object.getOwnPropertyNames(this.highlightItems);\n        keys.forEach(function (element, index, array) {\n            var highlight = this.highlightItems[element];\n            this.feedbackController.del(highlight.feedback);\n            delete this.highlightItems[element];\n        }, this);\n\n        this.feedbackController.refresh();\n    },\n\n    isCleared: function () {\n        var keys = Object.getOwnPropertyNames(this.highlightItems);\n        return keys.length === 0;\n    },\n\n    refresh: function () {\n        var keys = Object.getOwnPropertyNames(this.highlightItems);\n        keys.forEach(function (element, index, array) {\n            var highlight = this.highlightItems[element];\n            this.feedbackController.del(highlight.feedback);\n            highlight.refresh();\n            this.feedbackController.add(highlight.feedback);\n        }, this);\n\n        this.feedbackController.refresh();\n    },\n\n    destroy: function () {\n        FM.mapApi.render.HighlightController.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!FM.mapApi.render.HighlightController.instance) {\n                FM.mapApi.render.HighlightController.instance =\n                    new FM.mapApi.render.HighlightController();\n            }\n            return FM.mapApi.render.HighlightController.instance;\n        }\n    }\n});\n","/**\n * Created by Chenx on 2017/7/7.\n * \n */\nFM.mapApi.render.FlashHighlightController = FM.Class.extend({\n    options: {},\n\n    initialize: function (option) {\n        FM.setOptions(this, option);\n\n        this.highlightCtrl = FM.mapApi.render.HighlightController.getInstance();\n        this.symbolFactory = fastmap.mapApi.symbol.GetSymbolFactory();\n        this.feedbackCtrl = fastmap.mapApi.FeedbackController.getInstance();\n        this.feedback = new fastmap.mapApi.Feedback();\n        this.feedback.priority = 1;\n        this.feedbackCtrl.add(this.feedback);\n\n        this.interval = null;\n    },\n    _clearFeedback: function () {\n        if (this.interval) {\n            clearInterval(this.interval);\n            this.interval = null;\n        }\n        this.feedback.clear();\n    },\n    resetFeedback: function (data) {\n        data = data || [];\n        this._clearFeedback();\n\n        if (data.length > 0) {\n            var item,\n                symbol;\n            for (var i = 0; i < data.length; i++) {\n                item = data[i];\n                if (item.featureType && item.pid && item.symbolName) {\n                    symbol = this.symbolFactory.getSymbol(item.symbolName);\n                    this.feedback.addPid(item.pid, item.featureType, symbol);\n                }\n            }\n\n            var that = this;\n            var items = this.feedback.getDrawItems().slice();\n            this.interval = setInterval(function () {\n                // \n                // \n                // topoeditControl\n                if (that.highlightCtrl.isCleared()) {\n                    that.clearFeedback();\n                    return;\n                }\n\n                if (that.feedback.getDrawItems().length > 0) {\n                    that.feedback.clear();\n                } else {\n                    that.feedback.setDrawItems(items);\n                }\n                that.feedbackCtrl.refresh();\n            }, 300);\n        }\n\n        this.feedbackCtrl.refresh();\n    },\n\n    clearFeedback: function () {\n        this._clearFeedback();\n        this.feedbackCtrl.refresh();\n    },\n\n    destroy: function () {\n        FM.mapApi.render.FlashHighlightController.instance = null;\n    },\n\n    statics: {\n        instance: null,\n\n        getInstance: function () {\n            if (!FM.mapApi.render.FlashHighlightController.instance) {\n                FM.mapApi.render.FlashHighlightController.instance =\n                    new FM.mapApi.render.FlashHighlightController();\n            }\n            return FM.mapApi.render.FlashHighlightController.instance;\n        }\n    }\n});\n"],"sourceRoot":"/src/scripts/mapApi"}